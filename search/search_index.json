{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Purpose of the project Introduction For data analysts, the output of a project is typically a report of the derived results of the dataset, be it an algorithm, the summary of a regression model and the significance of variables or some other sort of requested insight. In order to simplify the writing of such reports, various tools have been invented, the most well known ones being RMarkdown in R and Jupyter that is mostly used with Python (but supports many other languages as well). These tools are incarnations of a Literate Programming , that had its beginnings with tools such as noweb and aims to mix regular text with code in an article, but of course that have been developed much further since then to extend to interactively editing and running code such as in Jupyter, processing entire books (see e.g. bookdown or also inverting the text and code-blocks such that the regular text becomes comments inside a script in e.g. R or Python (see jupytext ). Jupyter and related tools As this package is only for Python, I will focus in the following on aspects of these tools for this language, but some comments are certainly also valid for other frameworks. Jupyter is for sure the most used framework for this purpose with a very large set of tools and users. Since its invention, it has certainly changed how datascience is being done in many organizations. Some of its most noteworthy advantages are: - Deployment through the browser without the need of direct access to hardware. Due to this it is also simpler to have users work with on-demand resources - A good console with outputs of tables and figures that make rapid development easy - Tools such as turning jupyter notebooks into websites - Jupyterlab, which is (almost) a full Python IDE Next to these positive sides are however also a few shortcomings. Shortcomings of Jupyter One of the side-effects of structure of Jupyter-notebooks is their linear form where code and output blocks are mixed, which can cause notebooks to become very large and particular places can be hard to find. Code sharing between notebooks is also not easily possible, requiring to write libraries outside the notebook to fulfill this purpose, mixing very different styles of coding. Also related to their design of one notebook, one html page, parametrization of notebooks can be cumbersome and is certainly not as simple and straightforward as a function. Another drawback is the fact that notebooks hard or impossible to edit in many IDEs, requiring the use of a different environment than the one the scientist is used to. Tools like jupytext can help here, but they still rely on the special interpretation of comments to function properly and inherently still follow the linear form and one file one document view of Jupyter (and pretty much any other Literate Programming approach). Next to these, some more issues are that: - Some debuggers such as pudb are not supported well supported. - Jupytext does not solve the issue that in remote ssh development shells the viewing of graphics can be complicated. - The display options for code and complex tables are limited. This package This package was developed to give an alternative to Jupyter providing more sophisticated ways to create reports while retaining (some) of the interactivity of the browser. All this will be done in pure python without any specially formatted file or overloading of the meaning of any comments. It will further retain the ability to include live code-blocks from the scripts in the output, but less intrusively than for Jupyter notebooks. In particular, it is intended to work by providing functions to easily write out markdown pages that are part of an mkdocs site. For this convenience functions for Figures and Tables as well as other objects are available. For viewing these results, mkdocs is used that contains a development server that automatically watches input files and updates the browser on any change. This update process is typically very fast. Last, a plugin for the ipython console is provided that writes any appropriate output in the console to a special markdown page that can then also be viewed using mkdocs. This way, it is easy to visualize figues and tables from the ipython console, where tables in the browser are sortable or can even be filtered, thus providing better functionality than default Jupyter tables in an output cell.","title":"Home"},{"location":"#purpose-of-the-project","text":"","title":"Purpose of the project"},{"location":"#introduction","text":"For data analysts, the output of a project is typically a report of the derived results of the dataset, be it an algorithm, the summary of a regression model and the significance of variables or some other sort of requested insight. In order to simplify the writing of such reports, various tools have been invented, the most well known ones being RMarkdown in R and Jupyter that is mostly used with Python (but supports many other languages as well). These tools are incarnations of a Literate Programming , that had its beginnings with tools such as noweb and aims to mix regular text with code in an article, but of course that have been developed much further since then to extend to interactively editing and running code such as in Jupyter, processing entire books (see e.g. bookdown or also inverting the text and code-blocks such that the regular text becomes comments inside a script in e.g. R or Python (see jupytext ).","title":"Introduction"},{"location":"#jupyter-and-related-tools","text":"As this package is only for Python, I will focus in the following on aspects of these tools for this language, but some comments are certainly also valid for other frameworks. Jupyter is for sure the most used framework for this purpose with a very large set of tools and users. Since its invention, it has certainly changed how datascience is being done in many organizations. Some of its most noteworthy advantages are: - Deployment through the browser without the need of direct access to hardware. Due to this it is also simpler to have users work with on-demand resources - A good console with outputs of tables and figures that make rapid development easy - Tools such as turning jupyter notebooks into websites - Jupyterlab, which is (almost) a full Python IDE Next to these positive sides are however also a few shortcomings.","title":"Jupyter and related tools"},{"location":"#shortcomings-of-jupyter","text":"One of the side-effects of structure of Jupyter-notebooks is their linear form where code and output blocks are mixed, which can cause notebooks to become very large and particular places can be hard to find. Code sharing between notebooks is also not easily possible, requiring to write libraries outside the notebook to fulfill this purpose, mixing very different styles of coding. Also related to their design of one notebook, one html page, parametrization of notebooks can be cumbersome and is certainly not as simple and straightforward as a function. Another drawback is the fact that notebooks hard or impossible to edit in many IDEs, requiring the use of a different environment than the one the scientist is used to. Tools like jupytext can help here, but they still rely on the special interpretation of comments to function properly and inherently still follow the linear form and one file one document view of Jupyter (and pretty much any other Literate Programming approach). Next to these, some more issues are that: - Some debuggers such as pudb are not supported well supported. - Jupytext does not solve the issue that in remote ssh development shells the viewing of graphics can be complicated. - The display options for code and complex tables are limited.","title":"Shortcomings of Jupyter"},{"location":"#this-package","text":"This package was developed to give an alternative to Jupyter providing more sophisticated ways to create reports while retaining (some) of the interactivity of the browser. All this will be done in pure python without any specially formatted file or overloading of the meaning of any comments. It will further retain the ability to include live code-blocks from the scripts in the output, but less intrusively than for Jupyter notebooks. In particular, it is intended to work by providing functions to easily write out markdown pages that are part of an mkdocs site. For this convenience functions for Figures and Tables as well as other objects are available. For viewing these results, mkdocs is used that contains a development server that automatically watches input files and updates the browser on any change. This update process is typically very fast. Last, a plugin for the ipython console is provided that writes any appropriate output in the console to a special markdown page that can then also be viewed using mkdocs. This way, it is easy to visualize figues and tables from the ipython console, where tables in the browser are sortable or can even be filtered, thus providing better functionality than default Jupyter tables in an output cell.","title":"This package"},{"location":"basic/","text":"Basic formatting elements Headings Content Code Available headings md . H1 ( \"Header type 1\" ) md . H2 ( \"Header type 2\" ) md . H3 ( \"Header type 3\" ) md . H4 ( \"Header type 4\" ) md . H5 ( \"Header type 5\" ) md . H6 ( \"Header type 6\" ) md . H7 ( \"Header type 7\" ) /home/hhoeflin/projects/mkreports/docs/staging/basic.py 10 11 12 13 14 15 16 17 18 19 20 21 p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) Lists Content Code First item Second item Third item Some fruit: apples pears strawberry A code block: Hello world print ( \"Hello world\" ) /home/hhoeflin/projects/mkreports/docs/staging/basic.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) Links Content Code A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) A link back to the first heading A link to another page Images Or just to any page Google Or of course also just straight markdown Google /home/hhoeflin/projects/mkreports/docs/staging/basic.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + md . Link ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + md . Link ( \"Images\" , to_page_path = report . page ( \"images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Basic"},{"location":"basic/#basic-formatting-elements","text":"","title":"Basic formatting elements"},{"location":"basic/#headings","text":"Content Code Available headings md . H1 ( \"Header type 1\" ) md . H2 ( \"Header type 2\" ) md . H3 ( \"Header type 3\" ) md . H4 ( \"Header type 4\" ) md . H5 ( \"Header type 5\" ) md . H6 ( \"Header type 6\" ) md . H7 ( \"Header type 7\" ) /home/hhoeflin/projects/mkreports/docs/staging/basic.py 10 11 12 13 14 15 16 17 18 19 20 21 p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , )","title":"Headings"},{"location":"basic/#lists","text":"Content Code First item Second item Third item Some fruit: apples pears strawberry A code block: Hello world print ( \"Hello world\" ) /home/hhoeflin/projects/mkreports/docs/staging/basic.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list )","title":"Lists"},{"location":"basic/#links","text":"Content Code A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) A link back to the first heading A link to another page Images Or just to any page Google Or of course also just straight markdown Google /home/hhoeflin/projects/mkreports/docs/staging/basic.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + md . Link ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + md . Link ( \"Images\" , to_page_path = report . page ( \"images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Links"},{"location":"code_blocks/","text":"Code blocks Tracking code (tabbed) Content Code One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. fib(3) = 2 By default, the tabbed version will be used, but there are also the options top-c : Collapsed code block at the top top-o : Open code block at the top bottom-c : Collapsed code block at the bottom bottom-o : Open code block at the bottom The default style can be set when creating the page using the code_layout parameter, but can also be set one at a time later using the ctx method on a page. /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) Tracking code (top-c) Code /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 52 53 54 55 56 p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as a collapsed admonition before the output. fib(4) = 3 Tracking code (top-o) /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 59 60 61 62 63 p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as an open code block before the output. fib(5) = 5 Tracking code (bottom-c) The code as a collapsed admoniton after the output. fib(6) = 8 Code /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 66 67 68 69 70 p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) Tracking code (bottom-o) The code as an open code block after the output. fib(7) = 13 /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 73 74 75 76 77 p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) Adding code files Content Code In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. Code from mkreports import Report def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" p = report . page ( \"code_blocks.md\" , truncate = True ) p . H1 ( \"Code blocks\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 80 81 82 83 84 85 86 87 88 89 p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) And at the end will add another copy of the code-file, but automatically when ending the page context manager.","title":"Code Blocks"},{"location":"code_blocks/#code-blocks","text":"","title":"Code blocks"},{"location":"code_blocks/#tracking-code-tabbed","text":"Content Code One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. fib(3) = 2 By default, the tabbed version will be used, but there are also the options top-c : Collapsed code block at the top top-o : Open code block at the top bottom-c : Collapsed code block at the bottom bottom-o : Open code block at the bottom The default style can be set when creating the page using the code_layout parameter, but can also be set one at a time later using the ctx method on a page. /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" )","title":"Tracking code (tabbed)"},{"location":"code_blocks/#tracking-code-top-c","text":"Code /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 52 53 54 55 56 p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as a collapsed admonition before the output. fib(4) = 3","title":"Tracking code (top-c)"},{"location":"code_blocks/#tracking-code-top-o","text":"/home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 59 60 61 62 63 p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as an open code block before the output. fib(5) = 5","title":"Tracking code (top-o)"},{"location":"code_blocks/#tracking-code-bottom-c","text":"The code as a collapsed admoniton after the output. fib(6) = 8 Code /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 66 67 68 69 70 p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" )","title":"Tracking code (bottom-c)"},{"location":"code_blocks/#tracking-code-bottom-o","text":"The code as an open code block after the output. fib(7) = 13 /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 73 74 75 76 77 p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" )","title":"Tracking code (bottom-o)"},{"location":"code_blocks/#adding-code-files","text":"Content Code In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. Code from mkreports import Report def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" p = report . page ( \"code_blocks.md\" , truncate = True ) p . H1 ( \"Code blocks\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) /home/hhoeflin/projects/mkreports/docs/staging/code_blocks.py 80 81 82 83 84 85 86 87 88 89 p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) And at the end will add another copy of the code-file, but automatically when ending the page context manager.","title":"Adding code files"},{"location":"images/","text":"Images Supported formats Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an ImageFile object. PIL Content Code PIL is the standard python image library. Image objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. /home/hhoeflin/projects/mkreports/docs/staging/images.py 31 32 33 34 35 36 37 38 39 40 41 42 43 p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) Matplotlib Content Code For many scientific graphing purposes, matplotlib is either the direct choice or the backend being used for plotting. /home/hhoeflin/projects/mkreports/docs/staging/images.py 47 48 49 50 51 52 53 54 55 56 p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Image ( fig ) Plotnine Content Code Any plots created by plotnine can be included directly. The code below is from the beginner example of the library. /home/hhoeflin/projects/mkreports/docs/staging/images.py 59 60 61 62 63 64 65 66 67 68 69 70 71 p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) Seaborn Content Code Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the figure attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. /home/hhoeflin/projects/mkreports/docs/staging/images.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) Altair Content Code /home/hhoeflin/projects/mkreports/docs/staging/images.py 104 105 106 107 108 109 110 111 112 113 114 115 116 import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) vegaEmbed(\"#altair_id-0\", \"../images_store/altair-a7a2eb773c7d9454c694b490a77e5a7e.csv\") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); Plotly Content Code /home/hhoeflin/projects/mkreports/docs/staging/images.py 119 120 121 122 import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) fetch('../images_store/plotly-2c4e085bcb294e03c4c01a147570a8c5.json') .then(function (response) { return response.json(); }) .then(function (data) { doPlotly(data); }) .catch(function (err) { console.log('error: ' + err); }); function doPlotly(plotlyJson) { Plotly.newPlot(\"plotly_id-0\", { \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }) } Different image sizes Warning Still to be implemented","title":"Images"},{"location":"images/#images","text":"","title":"Images"},{"location":"images/#supported-formats","text":"Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an ImageFile object.","title":"Supported formats"},{"location":"images/#pil","text":"Content Code PIL is the standard python image library. Image objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. /home/hhoeflin/projects/mkreports/docs/staging/images.py 31 32 33 34 35 36 37 38 39 40 41 42 43 p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img )","title":"PIL"},{"location":"images/#matplotlib","text":"Content Code For many scientific graphing purposes, matplotlib is either the direct choice or the backend being used for plotting. /home/hhoeflin/projects/mkreports/docs/staging/images.py 47 48 49 50 51 52 53 54 55 56 p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Image ( fig )","title":"Matplotlib"},{"location":"images/#plotnine","text":"Content Code Any plots created by plotnine can be included directly. The code below is from the beginner example of the library. /home/hhoeflin/projects/mkreports/docs/staging/images.py 59 60 61 62 63 64 65 66 67 68 69 70 71 p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), )","title":"Plotnine"},{"location":"images/#seaborn","text":"Content Code Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the figure attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. /home/hhoeflin/projects/mkreports/docs/staging/images.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), )","title":"Seaborn"},{"location":"images/#altair","text":"Content Code /home/hhoeflin/projects/mkreports/docs/staging/images.py 104 105 106 107 108 109 110 111 112 113 114 115 116 import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) vegaEmbed(\"#altair_id-0\", \"../images_store/altair-a7a2eb773c7d9454c694b490a77e5a7e.csv\") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn);","title":"Altair"},{"location":"images/#plotly","text":"Content Code /home/hhoeflin/projects/mkreports/docs/staging/images.py 119 120 121 122 import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) fetch('../images_store/plotly-2c4e085bcb294e03c4c01a147570a8c5.json') .then(function (response) { return response.json(); }) .then(function (data) { doPlotly(data); }) .catch(function (err) { console.log('error: ' + err); }); function doPlotly(plotlyJson) { Plotly.newPlot(\"plotly_id-0\", { \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }) }","title":"Plotly"},{"location":"images/#different-image-sizes","text":"Warning Still to be implemented","title":"Different image sizes"},{"location":"markdown/","text":"Adding markdown elements to a page Opening pages The first step is to define a report directory and open a page in it. There is always at least the 'index.md' page included in any report, which is listed in the navigation under Home . from mkreports import Report report = Report () page = report . page ( 'index.md' ) Adding markdown There are overall 3 ways to use and add markdown elements to a page. Each of these provides a different level of convenient. As a summary for the user: - If you want to add an element immediately to a page, use the markdown classes directly available as attributes in the page itself. These preset certain parameters and add the markdown object directly to the page after it is instantiated. - If you need to build up more complicated markdown objects before adding it to a page (e.g. in the case of nested objects), use the Page.md attribute to get the markdown object that pre-populates certain parameters to sensible defaults - In some special circumstances it may be necessary to get the raw markdown with full control. In this case the mkreports.md module can be used. In more detail below the three options, in reverse order from most basic to most convenient. md module The mkreports.md module provides all markdown functionality that can be used in the package. In the rest of this documentation, various of these are being explained. As the most basic there is however certain information that can get cumbersome to input. One example is the store_path . Certain markdown elements, such as tables, store the information to be displayed in a file in subdirectory of the reports directory. As the page on which the markdown element is added is not specified at this point (and neither is the report), this store_path needs to be explicitly passed into the element. For most use-cases, this basic level does not need to be used by the end-user. This markdown object then has to be added to a page using the add method. md-attribute of a page Each Page instance also md attribute. This attribute is a proxy-object to the md -submodule. When requesting an object, the store_path and certain required ids (e.g. for Altair or DataTable objects) will be pre-populated by the page instance so that the user doesn't have to worry about it. The resulting markdown object then has to be added to the page again using the add method. Markdown attributes of a page This is very similar to the Page.md attribute, except that the markdown classes are directly available as attributes on the Page class. After instantiating the markdown element, it immediately gets added to the page automatically. Keyword parameters that are available on Page.add can also be specified and will be passed along appropriately.","title":"Markdown"},{"location":"markdown/#adding-markdown-elements-to-a-page","text":"","title":"Adding markdown elements to a page"},{"location":"markdown/#opening-pages","text":"The first step is to define a report directory and open a page in it. There is always at least the 'index.md' page included in any report, which is listed in the navigation under Home . from mkreports import Report report = Report () page = report . page ( 'index.md' )","title":"Opening pages"},{"location":"markdown/#adding-markdown","text":"There are overall 3 ways to use and add markdown elements to a page. Each of these provides a different level of convenient. As a summary for the user: - If you want to add an element immediately to a page, use the markdown classes directly available as attributes in the page itself. These preset certain parameters and add the markdown object directly to the page after it is instantiated. - If you need to build up more complicated markdown objects before adding it to a page (e.g. in the case of nested objects), use the Page.md attribute to get the markdown object that pre-populates certain parameters to sensible defaults - In some special circumstances it may be necessary to get the raw markdown with full control. In this case the mkreports.md module can be used. In more detail below the three options, in reverse order from most basic to most convenient.","title":"Adding markdown"},{"location":"markdown/#md-module","text":"The mkreports.md module provides all markdown functionality that can be used in the package. In the rest of this documentation, various of these are being explained. As the most basic there is however certain information that can get cumbersome to input. One example is the store_path . Certain markdown elements, such as tables, store the information to be displayed in a file in subdirectory of the reports directory. As the page on which the markdown element is added is not specified at this point (and neither is the report), this store_path needs to be explicitly passed into the element. For most use-cases, this basic level does not need to be used by the end-user. This markdown object then has to be added to a page using the add method.","title":"md module"},{"location":"markdown/#md-attribute-of-a-page","text":"Each Page instance also md attribute. This attribute is a proxy-object to the md -submodule. When requesting an object, the store_path and certain required ids (e.g. for Altair or DataTable objects) will be pre-populated by the page instance so that the user doesn't have to worry about it. The resulting markdown object then has to be added to the page again using the add method.","title":"md-attribute of a page"},{"location":"markdown/#markdown-attributes-of-a-page","text":"This is very similar to the Page.md attribute, except that the markdown classes are directly available as attributes on the Page class. After instantiating the markdown element, it immediately gets added to the page automatically. Keyword parameters that are available on Page.add can also be specified and will be passed along appropriately.","title":"Markdown attributes of a page"},{"location":"quickstart/","text":"Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. import pandas as pd import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code /home/hhoeflin/projects/mkreports/docs/staging/quickstart.py 31 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code /home/hhoeflin/projects/mkreports/docs/staging/quickstart.py 35 36 37 38 39 40 41 42 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. import pandas as pd import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table","text":"Content Code /home/hhoeflin/projects/mkreports/docs/staging/quickstart.py 31 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots","text":"Content Code /home/hhoeflin/projects/mkreports/docs/staging/quickstart.py 35 36 37 38 39 40 41 42 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"tables/","text":"Different ways of handling tables Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. Markdown tables Content Code Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. name mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 /home/hhoeflin/projects/mkreports/docs/staging/tables.py 35 36 37 38 39 40 41 42 p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) DataTable javascript library Content Code Here the same table, but displayed using the DataTables plugin. With this, we get automatic paging, searching as well as sorting by columns. Header filters Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. A numeric column gets a range selector A categorical or boolean column a dropdown selection Any other column a text-field. /home/hhoeflin/projects/mkreports/docs/staging/tables.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) $(document).ready( function () { var myTable = $('#datatable_id-0').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"name\"}, {\"title\": \"mpg\"}, {\"title\": \"cyl\"}, {\"title\": \"disp\"}, {\"title\": \"hp\"}, {\"title\": \"drat\"}, {\"title\": \"wt\"}, {\"title\": \"qsec\"}, {\"title\": \"vs\"}, {\"title\": \"am\"}, {\"title\": \"gear\"}, {\"title\": \"carb\"}], \"ajax\": \"../tables_store/datatable-ca9b6f052f673e1d46f468ebb1ccc5d1.json\"}); } ); $(document).ready( function () { var myTable = $('#datatable_id-1').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"name\"}, {\"title\": \"age\"}, {\"title\": \"hair\"}, {\"title\": \"married\"}], \"ajax\": \"../tables_store/datatable-580c4149445c9b58b5740c532e20a5a0.json\"}); yadcf.init(myTable, [{\"column_number\": 0, \"filter_type\": \"text\"}, {\"column_number\": 1, \"filter_type\": \"range_number\"}, {\"column_number\": 2, \"filter_type\": \"select\"}, {\"column_number\": 3, \"filter_type\": \"select\"}]); } ); Tabulator javascript library Content Code This time, we use the Tabulator library. A library with a lot of interesting functionality. Currently limited support. Header filters We also can enable header filtering. For the datatypes numeric boolean categorical str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are Input filter for the names Range filter with min and max for age Select dropdown for hair color and checkbox for marital status /home/hhoeflin/projects/mkreports/docs/staging/tables.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. Currently limited support. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"title\": \"name\"}, {\"field\": \"mpg\", \"title\": \"mpg\"}, {\"field\": \"cyl\", \"title\": \"cyl\"}, {\"field\": \"disp\", \"title\": \"disp\"}, {\"field\": \"hp\", \"title\": \"hp\"}, {\"field\": \"drat\", \"title\": \"drat\"}, {\"field\": \"wt\", \"title\": \"wt\"}, {\"field\": \"qsec\", \"title\": \"qsec\"}, {\"field\": \"vs\", \"title\": \"vs\"}, {\"field\": \"am\", \"title\": \"am\"}, {\"field\": \"gear\", \"title\": \"gear\"}, {\"field\": \"carb\", \"title\": \"carb\"}], \"ajaxURL\": \"../tables_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); var table = new Tabulator('#tabulator_id-1', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"age\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Age\"}, {\"field\": \"hair\", \"headerFilter\": \"select\", \"headerFilterParams\": {\"values\": [\"\", \"brown\", \"green\", \"red\"]}, \"title\": \"Hair\"}, {\"field\": \"married\", \"headerFilter\": \"tickCross\", \"formatter\": \"tickCross\", \"headerFilterParams\": {\"tristate\": true}, \"title\": \"Married\"}], \"ajaxURL\": \"../tables_store/tabulator-75b468c8a8bcf5fff9d211e88d0e6972.json\"}); Notes Content Code Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the str funtion is called. If this is not ok, please transform the table columns accordingly. /home/hhoeflin/projects/mkreports/docs/staging/tables.py 107 108 109 110 111 112 113 114 115 p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" )","title":"Tables"},{"location":"tables/#different-ways-of-handling-tables","text":"Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed.","title":"Different ways of handling tables"},{"location":"tables/#markdown-tables","text":"Content Code Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. name mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 /home/hhoeflin/projects/mkreports/docs/staging/tables.py 35 36 37 38 39 40 41 42 p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False ))","title":"Markdown tables"},{"location":"tables/#datatable-javascript-library","text":"Content Code Here the same table, but displayed using the DataTables plugin. With this, we get automatic paging, searching as well as sorting by columns.","title":"DataTable javascript library"},{"location":"tables/#header-filters","text":"Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. A numeric column gets a range selector A categorical or boolean column a dropdown selection Any other column a text-field. /home/hhoeflin/projects/mkreports/docs/staging/tables.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) $(document).ready( function () { var myTable = $('#datatable_id-0').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"name\"}, {\"title\": \"mpg\"}, {\"title\": \"cyl\"}, {\"title\": \"disp\"}, {\"title\": \"hp\"}, {\"title\": \"drat\"}, {\"title\": \"wt\"}, {\"title\": \"qsec\"}, {\"title\": \"vs\"}, {\"title\": \"am\"}, {\"title\": \"gear\"}, {\"title\": \"carb\"}], \"ajax\": \"../tables_store/datatable-ca9b6f052f673e1d46f468ebb1ccc5d1.json\"}); } ); $(document).ready( function () { var myTable = $('#datatable_id-1').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"name\"}, {\"title\": \"age\"}, {\"title\": \"hair\"}, {\"title\": \"married\"}], \"ajax\": \"../tables_store/datatable-580c4149445c9b58b5740c532e20a5a0.json\"}); yadcf.init(myTable, [{\"column_number\": 0, \"filter_type\": \"text\"}, {\"column_number\": 1, \"filter_type\": \"range_number\"}, {\"column_number\": 2, \"filter_type\": \"select\"}, {\"column_number\": 3, \"filter_type\": \"select\"}]); } );","title":"Header filters"},{"location":"tables/#tabulator-javascript-library","text":"Content Code This time, we use the Tabulator library. A library with a lot of interesting functionality. Currently limited support.","title":"Tabulator javascript library"},{"location":"tables/#header-filters_1","text":"We also can enable header filtering. For the datatypes numeric boolean categorical str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are Input filter for the names Range filter with min and max for age Select dropdown for hair color and checkbox for marital status /home/hhoeflin/projects/mkreports/docs/staging/tables.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. Currently limited support. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"title\": \"name\"}, {\"field\": \"mpg\", \"title\": \"mpg\"}, {\"field\": \"cyl\", \"title\": \"cyl\"}, {\"field\": \"disp\", \"title\": \"disp\"}, {\"field\": \"hp\", \"title\": \"hp\"}, {\"field\": \"drat\", \"title\": \"drat\"}, {\"field\": \"wt\", \"title\": \"wt\"}, {\"field\": \"qsec\", \"title\": \"qsec\"}, {\"field\": \"vs\", \"title\": \"vs\"}, {\"field\": \"am\", \"title\": \"am\"}, {\"field\": \"gear\", \"title\": \"gear\"}, {\"field\": \"carb\", \"title\": \"carb\"}], \"ajaxURL\": \"../tables_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); var table = new Tabulator('#tabulator_id-1', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"age\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Age\"}, {\"field\": \"hair\", \"headerFilter\": \"select\", \"headerFilterParams\": {\"values\": [\"\", \"brown\", \"green\", \"red\"]}, \"title\": \"Hair\"}, {\"field\": \"married\", \"headerFilter\": \"tickCross\", \"formatter\": \"tickCross\", \"headerFilterParams\": {\"tristate\": true}, \"title\": \"Married\"}], \"ajaxURL\": \"../tables_store/tabulator-75b468c8a8bcf5fff9d211e88d0e6972.json\"});","title":"Header filters"},{"location":"tables/#notes","text":"Content Code Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the str funtion is called. If this is not ok, please transform the table columns accordingly. /home/hhoeflin/projects/mkreports/docs/staging/tables.py 107 108 109 110 111 112 113 114 115 p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" )","title":"Notes"},{"location":"Reference/mkreports/_stack/","text":"FrameInfo ( NodeMixin ) Source code in mkreports/_stack.py class FrameInfo ( NodeMixin ): filename : str code_interval : Interval hilite_interval : Optional [ Interval ] curlineno : int code : List [ str ] co_name : str def __init__ ( self , filename : str , code_interval : Interval , hilite_interval : Optional [ Interval ], curlineno : int , code : List [ str ], co_name : str , parent : Optional [ FrameInfo ], children : Optional [ List [ FrameInfo ]], ): self . filename = filename self . code_interval = code_interval self . hilite_interval = hilite_interval self . curlineno = curlineno self . code = code self . co_name = co_name self . parent = parent if children : self . children = children def __str__ ( self ): header = f \"File: { self . filename } \" position = f \" { self . hilite_interval } in { self . code_interval } \" return \" \\n \" . join ([ header , position , self . focus_code ]) @property def name ( self ): return f \" { self . filename } : { self . code_interval . begin } - { self . code_interval . end } \" @property def focus_interval ( self ): if self . hilite_interval is None : return self . code_interval else : return self . hilite_interval @property def focus_code ( self ): display_code = \"\" . join ( self . code [ ( self . focus_interval . begin - self . code_interval . begin ) : ( self . focus_interval . end - self . code_interval . begin ) ] ) return display_code def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> Code : if highlight : code = \"\" . join ( self . code ) first_line = self . code_interval . begin if self . code_interval == self . focus_interval : hl_lines = None else : hl_lines = ( self . focus_interval . begin , self . focus_interval . end - 1 ) else : # no highlight, so we take the focused range code = self . focus_code first_line = self . focus_interval . begin hl_lines = None return Code ( code = dedent ( code ), title = self . filename if full_filename else Path ( self . filename ) . name , first_line = first_line , hl_lines = hl_lines , language = \"python\" , ) def _md_collect ( self , highlight ) -> List [ Tuple [ str , Code ]]: res = [( self . co_name , self . md_code ( highlight = highlight ))] for child in self . children : res . extend ( child . _md_collect ( highlight )) return res def md_tree ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\" Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. \"\"\" code_list = self . _md_collect ( highlight ) # now only take the unique ones code_list = list ({ key : None for key in code_list } . keys ()) # now we want to de-duplicate the list if len ( code_list ) > 0 : if len ( code_list ) == 1 : return code_list [ 0 ][ 1 ] else : res = Tab ( code_list [ 0 ][ 1 ], title = \"<main>\" ) for i in range ( 1 , len ( code_list )): res = res + Tab ( code_list [ i ][ 1 ], title = code_list [ i ][ 0 ] if full_filename else Path ( code_list [ i ][ 0 ]) . name , ) return res else : return Raw ( \"\" ) @classmethod def from_frame ( cls , frame , parent = None , children = None ) -> \"FrameInfo\" : code = frame . f_code # if higher_frame is None and code.co_firstlineno != 1: # raise Exception( # f\"Did not expect first line {code.co_firstlineno} when upper frame is None.\" # ) # if higher_frame is None: # code_lines = read_file(Path(code.co_filename)) # else: try : if code . co_name == \"<module>\" : code_lines = read_file ( Path ( code . co_filename )) else : code_lines = inspect . getsourcelines ( code )[ 0 ] except Exception : code_lines = [ \"Count not get source \\n \" ] return FrameInfo ( filename = code . co_filename , co_name = code . co_name , code_interval = Interval ( code . co_firstlineno , code . co_firstlineno + len ( code_lines ), ), hilite_interval = None , curlineno = frame . f_lineno , code = code_lines , parent = parent , children = children , ) md_tree ( self , highlight = True , full_filename = False ) Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. Source code in mkreports/_stack.py def md_tree ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\" Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. \"\"\" code_list = self . _md_collect ( highlight ) # now only take the unique ones code_list = list ({ key : None for key in code_list } . keys ()) # now we want to de-duplicate the list if len ( code_list ) > 0 : if len ( code_list ) == 1 : return code_list [ 0 ][ 1 ] else : res = Tab ( code_list [ 0 ][ 1 ], title = \"<main>\" ) for i in range ( 1 , len ( code_list )): res = res + Tab ( code_list [ i ][ 1 ], title = code_list [ i ][ 0 ] if full_filename else Path ( code_list [ i ][ 0 ]) . name , ) return res else : return Raw ( \"\" ) StackDiff Source code in mkreports/_stack.py class StackDiff : def __init__ ( self , first_stack : Stack , second_stack : Stack ): \"\"\" Calculate the difference of two stacks. Shows the code executed between the old stack and the new. \"\"\" self . first = first_stack self . second = second_stack self . equal = [] for idx in range ( min ( len ( self . first ), len ( self . second ))): frame_old = self . first [ idx ] frame_new = self . second [ idx ] if ( frame_old . filename == frame_new . filename and frame_old . code_interval == frame_new . code_interval ): # this is within the same function if frame_old . hilite_interval == frame_new . hilite_interval : # this is the same, no change self . equal . append ( frame_old ) else : # execution has at least moved by one code line # store the lower levels of the old frame # then the difference in the current frame to the new # then the lower levels of the new frame self . old_lower = [ FrameInfo ( filename = frame . filename , code_interval = frame . code_interval , hilite_interval = Interval ( frame . curlineno , frame . code_interval . end ), curlineno = frame . code_interval . end , code = frame . code , co_name = frame . co_name , parent = None , children = None , ) for frame in self . first [ idx + 1 :] ] middle_frame = copy ( self . first [ idx ]) middle_frame . hilite_interval = Interval ( self . first [ idx ] . focus_interval . end - 1 , self . second [ idx ] . focus_interval . end , ) self . middle = [ middle_frame ] self . new_lower = [ frame for frame in self . second [ idx + 1 :]] self . changed = self . old_lower + self . middle + self . new_lower return __init__ ( self , first_stack , second_stack ) special Calculate the difference of two stacks. Shows the code executed between the old stack and the new. Source code in mkreports/_stack.py def __init__ ( self , first_stack : Stack , second_stack : Stack ): \"\"\" Calculate the difference of two stacks. Shows the code executed between the old stack and the new. \"\"\" self . first = first_stack self . second = second_stack self . equal = [] for idx in range ( min ( len ( self . first ), len ( self . second ))): frame_old = self . first [ idx ] frame_new = self . second [ idx ] if ( frame_old . filename == frame_new . filename and frame_old . code_interval == frame_new . code_interval ): # this is within the same function if frame_old . hilite_interval == frame_new . hilite_interval : # this is the same, no change self . equal . append ( frame_old ) else : # execution has at least moved by one code line # store the lower levels of the old frame # then the difference in the current frame to the new # then the lower levels of the new frame self . old_lower = [ FrameInfo ( filename = frame . filename , code_interval = frame . code_interval , hilite_interval = Interval ( frame . curlineno , frame . code_interval . end ), curlineno = frame . code_interval . end , code = frame . code , co_name = frame . co_name , parent = None , children = None , ) for frame in self . first [ idx + 1 :] ] middle_frame = copy ( self . first [ idx ]) middle_frame . hilite_interval = Interval ( self . first [ idx ] . focus_interval . end - 1 , self . second [ idx ] . focus_interval . end , ) self . middle = [ middle_frame ] self . new_lower = [ frame for frame in self . second [ idx + 1 :]] self . changed = self . old_lower + self . middle + self . new_lower return Tracker Used to profile the code in order to detect executed functions. It is intended to be used as a context manager. When entering the context, the profiler will be set and all subsequent function calls will be recorded. Afterwards the profiling is stopped. Source code in mkreports/_stack.py class Tracker : \"\"\" Used to profile the code in order to detect executed functions. It is intended to be used as a context manager. When entering the context, the profiler will be set and all subsequent function calls will be recorded. Afterwards the profiling is stopped. \"\"\" def __init__ ( self , dirs : Optional [ Union [ AnyPath , Sequence [ AnyPath ]]] = None , packages : Optional [ Union [ ModuleType , Sequence [ ModuleType ]]] = None , omit_levels : int = 0 , ): if isinstance ( dirs , Sequence ) and not isinstance ( dirs , str ): my_dirs = list ( dirs ) # don't need to do anything elif isinstance ( dirs , ( str , Path )): my_dirs = [ dirs ] else : my_dirs = [] if isinstance ( packages , Sequence ): packages = list ( packages ) elif isinstance ( packages , ModuleType ): packages = [ packages ] else : packages = [] # for the packages, we also convert them to directories for package in packages : # always use the first element of the list my_dirs . append ( Path ( package . __path__ [ 0 ])) # make the directories strings with a slash at the end self . dirs = [ str ( x ) + \"/\" for x in my_dirs ] self . omit_levels = omit_levels self . ctx_active = False self . tree = None self . cur_node = None def start ( self , omit_levels = 0 ): \"\"\"Activate the tracking.\"\"\" if self . ctx_active : raise TrackerActiveError ( \"Context manager is already active\" ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # save the tree for storing the information self . tree = FrameInfo . from_frame ( frame ) # include the current file in the directories to accept self . active_dirs = copy ( self . dirs ) self . active_dirs . append ( str ( Path ( self . tree . filename ) . parent ) + \"/\" ) self . active_dirs = list ( set ( self . active_dirs )) # here we actually want the next command self . cur_node = self . tree stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) stmt_after = parser . closest_after ( stmt_tree , frame . f_lineno ) if stmt_after is None : self . entry_lineno = frame . f_lineno else : self . entry_lineno = stmt_after . begin self . ctx_active = True # we get the directory of the callee if sys . gettrace () is None : sys . settrace ( self . trace ) # sys.settrace(None) else : logger . warning ( f \"Logger already set to { sys . gettrace () } \" ) return self def stop ( self , omit_levels = 0 ): if not self . ctx_active : raise TrackerNotActiveError ( \"Context manager is not active\" ) sys . settrace ( None ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # we set the display range # the display_range should go to the end of the current statement if self . tree is not None : # here we want to have the true ending line number stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) cur_stmt_lines = parser . smallest_overlap ( stmt_tree , frame . f_lineno ) if cur_stmt_lines is not None : self . tree . hilite_interval = Interval ( self . entry_lineno , cur_stmt_lines . end ) else : raise Exception ( \"Could not find current statement\" ) else : raise Exception ( \"__enter__ has not been called.\" ) self . ctx_active = False def __enter__ ( self ) -> \"Tracker\" : \"\"\"Enter context manager and set the profiler.\"\"\" return self . start ( omit_levels = 1 ) def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\"Remove the profiler when exiting the context manager.\"\"\" del exc_type , exc_val , traceback self . stop ( omit_levels = 1 ) @property def finished ( self ) -> bool : \"\"\"Tracker ctx manager has been finished.\"\"\" # The tracker context manager has been finished if # the node is not None, but also the ctx-manager is not active. return self . tree is not None and not self . ctx_active def _get_callee_frame ( self , omit_levels : int ) -> FrameType : frame = inspect . currentframe () # need to jump over the specified number of levels for _ in range ( omit_levels + 1 ): if frame is None : raise Exception ( \"frame is None\" ) frame = frame . f_back if frame is None : raise Exception ( \"frame is None\" ) return frame def frame_traceable ( self , frame : FrameType ) -> bool : frame_path = frame . f_code . co_filename for dir in self . active_dirs : if frame_path . startswith ( dir ): return True return False def notrace ( self , frame , event , arg ): del frame , event , arg return None def trace_reset_on_return ( self , frame , event , arg ): del frame , arg if event == \"return\" : sys . settrace ( self . trace ) return self . trace def trace ( self , frame , event , arg ): del arg # when tracing, only care if it is a 'call' event if event == \"call\" : # if it is inside the approved dirs, keep tracing; # otherwise we turn it off if self . frame_traceable ( frame ): # add the code object to the things that are traced # we put this as part of the tree self . cur_node = FrameInfo . from_frame ( frame , parent = self . cur_node ) return self . trace else : # we stop tracing sys . settrace ( self . notrace ) return self . trace_reset_on_return elif event == \"return\" : # set the current node to the parent in the tree if self . cur_node is not None : self . cur_node = self . cur_node . parent sys . settrace ( self . trace ) else : raise Exception ( \"cur_node should not be None\" ) pass else : return self . trace finished : bool property readonly Tracker ctx manager has been finished. __enter__ ( self ) special Enter context manager and set the profiler. Source code in mkreports/_stack.py def __enter__ ( self ) -> \"Tracker\" : \"\"\"Enter context manager and set the profiler.\"\"\" return self . start ( omit_levels = 1 ) __exit__ ( self , exc_type , exc_val , traceback ) special Remove the profiler when exiting the context manager. Source code in mkreports/_stack.py def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\"Remove the profiler when exiting the context manager.\"\"\" del exc_type , exc_val , traceback self . stop ( omit_levels = 1 ) start ( self , omit_levels = 0 ) Activate the tracking. Source code in mkreports/_stack.py def start ( self , omit_levels = 0 ): \"\"\"Activate the tracking.\"\"\" if self . ctx_active : raise TrackerActiveError ( \"Context manager is already active\" ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # save the tree for storing the information self . tree = FrameInfo . from_frame ( frame ) # include the current file in the directories to accept self . active_dirs = copy ( self . dirs ) self . active_dirs . append ( str ( Path ( self . tree . filename ) . parent ) + \"/\" ) self . active_dirs = list ( set ( self . active_dirs )) # here we actually want the next command self . cur_node = self . tree stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) stmt_after = parser . closest_after ( stmt_tree , frame . f_lineno ) if stmt_after is None : self . entry_lineno = frame . f_lineno else : self . entry_lineno = stmt_after . begin self . ctx_active = True # we get the directory of the callee if sys . gettrace () is None : sys . settrace ( self . trace ) # sys.settrace(None) else : logger . warning ( f \"Logger already set to { sys . gettrace () } \" ) return self get_stack ( omit_levels = 0 ) Get a simplified version of the stack. Source code in mkreports/_stack.py def get_stack ( omit_levels : int = 0 ) -> Stack : \"\"\" Get a simplified version of the stack. \"\"\" frame = inspect . currentframe () # need to jump over the specified number of levels for _ in range ( omit_levels + 1 ): if frame is None : raise Exception ( \"frame is None\" ) frame = frame . f_back stack = [] while frame is not None : stack . append ( FrameInfo . from_frame ( frame )) frame = frame . f_back return list ( reversed ( stack ))","title":"_stack"},{"location":"Reference/mkreports/_stack/#mkreports._stack.FrameInfo","text":"Source code in mkreports/_stack.py class FrameInfo ( NodeMixin ): filename : str code_interval : Interval hilite_interval : Optional [ Interval ] curlineno : int code : List [ str ] co_name : str def __init__ ( self , filename : str , code_interval : Interval , hilite_interval : Optional [ Interval ], curlineno : int , code : List [ str ], co_name : str , parent : Optional [ FrameInfo ], children : Optional [ List [ FrameInfo ]], ): self . filename = filename self . code_interval = code_interval self . hilite_interval = hilite_interval self . curlineno = curlineno self . code = code self . co_name = co_name self . parent = parent if children : self . children = children def __str__ ( self ): header = f \"File: { self . filename } \" position = f \" { self . hilite_interval } in { self . code_interval } \" return \" \\n \" . join ([ header , position , self . focus_code ]) @property def name ( self ): return f \" { self . filename } : { self . code_interval . begin } - { self . code_interval . end } \" @property def focus_interval ( self ): if self . hilite_interval is None : return self . code_interval else : return self . hilite_interval @property def focus_code ( self ): display_code = \"\" . join ( self . code [ ( self . focus_interval . begin - self . code_interval . begin ) : ( self . focus_interval . end - self . code_interval . begin ) ] ) return display_code def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> Code : if highlight : code = \"\" . join ( self . code ) first_line = self . code_interval . begin if self . code_interval == self . focus_interval : hl_lines = None else : hl_lines = ( self . focus_interval . begin , self . focus_interval . end - 1 ) else : # no highlight, so we take the focused range code = self . focus_code first_line = self . focus_interval . begin hl_lines = None return Code ( code = dedent ( code ), title = self . filename if full_filename else Path ( self . filename ) . name , first_line = first_line , hl_lines = hl_lines , language = \"python\" , ) def _md_collect ( self , highlight ) -> List [ Tuple [ str , Code ]]: res = [( self . co_name , self . md_code ( highlight = highlight ))] for child in self . children : res . extend ( child . _md_collect ( highlight )) return res def md_tree ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\" Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. \"\"\" code_list = self . _md_collect ( highlight ) # now only take the unique ones code_list = list ({ key : None for key in code_list } . keys ()) # now we want to de-duplicate the list if len ( code_list ) > 0 : if len ( code_list ) == 1 : return code_list [ 0 ][ 1 ] else : res = Tab ( code_list [ 0 ][ 1 ], title = \"<main>\" ) for i in range ( 1 , len ( code_list )): res = res + Tab ( code_list [ i ][ 1 ], title = code_list [ i ][ 0 ] if full_filename else Path ( code_list [ i ][ 0 ]) . name , ) return res else : return Raw ( \"\" ) @classmethod def from_frame ( cls , frame , parent = None , children = None ) -> \"FrameInfo\" : code = frame . f_code # if higher_frame is None and code.co_firstlineno != 1: # raise Exception( # f\"Did not expect first line {code.co_firstlineno} when upper frame is None.\" # ) # if higher_frame is None: # code_lines = read_file(Path(code.co_filename)) # else: try : if code . co_name == \"<module>\" : code_lines = read_file ( Path ( code . co_filename )) else : code_lines = inspect . getsourcelines ( code )[ 0 ] except Exception : code_lines = [ \"Count not get source \\n \" ] return FrameInfo ( filename = code . co_filename , co_name = code . co_name , code_interval = Interval ( code . co_firstlineno , code . co_firstlineno + len ( code_lines ), ), hilite_interval = None , curlineno = frame . f_lineno , code = code_lines , parent = parent , children = children , )","title":"FrameInfo"},{"location":"Reference/mkreports/_stack/#mkreports._stack.FrameInfo.md_tree","text":"Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. Source code in mkreports/_stack.py def md_tree ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\" Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. \"\"\" code_list = self . _md_collect ( highlight ) # now only take the unique ones code_list = list ({ key : None for key in code_list } . keys ()) # now we want to de-duplicate the list if len ( code_list ) > 0 : if len ( code_list ) == 1 : return code_list [ 0 ][ 1 ] else : res = Tab ( code_list [ 0 ][ 1 ], title = \"<main>\" ) for i in range ( 1 , len ( code_list )): res = res + Tab ( code_list [ i ][ 1 ], title = code_list [ i ][ 0 ] if full_filename else Path ( code_list [ i ][ 0 ]) . name , ) return res else : return Raw ( \"\" )","title":"md_tree()"},{"location":"Reference/mkreports/_stack/#mkreports._stack.StackDiff","text":"Source code in mkreports/_stack.py class StackDiff : def __init__ ( self , first_stack : Stack , second_stack : Stack ): \"\"\" Calculate the difference of two stacks. Shows the code executed between the old stack and the new. \"\"\" self . first = first_stack self . second = second_stack self . equal = [] for idx in range ( min ( len ( self . first ), len ( self . second ))): frame_old = self . first [ idx ] frame_new = self . second [ idx ] if ( frame_old . filename == frame_new . filename and frame_old . code_interval == frame_new . code_interval ): # this is within the same function if frame_old . hilite_interval == frame_new . hilite_interval : # this is the same, no change self . equal . append ( frame_old ) else : # execution has at least moved by one code line # store the lower levels of the old frame # then the difference in the current frame to the new # then the lower levels of the new frame self . old_lower = [ FrameInfo ( filename = frame . filename , code_interval = frame . code_interval , hilite_interval = Interval ( frame . curlineno , frame . code_interval . end ), curlineno = frame . code_interval . end , code = frame . code , co_name = frame . co_name , parent = None , children = None , ) for frame in self . first [ idx + 1 :] ] middle_frame = copy ( self . first [ idx ]) middle_frame . hilite_interval = Interval ( self . first [ idx ] . focus_interval . end - 1 , self . second [ idx ] . focus_interval . end , ) self . middle = [ middle_frame ] self . new_lower = [ frame for frame in self . second [ idx + 1 :]] self . changed = self . old_lower + self . middle + self . new_lower return","title":"StackDiff"},{"location":"Reference/mkreports/_stack/#mkreports._stack.StackDiff.__init__","text":"Calculate the difference of two stacks. Shows the code executed between the old stack and the new. Source code in mkreports/_stack.py def __init__ ( self , first_stack : Stack , second_stack : Stack ): \"\"\" Calculate the difference of two stacks. Shows the code executed between the old stack and the new. \"\"\" self . first = first_stack self . second = second_stack self . equal = [] for idx in range ( min ( len ( self . first ), len ( self . second ))): frame_old = self . first [ idx ] frame_new = self . second [ idx ] if ( frame_old . filename == frame_new . filename and frame_old . code_interval == frame_new . code_interval ): # this is within the same function if frame_old . hilite_interval == frame_new . hilite_interval : # this is the same, no change self . equal . append ( frame_old ) else : # execution has at least moved by one code line # store the lower levels of the old frame # then the difference in the current frame to the new # then the lower levels of the new frame self . old_lower = [ FrameInfo ( filename = frame . filename , code_interval = frame . code_interval , hilite_interval = Interval ( frame . curlineno , frame . code_interval . end ), curlineno = frame . code_interval . end , code = frame . code , co_name = frame . co_name , parent = None , children = None , ) for frame in self . first [ idx + 1 :] ] middle_frame = copy ( self . first [ idx ]) middle_frame . hilite_interval = Interval ( self . first [ idx ] . focus_interval . end - 1 , self . second [ idx ] . focus_interval . end , ) self . middle = [ middle_frame ] self . new_lower = [ frame for frame in self . second [ idx + 1 :]] self . changed = self . old_lower + self . middle + self . new_lower return","title":"__init__()"},{"location":"Reference/mkreports/_stack/#mkreports._stack.Tracker","text":"Used to profile the code in order to detect executed functions. It is intended to be used as a context manager. When entering the context, the profiler will be set and all subsequent function calls will be recorded. Afterwards the profiling is stopped. Source code in mkreports/_stack.py class Tracker : \"\"\" Used to profile the code in order to detect executed functions. It is intended to be used as a context manager. When entering the context, the profiler will be set and all subsequent function calls will be recorded. Afterwards the profiling is stopped. \"\"\" def __init__ ( self , dirs : Optional [ Union [ AnyPath , Sequence [ AnyPath ]]] = None , packages : Optional [ Union [ ModuleType , Sequence [ ModuleType ]]] = None , omit_levels : int = 0 , ): if isinstance ( dirs , Sequence ) and not isinstance ( dirs , str ): my_dirs = list ( dirs ) # don't need to do anything elif isinstance ( dirs , ( str , Path )): my_dirs = [ dirs ] else : my_dirs = [] if isinstance ( packages , Sequence ): packages = list ( packages ) elif isinstance ( packages , ModuleType ): packages = [ packages ] else : packages = [] # for the packages, we also convert them to directories for package in packages : # always use the first element of the list my_dirs . append ( Path ( package . __path__ [ 0 ])) # make the directories strings with a slash at the end self . dirs = [ str ( x ) + \"/\" for x in my_dirs ] self . omit_levels = omit_levels self . ctx_active = False self . tree = None self . cur_node = None def start ( self , omit_levels = 0 ): \"\"\"Activate the tracking.\"\"\" if self . ctx_active : raise TrackerActiveError ( \"Context manager is already active\" ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # save the tree for storing the information self . tree = FrameInfo . from_frame ( frame ) # include the current file in the directories to accept self . active_dirs = copy ( self . dirs ) self . active_dirs . append ( str ( Path ( self . tree . filename ) . parent ) + \"/\" ) self . active_dirs = list ( set ( self . active_dirs )) # here we actually want the next command self . cur_node = self . tree stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) stmt_after = parser . closest_after ( stmt_tree , frame . f_lineno ) if stmt_after is None : self . entry_lineno = frame . f_lineno else : self . entry_lineno = stmt_after . begin self . ctx_active = True # we get the directory of the callee if sys . gettrace () is None : sys . settrace ( self . trace ) # sys.settrace(None) else : logger . warning ( f \"Logger already set to { sys . gettrace () } \" ) return self def stop ( self , omit_levels = 0 ): if not self . ctx_active : raise TrackerNotActiveError ( \"Context manager is not active\" ) sys . settrace ( None ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # we set the display range # the display_range should go to the end of the current statement if self . tree is not None : # here we want to have the true ending line number stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) cur_stmt_lines = parser . smallest_overlap ( stmt_tree , frame . f_lineno ) if cur_stmt_lines is not None : self . tree . hilite_interval = Interval ( self . entry_lineno , cur_stmt_lines . end ) else : raise Exception ( \"Could not find current statement\" ) else : raise Exception ( \"__enter__ has not been called.\" ) self . ctx_active = False def __enter__ ( self ) -> \"Tracker\" : \"\"\"Enter context manager and set the profiler.\"\"\" return self . start ( omit_levels = 1 ) def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\"Remove the profiler when exiting the context manager.\"\"\" del exc_type , exc_val , traceback self . stop ( omit_levels = 1 ) @property def finished ( self ) -> bool : \"\"\"Tracker ctx manager has been finished.\"\"\" # The tracker context manager has been finished if # the node is not None, but also the ctx-manager is not active. return self . tree is not None and not self . ctx_active def _get_callee_frame ( self , omit_levels : int ) -> FrameType : frame = inspect . currentframe () # need to jump over the specified number of levels for _ in range ( omit_levels + 1 ): if frame is None : raise Exception ( \"frame is None\" ) frame = frame . f_back if frame is None : raise Exception ( \"frame is None\" ) return frame def frame_traceable ( self , frame : FrameType ) -> bool : frame_path = frame . f_code . co_filename for dir in self . active_dirs : if frame_path . startswith ( dir ): return True return False def notrace ( self , frame , event , arg ): del frame , event , arg return None def trace_reset_on_return ( self , frame , event , arg ): del frame , arg if event == \"return\" : sys . settrace ( self . trace ) return self . trace def trace ( self , frame , event , arg ): del arg # when tracing, only care if it is a 'call' event if event == \"call\" : # if it is inside the approved dirs, keep tracing; # otherwise we turn it off if self . frame_traceable ( frame ): # add the code object to the things that are traced # we put this as part of the tree self . cur_node = FrameInfo . from_frame ( frame , parent = self . cur_node ) return self . trace else : # we stop tracing sys . settrace ( self . notrace ) return self . trace_reset_on_return elif event == \"return\" : # set the current node to the parent in the tree if self . cur_node is not None : self . cur_node = self . cur_node . parent sys . settrace ( self . trace ) else : raise Exception ( \"cur_node should not be None\" ) pass else : return self . trace","title":"Tracker"},{"location":"Reference/mkreports/_stack/#mkreports._stack.Tracker.finished","text":"Tracker ctx manager has been finished.","title":"finished"},{"location":"Reference/mkreports/_stack/#mkreports._stack.Tracker.__enter__","text":"Enter context manager and set the profiler. Source code in mkreports/_stack.py def __enter__ ( self ) -> \"Tracker\" : \"\"\"Enter context manager and set the profiler.\"\"\" return self . start ( omit_levels = 1 )","title":"__enter__()"},{"location":"Reference/mkreports/_stack/#mkreports._stack.Tracker.__exit__","text":"Remove the profiler when exiting the context manager. Source code in mkreports/_stack.py def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\"Remove the profiler when exiting the context manager.\"\"\" del exc_type , exc_val , traceback self . stop ( omit_levels = 1 )","title":"__exit__()"},{"location":"Reference/mkreports/_stack/#mkreports._stack.Tracker.start","text":"Activate the tracking. Source code in mkreports/_stack.py def start ( self , omit_levels = 0 ): \"\"\"Activate the tracking.\"\"\" if self . ctx_active : raise TrackerActiveError ( \"Context manager is already active\" ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # save the tree for storing the information self . tree = FrameInfo . from_frame ( frame ) # include the current file in the directories to accept self . active_dirs = copy ( self . dirs ) self . active_dirs . append ( str ( Path ( self . tree . filename ) . parent ) + \"/\" ) self . active_dirs = list ( set ( self . active_dirs )) # here we actually want the next command self . cur_node = self . tree stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) stmt_after = parser . closest_after ( stmt_tree , frame . f_lineno ) if stmt_after is None : self . entry_lineno = frame . f_lineno else : self . entry_lineno = stmt_after . begin self . ctx_active = True # we get the directory of the callee if sys . gettrace () is None : sys . settrace ( self . trace ) # sys.settrace(None) else : logger . warning ( f \"Logger already set to { sys . gettrace () } \" ) return self","title":"start()"},{"location":"Reference/mkreports/_stack/#mkreports._stack.get_stack","text":"Get a simplified version of the stack. Source code in mkreports/_stack.py def get_stack ( omit_levels : int = 0 ) -> Stack : \"\"\" Get a simplified version of the stack. \"\"\" frame = inspect . currentframe () # need to jump over the specified number of levels for _ in range ( omit_levels + 1 ): if frame is None : raise Exception ( \"frame is None\" ) frame = frame . f_back stack = [] while frame is not None : stack . append ( FrameInfo . from_frame ( frame )) frame = frame . f_back return list ( reversed ( stack ))","title":"get_stack()"},{"location":"Reference/mkreports/code_context/","text":"Module providing a class and context manager for tracking code. The way of tracking code and displaying it is handled through a context manager, which is the return value obtained when adding an object to a page. The context manager gives different options on how to display the code and the results such as: A code block at the top followed by the output similar to standard jupyter notebooks. A Tab-format where output and code are on separate tabs A collapsed code block followed by the output or the output followed by a collapsed code block. CodeContext Source code in mkreports/code_context.py class CodeContext : tracker : BaseTracker def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): self . layout = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only def __enter__ ( self ) -> \"CodeContext\" : if self . do_tracking : self . tracker . start ( inspect . stack ()[ self . stack_level ]) return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : del exc_type , exc_val , traceback if self . do_tracking : self . tracker . stop ( inspect . stack ()[ self . stack_level ]) @property def active ( self ): return self . tracker . active def add ( self , md_obj : MdObj ) -> None : if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj ) def md_obj ( self , javascript_path : Path ) -> MdObj : \"\"\" Return the markdown object that represents output and code. \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : return content else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] if self . layout == \"top-c\" : return ( Admonition ( code_final , javascript_path = javascript_path , collapse = True , title = \"Code\" , kind = \"code\" , ) + content + HLine () ) elif self . layout == \"top-o\" : return code_final + content + HLine () elif self . layout == \"bottom-c\" : return ( content + Admonition ( code_final , javascript_path = javascript_path , collapse = True , title = \"Code\" , kind = \"code\" , ) + HLine () ) elif self . layout == \"bottom-o\" : return content + code_final + HLine () elif self . layout == \"tabbed\" : return ( Tab ( content , title = \"Content\" ) + Tab ( code_final , title = \"Code\" ) + HLine () ) else : raise Exception ( \"Unknown layout type.\" ) md_obj ( self , javascript_path ) Return the markdown object that represents output and code. Source code in mkreports/code_context.py def md_obj ( self , javascript_path : Path ) -> MdObj : \"\"\" Return the markdown object that represents output and code. \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : return content else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] if self . layout == \"top-c\" : return ( Admonition ( code_final , javascript_path = javascript_path , collapse = True , title = \"Code\" , kind = \"code\" , ) + content + HLine () ) elif self . layout == \"top-o\" : return code_final + content + HLine () elif self . layout == \"bottom-c\" : return ( content + Admonition ( code_final , javascript_path = javascript_path , collapse = True , title = \"Code\" , kind = \"code\" , ) + HLine () ) elif self . layout == \"bottom-o\" : return content + code_final + HLine () elif self . layout == \"tabbed\" : return ( Tab ( content , title = \"Content\" ) + Tab ( code_final , title = \"Code\" ) + HLine () ) else : raise Exception ( \"Unknown layout type.\" )","title":"code_context"},{"location":"Reference/mkreports/code_context/#mkreports.code_context.CodeContext","text":"Source code in mkreports/code_context.py class CodeContext : tracker : BaseTracker def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): self . layout = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only def __enter__ ( self ) -> \"CodeContext\" : if self . do_tracking : self . tracker . start ( inspect . stack ()[ self . stack_level ]) return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : del exc_type , exc_val , traceback if self . do_tracking : self . tracker . stop ( inspect . stack ()[ self . stack_level ]) @property def active ( self ): return self . tracker . active def add ( self , md_obj : MdObj ) -> None : if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj ) def md_obj ( self , javascript_path : Path ) -> MdObj : \"\"\" Return the markdown object that represents output and code. \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : return content else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] if self . layout == \"top-c\" : return ( Admonition ( code_final , javascript_path = javascript_path , collapse = True , title = \"Code\" , kind = \"code\" , ) + content + HLine () ) elif self . layout == \"top-o\" : return code_final + content + HLine () elif self . layout == \"bottom-c\" : return ( content + Admonition ( code_final , javascript_path = javascript_path , collapse = True , title = \"Code\" , kind = \"code\" , ) + HLine () ) elif self . layout == \"bottom-o\" : return content + code_final + HLine () elif self . layout == \"tabbed\" : return ( Tab ( content , title = \"Content\" ) + Tab ( code_final , title = \"Code\" ) + HLine () ) else : raise Exception ( \"Unknown layout type.\" )","title":"CodeContext"},{"location":"Reference/mkreports/code_context/#mkreports.code_context.CodeContext.md_obj","text":"Return the markdown object that represents output and code. Source code in mkreports/code_context.py def md_obj ( self , javascript_path : Path ) -> MdObj : \"\"\" Return the markdown object that represents output and code. \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : return content else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] if self . layout == \"top-c\" : return ( Admonition ( code_final , javascript_path = javascript_path , collapse = True , title = \"Code\" , kind = \"code\" , ) + content + HLine () ) elif self . layout == \"top-o\" : return code_final + content + HLine () elif self . layout == \"bottom-c\" : return ( content + Admonition ( code_final , javascript_path = javascript_path , collapse = True , title = \"Code\" , kind = \"code\" , ) + HLine () ) elif self . layout == \"bottom-o\" : return content + code_final + HLine () elif self . layout == \"tabbed\" : return ( Tab ( content , title = \"Content\" ) + Tab ( code_final , title = \"Code\" ) + HLine () ) else : raise Exception ( \"Unknown layout type.\" )","title":"md_obj()"},{"location":"Reference/mkreports/docs/","text":"add_pkg_docs ( pkg_path , parent_name , report ) Add docstrings of the object to the report Source code in mkreports/docs.py def add_pkg_docs ( pkg_path : Path , parent_name : Union [ NavEntry , Path , str ], report : Report , ): \"\"\" Add docstrings of the object to the report \"\"\" # we need the parent name as a nav_entry if isinstance ( parent_name , str ): parent_name = Path ( parent_name ) if isinstance ( parent_name , Path ): parent_name = path_to_nav_entry ( parent_name ) # now iterate through all python entries for path in sorted ( pkg_path . glob ( \"**/*.py\" )): module_path = path . relative_to ( pkg_path . parent ) . with_suffix ( \"\" ) if module_path . name == \"__init__\" : continue else : # now create the new nav_entry for this page module_nav_entry = ( parent_name [ 0 ] + list ( module_path . parts ), ( parent_name [ 1 ] / module_path ) . with_suffix ( \".md\" ), ) # now create a new page and add the doc-entry page = report . page ( module_nav_entry , truncate = True ) page . add ( page . md . Docstring ( \".\" . join ( module_path . parts )))","title":"docs"},{"location":"Reference/mkreports/docs/#mkreports.docs.add_pkg_docs","text":"Add docstrings of the object to the report Source code in mkreports/docs.py def add_pkg_docs ( pkg_path : Path , parent_name : Union [ NavEntry , Path , str ], report : Report , ): \"\"\" Add docstrings of the object to the report \"\"\" # we need the parent name as a nav_entry if isinstance ( parent_name , str ): parent_name = Path ( parent_name ) if isinstance ( parent_name , Path ): parent_name = path_to_nav_entry ( parent_name ) # now iterate through all python entries for path in sorted ( pkg_path . glob ( \"**/*.py\" )): module_path = path . relative_to ( pkg_path . parent ) . with_suffix ( \"\" ) if module_path . name == \"__init__\" : continue else : # now create the new nav_entry for this page module_nav_entry = ( parent_name [ 0 ] + list ( module_path . parts ), ( parent_name [ 1 ] / module_path ) . with_suffix ( \".md\" ), ) # now create a new page and add the doc-entry page = report . page ( module_nav_entry , truncate = True ) page . add ( page . md . Docstring ( \".\" . join ( module_path . parts )))","title":"add_pkg_docs()"},{"location":"Reference/mkreports/exceptions/","text":"All Exception classes that we are using in the package.","title":"exceptions"},{"location":"Reference/mkreports/ipython/","text":"ConsoleWriter ( Magics ) Source code in mkreports/ipython.py @magics_class class ConsoleWriter ( Magics ): handlers : List [ Handler ] console : Page def __init__ ( self , ip ): super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] self . _set_default_handlers () # identify an mkreport if \"MKREPORTS_DIR\" in os . environ : self . report = Report . create ( os . environ [ \"MKREPORTS_DIR\" ], report_name = \"Mkreports console\" , exist_ok = True , ) self . open_console () else : raise Exception ( \"No 'MKREPORTS_DIR' in environment\" ) def _set_default_handlers ( self ): self . handlers = [] # handler for tables try : import pandas as pd self . handlers . append ( Handler ( name = \"datatable\" , class_type = pd . DataFrame , func = lambda x : self . console . md . DataTable ( x ), add_code = True , ) ) except Exception : pass # handler for matplotlib try : from matplotlib.figure import Figure as MplFigure self . handlers . append ( Handler ( name = \"matplotlib\" , class_type = MplFigure , func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass try : from plotnine.ggplot import ggplot self . handlers . append ( Handler ( name = \"plotnine\" , class_type = ggplot , func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass try : from seaborn import FacetGrid as SnsFacetGrid from seaborn import JointGrid as SnsJointGrid from seaborn import PairGrid as SnsPairGrid self . handlers . append ( Handler ( name = \"seaborn\" , class_type = ( SnsFacetGrid , SnsJointGrid , SnsPairGrid ), func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass self . handlers . append ( Handler ( name = \"mdobj\" , class_type = md . MdObj , func = lambda x : x , add_code = False ) ) def get_handler ( self , obj : Any ) -> Optional [ Handler ]: for handler in self . handlers : if isinstance ( obj , handler . class_type ): return handler else : return None def open_console ( self ) -> None : self . console = self . report . page ( Path ( \"console/active.md\" ), add_bottom = False ) # make sure the table of contents does not get shown self . console . add ( md . Raw ( page_settings = { \"hide\" : [ \"toc\" ]}, ) ) @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . open_console () def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . get_handler ( result . result ) if handler is not None : md_obj = handler . func ( result . result ) if handler . add_code : # we now want to attach this together with the stored code content = md . Tab ( md_obj , title = \"Content\" ) code = md . Tab ( md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ), title = \"Code\" , ) md_obj = content + code # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + md_obj + md . Raw ( md . SpacedText ( \"---\" , ( 2 , 2 ))) ) self . console . add ( post , add_code = False ) self . stored_code = [] archive_console ( self , line ) Function to archive the console. This is also a line magic, however the line itself will be ignored. Source code in mkreports/ipython.py @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . open_console () post_run_cell ( self , result ) Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. Source code in mkreports/ipython.py def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . get_handler ( result . result ) if handler is not None : md_obj = handler . func ( result . result ) if handler . add_code : # we now want to attach this together with the stored code content = md . Tab ( md_obj , title = \"Content\" ) code = md . Tab ( md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ), title = \"Code\" , ) md_obj = content + code # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + md_obj + md . Raw ( md . SpacedText ( \"---\" , ( 2 , 2 ))) ) self . console . add ( post , add_code = False ) self . stored_code = [] Handler dataclass Handler(name: str, class_type: Union[type, Tuple[type, ...]], func: Callable, add_code: bool) Source code in mkreports/ipython.py @dataclass class Handler : name : str class_type : Union [ type , Tuple [ type , ... ]] func : Callable add_code : bool load_ipython_extension ( ip ) Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. Source code in mkreports/ipython.py def load_ipython_extension ( ip ): \"\"\" Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. \"\"\" cw = ConsoleWriter ( ip ) cw . shell . push ({ \"md\" : cw . console . md , \"cons\" : cw . console }) ip . events . register ( \"post_run_cell\" , cw . post_run_cell ) ip . register_magics ( cw )","title":"ipython"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.ConsoleWriter","text":"Source code in mkreports/ipython.py @magics_class class ConsoleWriter ( Magics ): handlers : List [ Handler ] console : Page def __init__ ( self , ip ): super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] self . _set_default_handlers () # identify an mkreport if \"MKREPORTS_DIR\" in os . environ : self . report = Report . create ( os . environ [ \"MKREPORTS_DIR\" ], report_name = \"Mkreports console\" , exist_ok = True , ) self . open_console () else : raise Exception ( \"No 'MKREPORTS_DIR' in environment\" ) def _set_default_handlers ( self ): self . handlers = [] # handler for tables try : import pandas as pd self . handlers . append ( Handler ( name = \"datatable\" , class_type = pd . DataFrame , func = lambda x : self . console . md . DataTable ( x ), add_code = True , ) ) except Exception : pass # handler for matplotlib try : from matplotlib.figure import Figure as MplFigure self . handlers . append ( Handler ( name = \"matplotlib\" , class_type = MplFigure , func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass try : from plotnine.ggplot import ggplot self . handlers . append ( Handler ( name = \"plotnine\" , class_type = ggplot , func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass try : from seaborn import FacetGrid as SnsFacetGrid from seaborn import JointGrid as SnsJointGrid from seaborn import PairGrid as SnsPairGrid self . handlers . append ( Handler ( name = \"seaborn\" , class_type = ( SnsFacetGrid , SnsJointGrid , SnsPairGrid ), func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass self . handlers . append ( Handler ( name = \"mdobj\" , class_type = md . MdObj , func = lambda x : x , add_code = False ) ) def get_handler ( self , obj : Any ) -> Optional [ Handler ]: for handler in self . handlers : if isinstance ( obj , handler . class_type ): return handler else : return None def open_console ( self ) -> None : self . console = self . report . page ( Path ( \"console/active.md\" ), add_bottom = False ) # make sure the table of contents does not get shown self . console . add ( md . Raw ( page_settings = { \"hide\" : [ \"toc\" ]}, ) ) @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . open_console () def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . get_handler ( result . result ) if handler is not None : md_obj = handler . func ( result . result ) if handler . add_code : # we now want to attach this together with the stored code content = md . Tab ( md_obj , title = \"Content\" ) code = md . Tab ( md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ), title = \"Code\" , ) md_obj = content + code # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + md_obj + md . Raw ( md . SpacedText ( \"---\" , ( 2 , 2 ))) ) self . console . add ( post , add_code = False ) self . stored_code = []","title":"ConsoleWriter"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.ConsoleWriter.archive_console","text":"Function to archive the console. This is also a line magic, however the line itself will be ignored. Source code in mkreports/ipython.py @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . open_console ()","title":"archive_console()"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.ConsoleWriter.post_run_cell","text":"Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. Source code in mkreports/ipython.py def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . get_handler ( result . result ) if handler is not None : md_obj = handler . func ( result . result ) if handler . add_code : # we now want to attach this together with the stored code content = md . Tab ( md_obj , title = \"Content\" ) code = md . Tab ( md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ), title = \"Code\" , ) md_obj = content + code # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + md_obj + md . Raw ( md . SpacedText ( \"---\" , ( 2 , 2 ))) ) self . console . add ( post , add_code = False ) self . stored_code = []","title":"post_run_cell()"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.Handler","text":"Handler(name: str, class_type: Union[type, Tuple[type, ...]], func: Callable, add_code: bool) Source code in mkreports/ipython.py @dataclass class Handler : name : str class_type : Union [ type , Tuple [ type , ... ]] func : Callable add_code : bool","title":"Handler"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.load_ipython_extension","text":"Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. Source code in mkreports/ipython.py def load_ipython_extension ( ip ): \"\"\" Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. \"\"\" cw = ConsoleWriter ( ip ) cw . shell . push ({ \"md\" : cw . console . md , \"cons\" : cw . console }) ip . events . register ( \"post_run_cell\" , cw . post_run_cell ) ip . register_magics ( cw )","title":"load_ipython_extension()"},{"location":"Reference/mkreports/md_proxy/","text":"","title":"md_proxy"},{"location":"Reference/mkreports/parser/","text":"A simple class to provide access to full extent of statements with starting and ending lines. closest_after ( tree , lineno ) Return the closest item strictly before lineno. Source code in mkreports/parser.py def closest_after ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line # rest by difference to current line after_list = [ x for x in tree_list if ( x . begin > lineno )] after_list . sort ( key = lambda x : x . begin - lineno ) if len ( after_list ) > 0 : return after_list [ 0 ] else : return None closest_before ( tree , lineno ) Return the closest item strictly before lineno. Source code in mkreports/parser.py def closest_before ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line before_list = [ x for x in tree_list if ( x . begin < lineno )] before_list . sort ( key = lambda x : lineno - x . begin ) if len ( before_list ) > 0 : return before_list [ 0 ] else : return None get_neighbors ( tree , lineno ) For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Source code in mkreports/parser.py def get_neighbors ( tree : IntervalTree , lineno : int ) -> Tuple [ Optional [ Interval ], Optional [ Interval ], Optional [ Interval ]]: \"\"\" For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. \"\"\" return ( closest_before ( tree , lineno ), smallest_overlap ( tree , lineno ), closest_after ( tree , lineno ), ) get_stmt_ranges ( pyfile ) Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Source code in mkreports/parser.py def get_stmt_ranges ( pyfile : Path ) -> IntervalTree : \"\"\" Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. \"\"\" # first we parse the python file into an AST with pyfile . open ( \"r\" ) as f : file_ast = ast . parse ( f . read ()) inttree = IntervalTree () # now we want to walk along the tree and get the line extent of # all nodes that are statements; as data payload we attach # the parsed nodes for node in ast . walk ( file_ast ): if isinstance ( node , ast . stmt ): if node . lineno is not None and node . end_lineno is not None : inttree . add ( Interval ( begin = node . lineno , end = node . end_lineno + 1 , data = node ) ) return inttree smallest_overlap ( tree , lineno ) Find the closest match that overlaps and is shortests. Source code in mkreports/parser.py def smallest_overlap ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Find the closest match that overlaps and is shortests. \"\"\" overlap_set = tree . at ( lineno ) if len ( overlap_set ) > 0 : # we take the shortest overlap_list = list ( overlap_set ) overlap_list . sort ( key = lambda x : x . end - x . begin ) return overlap_list [ 0 ] else : return None","title":"parser"},{"location":"Reference/mkreports/parser/#mkreports.parser.closest_after","text":"Return the closest item strictly before lineno. Source code in mkreports/parser.py def closest_after ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line # rest by difference to current line after_list = [ x for x in tree_list if ( x . begin > lineno )] after_list . sort ( key = lambda x : x . begin - lineno ) if len ( after_list ) > 0 : return after_list [ 0 ] else : return None","title":"closest_after()"},{"location":"Reference/mkreports/parser/#mkreports.parser.closest_before","text":"Return the closest item strictly before lineno. Source code in mkreports/parser.py def closest_before ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line before_list = [ x for x in tree_list if ( x . begin < lineno )] before_list . sort ( key = lambda x : lineno - x . begin ) if len ( before_list ) > 0 : return before_list [ 0 ] else : return None","title":"closest_before()"},{"location":"Reference/mkreports/parser/#mkreports.parser.get_neighbors","text":"For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Source code in mkreports/parser.py def get_neighbors ( tree : IntervalTree , lineno : int ) -> Tuple [ Optional [ Interval ], Optional [ Interval ], Optional [ Interval ]]: \"\"\" For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. \"\"\" return ( closest_before ( tree , lineno ), smallest_overlap ( tree , lineno ), closest_after ( tree , lineno ), )","title":"get_neighbors()"},{"location":"Reference/mkreports/parser/#mkreports.parser.get_stmt_ranges","text":"Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Source code in mkreports/parser.py def get_stmt_ranges ( pyfile : Path ) -> IntervalTree : \"\"\" Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. \"\"\" # first we parse the python file into an AST with pyfile . open ( \"r\" ) as f : file_ast = ast . parse ( f . read ()) inttree = IntervalTree () # now we want to walk along the tree and get the line extent of # all nodes that are statements; as data payload we attach # the parsed nodes for node in ast . walk ( file_ast ): if isinstance ( node , ast . stmt ): if node . lineno is not None and node . end_lineno is not None : inttree . add ( Interval ( begin = node . lineno , end = node . end_lineno + 1 , data = node ) ) return inttree","title":"get_stmt_ranges()"},{"location":"Reference/mkreports/parser/#mkreports.parser.smallest_overlap","text":"Find the closest match that overlaps and is shortests. Source code in mkreports/parser.py def smallest_overlap ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Find the closest match that overlaps and is shortests. \"\"\" overlap_set = tree . at ( lineno ) if len ( overlap_set ) > 0 : # we take the shortest overlap_list = list ( overlap_set ) overlap_list . sort ( key = lambda x : x . end - x . begin ) return overlap_list [ 0 ] else : return None","title":"smallest_overlap()"},{"location":"Reference/mkreports/report/","text":"Base class for the whole report. This corresponds to a mkdocs project. The class is mainly responsible for creating a mkdocs project if it doesn't exist already and ensuring that the neccessary settings are all included. Page Source code in mkreports/report.py class Page : def __init__ ( self , path : Path , report : Report , code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , ) -> None : self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( store_path = self . store_path , report_path = self . report . path , javascript_path = self . report . javascript_path , ) self . code_context : Optional [ CodeContext ] = None def __enter__ ( self ) -> \"Page\" : \"\"\" Return a copy of the page with a new CodeContext set \"\"\" if self . code_context is not None and self . code_context . active : raise ContextActiveError ( \"The context manager is already active\" ) if self . code_context is None : self . code_context = CodeContext ( layout = self . code_layout , name_only = self . code_name_only , add_bottom = self . add_bottom , ) self . code_context . __enter__ () return self def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : if self . code_context is not None and self . code_context . active : raise ContextActiveError ( \"The context manager is already active\" ) self . code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , ) return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\" Exit the code context and add output. \"\"\" if self . code_context is None : raise Exception ( \"__exit__ called before __enter__\" ) self . code_context . __exit__ ( exc_type , exc_val , traceback ) self . _add_to_page ( self . code_context . md_obj ( javascript_path = self . report . javascript_path ) ) self . code_context = None def __getattr__ ( self , name ): md_class = self . md . __getattr__ ( name ) def md_and_add ( * args , ** kwargs ): kwargs_add = {} kwargs_md = kwargs # now apply to md md_obj = md_class ( * args , ** kwargs_md ) return self . add ( md_obj , ** kwargs_add ) return md_and_add def __copy__ ( self ): cls = self . __class__ result = cls . __new__ ( cls ) result . __dict__ . update ( self . __dict__ ) return result @property def notrack ( self ) -> ContextManager [ \"Page\" ]: return nullcontext ( self ) @property def path ( self ) -> Path : return self . _path @property def store_path ( self ) -> Path : return self . path . parent / ( self . _path . stem + \"_store\" ) def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\"Print code as markdown that has been tracked.\"\"\" if self . tracker . ctx_active : raise TrackerIncompleteError ( \"The tracker has not finished.\" ) if self . tracker . tree is None : raise TrackerEmptyError ( \"The tracker has not been started.\" ) return self . tracker . tree . md_tree ( highlight = highlight , full_filename = full_filename ) def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # if a context-manager is active, pass along the object into there if self . code_context is not None : self . code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self def _add_to_page ( self , item : MdObj , ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" # call the markdown and the backmatter md_out = item . to_markdown ( page_path = self . path , idstore = self . _idstore ) md_text = md_out . body + md_out . back req = md_out . settings if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in mkdocs\" ) mkdocs_settings = load_yaml ( self . report . mkdocs_file ) mkdocs_settings = merge_settings ( mkdocs_settings , req . mkdocs ) save_yaml ( mkdocs_settings , self . report . mkdocs_file ) metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , req . page ) if self . add_bottom : content = content + md_text . format_text ( content , \"\" ) else : content = md_text . format_text ( \"\" , content ) + content write_page ( self . path , metadata , content ) @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule that specifies 'store_path' where possible. \"\"\" return self . _md md : MdProxy property readonly A proxy for the 'md' submodule that specifies 'store_path' where possible. __enter__ ( self ) special Return a copy of the page with a new CodeContext set Source code in mkreports/report.py def __enter__ ( self ) -> \"Page\" : \"\"\" Return a copy of the page with a new CodeContext set \"\"\" if self . code_context is not None and self . code_context . active : raise ContextActiveError ( \"The context manager is already active\" ) if self . code_context is None : self . code_context = CodeContext ( layout = self . code_layout , name_only = self . code_name_only , add_bottom = self . add_bottom , ) self . code_context . __enter__ () return self __exit__ ( self , exc_type , exc_val , traceback ) special Exit the code context and add output. Source code in mkreports/report.py def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\" Exit the code context and add output. \"\"\" if self . code_context is None : raise Exception ( \"__exit__ called before __enter__\" ) self . code_context . __exit__ ( exc_type , exc_val , traceback ) self . _add_to_page ( self . code_context . md_obj ( javascript_path = self . report . javascript_path ) ) self . code_context = None clear ( self ) Clear the page markdown file and the generated assets directory. Source code in mkreports/report.py def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () md_code ( self , highlight = True , full_filename = False ) Print code as markdown that has been tracked. Source code in mkreports/report.py def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\"Print code as markdown that has been tracked.\"\"\" if self . tracker . ctx_active : raise TrackerIncompleteError ( \"The tracker has not finished.\" ) if self . tracker . tree is None : raise TrackerEmptyError ( \"The tracker has not been started.\" ) return self . tracker . tree . md_tree ( highlight = highlight , full_filename = full_filename )","title":"report"},{"location":"Reference/mkreports/report/#mkreports.report.Page","text":"Source code in mkreports/report.py class Page : def __init__ ( self , path : Path , report : Report , code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , ) -> None : self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( store_path = self . store_path , report_path = self . report . path , javascript_path = self . report . javascript_path , ) self . code_context : Optional [ CodeContext ] = None def __enter__ ( self ) -> \"Page\" : \"\"\" Return a copy of the page with a new CodeContext set \"\"\" if self . code_context is not None and self . code_context . active : raise ContextActiveError ( \"The context manager is already active\" ) if self . code_context is None : self . code_context = CodeContext ( layout = self . code_layout , name_only = self . code_name_only , add_bottom = self . add_bottom , ) self . code_context . __enter__ () return self def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : if self . code_context is not None and self . code_context . active : raise ContextActiveError ( \"The context manager is already active\" ) self . code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , ) return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\" Exit the code context and add output. \"\"\" if self . code_context is None : raise Exception ( \"__exit__ called before __enter__\" ) self . code_context . __exit__ ( exc_type , exc_val , traceback ) self . _add_to_page ( self . code_context . md_obj ( javascript_path = self . report . javascript_path ) ) self . code_context = None def __getattr__ ( self , name ): md_class = self . md . __getattr__ ( name ) def md_and_add ( * args , ** kwargs ): kwargs_add = {} kwargs_md = kwargs # now apply to md md_obj = md_class ( * args , ** kwargs_md ) return self . add ( md_obj , ** kwargs_add ) return md_and_add def __copy__ ( self ): cls = self . __class__ result = cls . __new__ ( cls ) result . __dict__ . update ( self . __dict__ ) return result @property def notrack ( self ) -> ContextManager [ \"Page\" ]: return nullcontext ( self ) @property def path ( self ) -> Path : return self . _path @property def store_path ( self ) -> Path : return self . path . parent / ( self . _path . stem + \"_store\" ) def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\"Print code as markdown that has been tracked.\"\"\" if self . tracker . ctx_active : raise TrackerIncompleteError ( \"The tracker has not finished.\" ) if self . tracker . tree is None : raise TrackerEmptyError ( \"The tracker has not been started.\" ) return self . tracker . tree . md_tree ( highlight = highlight , full_filename = full_filename ) def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # if a context-manager is active, pass along the object into there if self . code_context is not None : self . code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self def _add_to_page ( self , item : MdObj , ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" # call the markdown and the backmatter md_out = item . to_markdown ( page_path = self . path , idstore = self . _idstore ) md_text = md_out . body + md_out . back req = md_out . settings if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in mkdocs\" ) mkdocs_settings = load_yaml ( self . report . mkdocs_file ) mkdocs_settings = merge_settings ( mkdocs_settings , req . mkdocs ) save_yaml ( mkdocs_settings , self . report . mkdocs_file ) metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , req . page ) if self . add_bottom : content = content + md_text . format_text ( content , \"\" ) else : content = md_text . format_text ( \"\" , content ) + content write_page ( self . path , metadata , content ) @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule that specifies 'store_path' where possible. \"\"\" return self . _md","title":"Page"},{"location":"Reference/mkreports/report/#mkreports.report.Page.md","text":"A proxy for the 'md' submodule that specifies 'store_path' where possible.","title":"md"},{"location":"Reference/mkreports/report/#mkreports.report.Page.__enter__","text":"Return a copy of the page with a new CodeContext set Source code in mkreports/report.py def __enter__ ( self ) -> \"Page\" : \"\"\" Return a copy of the page with a new CodeContext set \"\"\" if self . code_context is not None and self . code_context . active : raise ContextActiveError ( \"The context manager is already active\" ) if self . code_context is None : self . code_context = CodeContext ( layout = self . code_layout , name_only = self . code_name_only , add_bottom = self . add_bottom , ) self . code_context . __enter__ () return self","title":"__enter__()"},{"location":"Reference/mkreports/report/#mkreports.report.Page.__exit__","text":"Exit the code context and add output. Source code in mkreports/report.py def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\" Exit the code context and add output. \"\"\" if self . code_context is None : raise Exception ( \"__exit__ called before __enter__\" ) self . code_context . __exit__ ( exc_type , exc_val , traceback ) self . _add_to_page ( self . code_context . md_obj ( javascript_path = self . report . javascript_path ) ) self . code_context = None","title":"__exit__()"},{"location":"Reference/mkreports/report/#mkreports.report.Page.clear","text":"Clear the page markdown file and the generated assets directory. Source code in mkreports/report.py def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink ()","title":"clear()"},{"location":"Reference/mkreports/report/#mkreports.report.Page.md_code","text":"Print code as markdown that has been tracked. Source code in mkreports/report.py def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\"Print code as markdown that has been tracked.\"\"\" if self . tracker . ctx_active : raise TrackerIncompleteError ( \"The tracker has not finished.\" ) if self . tracker . tree is None : raise TrackerEmptyError ( \"The tracker has not been started.\" ) return self . tracker . tree . md_tree ( highlight = highlight , full_filename = full_filename )","title":"md_code()"},{"location":"Reference/mkreports/settings/","text":"mkdocs_to_nav ( mkdocs_nav ) Convert an mkdovs nav to a list of NavEntry. Source code in mkreports/settings.py def mkdocs_to_nav ( mkdocs_nav : MkdocsNav ) -> Nav : \"\"\" Convert an mkdovs nav to a list of NavEntry. \"\"\" res = [] for entry in mkdocs_nav : if isinstance ( entry , str ): res . append (([], Path ( entry ))) elif isinstance ( entry , Mapping ): key , val = check_length_one ( entry ) if isinstance ( val , str ): res . append (([ key ], Path ( val ))) elif isinstance ( val , List ): res = res + [([ key ] + h , p ) for ( h , p ) in mkdocs_to_nav ( val )] else : raise Exception ( \"Not expected type\" ) else : raise Exception ( \"Not expected type\" ) return res nav_to_mkdocs ( nav ) Convert a list of nav-entries into mkdocs format. Source code in mkreports/settings.py def nav_to_mkdocs ( nav : Nav ) -> MkdocsNav : \"\"\" Convert a list of nav-entries into mkdocs format. \"\"\" split_nokey , split_keys = split_nav ( nav ) res : MkdocsNav = [ str ( p ) for p in split_nokey ] for key , val in split_keys . items (): mkdocs_for_key = nav_to_mkdocs ( val ) # if it is a list of length 1 with a string, treat it special if len ( mkdocs_for_key ) == 1 and isinstance ( mkdocs_for_key [ 0 ], str ): res . append ({ key : mkdocs_for_key [ 0 ]}) else : res . append ({ key : mkdocs_for_key }) return res","title":"settings"},{"location":"Reference/mkreports/settings/#mkreports.settings.mkdocs_to_nav","text":"Convert an mkdovs nav to a list of NavEntry. Source code in mkreports/settings.py def mkdocs_to_nav ( mkdocs_nav : MkdocsNav ) -> Nav : \"\"\" Convert an mkdovs nav to a list of NavEntry. \"\"\" res = [] for entry in mkdocs_nav : if isinstance ( entry , str ): res . append (([], Path ( entry ))) elif isinstance ( entry , Mapping ): key , val = check_length_one ( entry ) if isinstance ( val , str ): res . append (([ key ], Path ( val ))) elif isinstance ( val , List ): res = res + [([ key ] + h , p ) for ( h , p ) in mkdocs_to_nav ( val )] else : raise Exception ( \"Not expected type\" ) else : raise Exception ( \"Not expected type\" ) return res","title":"mkdocs_to_nav()"},{"location":"Reference/mkreports/settings/#mkreports.settings.nav_to_mkdocs","text":"Convert a list of nav-entries into mkdocs format. Source code in mkreports/settings.py def nav_to_mkdocs ( nav : Nav ) -> MkdocsNav : \"\"\" Convert a list of nav-entries into mkdocs format. \"\"\" split_nokey , split_keys = split_nav ( nav ) res : MkdocsNav = [ str ( p ) for p in split_nokey ] for key , val in split_keys . items (): mkdocs_for_key = nav_to_mkdocs ( val ) # if it is a list of length 1 with a string, treat it special if len ( mkdocs_for_key ) == 1 and isinstance ( mkdocs_for_key [ 0 ], str ): res . append ({ key : mkdocs_for_key [ 0 ]}) else : res . append ({ key : mkdocs_for_key }) return res","title":"nav_to_mkdocs()"},{"location":"Reference/mkreports/tracker/","text":"CodeBlock dataclass CodeBlock(filename: str, co_name: str, line_start: int, line_end: int) Source code in mkreports/tracker.py @dataclass class CodeBlock : filename : str co_name : str line_start : int line_end : int def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , ) SimpleTracker ( BaseTracker ) Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. Source code in mkreports/tracker.py class SimpleTracker ( BaseTracker ): \"\"\" Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. \"\"\" def __init__ ( self ): self . _active = False self . line_start = None self . line_end = None self . co_name = None def start ( self , frame_info : inspect . FrameInfo ) -> None : if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True def stop ( self , frame_info : inspect . FrameInfo ) -> None : if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False def code ( self ) -> List [ CodeBlock ]: if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ] @property def active ( self ) -> bool : return self . _active read_file ( path , from_line = None , to_line = None ) Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Source code in mkreports/tracker.py def read_file ( path : Path , from_line : Optional [ int ] = None , to_line : Optional [ int ] = None ) -> str : \"\"\" Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. \"\"\" with path . open ( \"r\" ) as f : lines = f . readlines () # the from_line to_line are line-numbers, not indices. to_line is included return \"\" . join ( lines [ slice ( from_line - 1 if from_line is not None else None , to_line , 1 )] )","title":"tracker"},{"location":"Reference/mkreports/tracker/#mkreports.tracker.CodeBlock","text":"CodeBlock(filename: str, co_name: str, line_start: int, line_end: int) Source code in mkreports/tracker.py @dataclass class CodeBlock : filename : str co_name : str line_start : int line_end : int def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , )","title":"CodeBlock"},{"location":"Reference/mkreports/tracker/#mkreports.tracker.SimpleTracker","text":"Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. Source code in mkreports/tracker.py class SimpleTracker ( BaseTracker ): \"\"\" Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. \"\"\" def __init__ ( self ): self . _active = False self . line_start = None self . line_end = None self . co_name = None def start ( self , frame_info : inspect . FrameInfo ) -> None : if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True def stop ( self , frame_info : inspect . FrameInfo ) -> None : if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False def code ( self ) -> List [ CodeBlock ]: if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ] @property def active ( self ) -> bool : return self . _active","title":"SimpleTracker"},{"location":"Reference/mkreports/tracker/#mkreports.tracker.read_file","text":"Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Source code in mkreports/tracker.py def read_file ( path : Path , from_line : Optional [ int ] = None , to_line : Optional [ int ] = None ) -> str : \"\"\" Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. \"\"\" with path . open ( \"r\" ) as f : lines = f . readlines () # the from_line to_line are line-numbers, not indices. to_line is included return \"\" . join ( lines [ slice ( from_line - 1 if from_line is not None else None , to_line , 1 )] )","title":"read_file()"},{"location":"Reference/mkreports/utils/","text":"relative_repo_root ( path ) Path relative to repo root or just the name. Source code in mkreports/utils.py def relative_repo_root ( path : Union [ Path , str ]) -> str : \"\"\" Path relative to repo root or just the name. \"\"\" try : repo = Repo ( \".\" , search_parent_directories = True ) root_dir = repo . working_tree_dir if root_dir is not None : return str ( Path ( path ) . relative_to ( root_dir )) except Exception : pass return Path ( path ) . name serialize_json ( obj ) Serialize an object to JSON, removing quotes for special strings. Source code in mkreports/utils.py def serialize_json ( obj : Any ) -> str : \"\"\"Serialize an object to JSON, removing quotes for special strings.\"\"\" return json . dumps ( obj ) . replace ( '\"____' , \"\" ) . replace ( '____\"' , \"\" ) snake_to_text ( x ) Convert snake case to regular text, with each word capitalized. Source code in mkreports/utils.py def snake_to_text ( x : str ) -> str : \"\"\"Convert snake case to regular text, with each word capitalized.\"\"\" return \" \" . join ([ w . capitalize () for w in x . split ( \"_\" )])","title":"utils"},{"location":"Reference/mkreports/utils/#mkreports.utils.relative_repo_root","text":"Path relative to repo root or just the name. Source code in mkreports/utils.py def relative_repo_root ( path : Union [ Path , str ]) -> str : \"\"\" Path relative to repo root or just the name. \"\"\" try : repo = Repo ( \".\" , search_parent_directories = True ) root_dir = repo . working_tree_dir if root_dir is not None : return str ( Path ( path ) . relative_to ( root_dir )) except Exception : pass return Path ( path ) . name","title":"relative_repo_root()"},{"location":"Reference/mkreports/utils/#mkreports.utils.serialize_json","text":"Serialize an object to JSON, removing quotes for special strings. Source code in mkreports/utils.py def serialize_json ( obj : Any ) -> str : \"\"\"Serialize an object to JSON, removing quotes for special strings.\"\"\" return json . dumps ( obj ) . replace ( '\"____' , \"\" ) . replace ( '____\"' , \"\" )","title":"serialize_json()"},{"location":"Reference/mkreports/utils/#mkreports.utils.snake_to_text","text":"Convert snake case to regular text, with each word capitalized. Source code in mkreports/utils.py def snake_to_text ( x : str ) -> str : \"\"\"Convert snake case to regular text, with each word capitalized.\"\"\" return \" \" . join ([ w . capitalize () for w in x . split ( \"_\" )])","title":"snake_to_text()"},{"location":"Reference/mkreports/md/base/","text":"Anchor ( MdObj ) dataclass Anchor(name: str) Source code in mkreports/md/base.py @register_md ( \"Anchor\" ) @dataclass () class Anchor ( MdObj ): name : str def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs return MdOut ( body = SpacedText ( f \"[]() {{ :name=' { self . name } ' }} \" , ( 0 , 0 ))) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs return MdOut ( body = SpacedText ( f \"[]() {{ :name=' { self . name } ' }} \" , ( 0 , 0 ))) Link ( MdObj ) dataclass Link(text: str = '', to_page_path: Optional[pathlib.Path] = None, anchor: Union[str, mkreports.md.base.Anchor, NoneType] = None, url: Optional[str] = None) Source code in mkreports/md/base.py @register_md ( \"Link\" ) @dataclass () class Link ( MdObj ): text : str = \"\" to_page_path : Optional [ Path ] = None anchor : Optional [ Union [ str , Anchor ]] = None url : Optional [ str ] = None def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : del kwargs if self . url is not None : link = self . url else : if page_path is None or self . to_page_path is None : if self . anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \"# { anchor_id } \" else : # both are not none, do relative if self . anchor is None : link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } \" else : anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } # { anchor_id } \" return MdOut ( body = SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 ))) to_markdown ( self , page_path , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : del kwargs if self . url is not None : link = self . url else : if page_path is None or self . to_page_path is None : if self . anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \"# { anchor_id } \" else : # both are not none, do relative if self . anchor is None : link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } \" else : anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } # { anchor_id } \" return MdOut ( body = SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 ))) MdObj ( ABC ) A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. Source code in mkreports/md/base.py class MdObj ( ABC ): \"\"\" A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. \"\"\" def __add__ ( self , other ) -> \"MdSeq\" : first = self if isinstance ( self , MdSeq ) else MdSeq ([ self ]) second = other if isinstance ( other , MdSeq ) else MdSeq ([ other ]) return first + second def __radd__ ( self , other ) -> \"MdSeq\" : first = other if isinstance ( self , MdSeq ) else MdSeq ([ other ]) second = self if isinstance ( other , MdSeq ) else MdSeq ([ self ]) return first + second @abstractmethod def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : \"\"\" Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. \"\"\" pass to_markdown ( self , page_path , idstore , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py @abstractmethod def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : \"\"\" Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. \"\"\" pass MdOut ( tuple ) MdOut(body, back, settings) Source code in mkreports/md/base.py class MdOut ( NamedTuple ): body : SpacedText = SpacedText ( \"\" ) back : SpacedText = SpacedText ( \"\" ) settings : Settings = Settings () __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in mkreports/md/base.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , body =< mkreports . md . text . SpacedText object at 0x7faf40efb070 > , back =< mkreports . md . text . SpacedText object at 0x7faf40efb0d0 > , settings = Settings ( mkdocs = {}, page = {})) special staticmethod Create new instance of MdOut(body, back, settings) __repr__ ( self ) special Return a nicely formatted representation string Source code in mkreports/md/base.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self MdSeq ( MdObj , Sequence ) Class to caputre a list of other MdObjs. Source code in mkreports/md/base.py @register_md ( \"MdSeq\" ) class MdSeq ( MdObj , Sequence ): \"\"\" Class to caputre a list of other MdObjs. \"\"\" items : Tuple [ MdObj , ... ] def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) def __getitem__ ( self , index : int ) -> MdObj : return self . items [ index ] def __len__ ( self ) -> int : return len ( self . items ) def __add__ ( self , other ) -> \"MdSeq\" : second_items = other . items if type ( other ) == MdSeq else ( other ,) return MdSeq ( self . items + second_items ) def __radd__ ( self , other ) -> \"MdSeq\" : second_items = other if type ( other ) == MdSeq else ( other ,) return MdSeq ( second_items + self . items ) def to_markdown ( self , ** kwargs ) -> MdOut : if len ( self . items ) == 0 : return MdOut () else : mdout_list = [ x . to_markdown ( ** kwargs ) for x in self . items ] return MdOut ( body = functools . reduce ( lambda x , y : x + y , [ elem . body for elem in mdout_list ] ), back = functools . reduce ( lambda x , y : x + y , [ elem . back for elem in mdout_list ] ), settings = functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in mdout_list ] ), ) __init__ ( self , items = ()) special Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Source code in mkreports/md/base.py def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , ** kwargs ) -> MdOut : if len ( self . items ) == 0 : return MdOut () else : mdout_list = [ x . to_markdown ( ** kwargs ) for x in self . items ] return MdOut ( body = functools . reduce ( lambda x , y : x + y , [ elem . body for elem in mdout_list ] ), back = functools . reduce ( lambda x , y : x + y , [ elem . back for elem in mdout_list ] ), settings = functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in mdout_list ] ), ) Paragraph ( MdObj ) dataclass Wraps an object in a paragraph. Source code in mkreports/md/base.py @register_md ( \"P\" ) @register_md ( \"Paragraph\" ) @dataclass class Paragraph ( MdObj ): \"\"\" Wraps an object in a paragraph. \"\"\" obj : MdObj anchor : Optional [ Union [ Anchor , str ]] def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) def to_markdown ( self , ** kwargs ) -> MdOut : obj_out = self . obj . to_markdown ( ** kwargs ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = ( SpacedText ( obj_out . body . text , ( 0 , 1 )) + self . anchor . to_markdown ( ** kwargs ) . body ) else : res_body = obj_out . body return MdOut ( body = SpacedText ( res_body , ( 2 , 2 )), back = obj_out . back ) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , ** kwargs ) -> MdOut : obj_out = self . obj . to_markdown ( ** kwargs ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = ( SpacedText ( obj_out . body . text , ( 0 , 1 )) + self . anchor . to_markdown ( ** kwargs ) . body ) else : res_body = obj_out . body return MdOut ( body = SpacedText ( res_body , ( 2 , 2 )), back = obj_out . back ) Raw ( MdObj ) dataclass Class to encapsulate raw markdown. Source code in mkreports/md/base.py @register_md ( \"Raw\" ) @dataclass () class Raw ( MdObj ): \"\"\" Class to encapsulate raw markdown. \"\"\" raw : Text page_settings : Dict [ str , Any ] mkdocs_settings : Dict [ str , Any ] def __init__ ( self , raw : Text = \"\" , dedent = True , back = \"\" , page_settings = None , mkdocs_settings = None , ): super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) self . raw = raw self . back = back self . page_settings = page_settings self . mkdocs_settings = mkdocs_settings def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs return MdOut ( body = SpacedText ( self . raw ), back = SpacedText ( self . back ), settings = Settings ( page = self . page_settings if self . page_settings is not None else {}, mkdocs = self . mkdocs_settings if self . mkdocs_settings is not None else {}, ), ) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs return MdOut ( body = SpacedText ( self . raw ), back = SpacedText ( self . back ), settings = Settings ( page = self . page_settings if self . page_settings is not None else {}, mkdocs = self . mkdocs_settings if self . mkdocs_settings is not None else {}, ), )","title":"base"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Anchor","text":"Anchor(name: str) Source code in mkreports/md/base.py @register_md ( \"Anchor\" ) @dataclass () class Anchor ( MdObj ): name : str def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs return MdOut ( body = SpacedText ( f \"[]() {{ :name=' { self . name } ' }} \" , ( 0 , 0 )))","title":"Anchor"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Anchor.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs return MdOut ( body = SpacedText ( f \"[]() {{ :name=' { self . name } ' }} \" , ( 0 , 0 )))","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Link","text":"Link(text: str = '', to_page_path: Optional[pathlib.Path] = None, anchor: Union[str, mkreports.md.base.Anchor, NoneType] = None, url: Optional[str] = None) Source code in mkreports/md/base.py @register_md ( \"Link\" ) @dataclass () class Link ( MdObj ): text : str = \"\" to_page_path : Optional [ Path ] = None anchor : Optional [ Union [ str , Anchor ]] = None url : Optional [ str ] = None def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : del kwargs if self . url is not None : link = self . url else : if page_path is None or self . to_page_path is None : if self . anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \"# { anchor_id } \" else : # both are not none, do relative if self . anchor is None : link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } \" else : anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } # { anchor_id } \" return MdOut ( body = SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 )))","title":"Link"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Link.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : del kwargs if self . url is not None : link = self . url else : if page_path is None or self . to_page_path is None : if self . anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \"# { anchor_id } \" else : # both are not none, do relative if self . anchor is None : link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } \" else : anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } # { anchor_id } \" return MdOut ( body = SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 )))","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdObj","text":"A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. Source code in mkreports/md/base.py class MdObj ( ABC ): \"\"\" A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. \"\"\" def __add__ ( self , other ) -> \"MdSeq\" : first = self if isinstance ( self , MdSeq ) else MdSeq ([ self ]) second = other if isinstance ( other , MdSeq ) else MdSeq ([ other ]) return first + second def __radd__ ( self , other ) -> \"MdSeq\" : first = other if isinstance ( self , MdSeq ) else MdSeq ([ other ]) second = self if isinstance ( other , MdSeq ) else MdSeq ([ self ]) return first + second @abstractmethod def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : \"\"\" Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. \"\"\" pass","title":"MdObj"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdObj.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py @abstractmethod def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : \"\"\" Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. \"\"\" pass","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdOut","text":"MdOut(body, back, settings) Source code in mkreports/md/base.py class MdOut ( NamedTuple ): body : SpacedText = SpacedText ( \"\" ) back : SpacedText = SpacedText ( \"\" ) settings : Settings = Settings ()","title":"MdOut"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdOut.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in mkreports/md/base.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdOut.__new__","text":"Create new instance of MdOut(body, back, settings)","title":"__new__()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdOut.__repr__","text":"Return a nicely formatted representation string Source code in mkreports/md/base.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdSeq","text":"Class to caputre a list of other MdObjs. Source code in mkreports/md/base.py @register_md ( \"MdSeq\" ) class MdSeq ( MdObj , Sequence ): \"\"\" Class to caputre a list of other MdObjs. \"\"\" items : Tuple [ MdObj , ... ] def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) def __getitem__ ( self , index : int ) -> MdObj : return self . items [ index ] def __len__ ( self ) -> int : return len ( self . items ) def __add__ ( self , other ) -> \"MdSeq\" : second_items = other . items if type ( other ) == MdSeq else ( other ,) return MdSeq ( self . items + second_items ) def __radd__ ( self , other ) -> \"MdSeq\" : second_items = other if type ( other ) == MdSeq else ( other ,) return MdSeq ( second_items + self . items ) def to_markdown ( self , ** kwargs ) -> MdOut : if len ( self . items ) == 0 : return MdOut () else : mdout_list = [ x . to_markdown ( ** kwargs ) for x in self . items ] return MdOut ( body = functools . reduce ( lambda x , y : x + y , [ elem . body for elem in mdout_list ] ), back = functools . reduce ( lambda x , y : x + y , [ elem . back for elem in mdout_list ] ), settings = functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in mdout_list ] ), )","title":"MdSeq"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdSeq.__init__","text":"Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Source code in mkreports/md/base.py def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ])","title":"__init__()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdSeq.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , ** kwargs ) -> MdOut : if len ( self . items ) == 0 : return MdOut () else : mdout_list = [ x . to_markdown ( ** kwargs ) for x in self . items ] return MdOut ( body = functools . reduce ( lambda x , y : x + y , [ elem . body for elem in mdout_list ] ), back = functools . reduce ( lambda x , y : x + y , [ elem . back for elem in mdout_list ] ), settings = functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in mdout_list ] ), )","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Paragraph","text":"Wraps an object in a paragraph. Source code in mkreports/md/base.py @register_md ( \"P\" ) @register_md ( \"Paragraph\" ) @dataclass class Paragraph ( MdObj ): \"\"\" Wraps an object in a paragraph. \"\"\" obj : MdObj anchor : Optional [ Union [ Anchor , str ]] def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) def to_markdown ( self , ** kwargs ) -> MdOut : obj_out = self . obj . to_markdown ( ** kwargs ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = ( SpacedText ( obj_out . body . text , ( 0 , 1 )) + self . anchor . to_markdown ( ** kwargs ) . body ) else : res_body = obj_out . body return MdOut ( body = SpacedText ( res_body , ( 2 , 2 )), back = obj_out . back )","title":"Paragraph"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Paragraph.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , ** kwargs ) -> MdOut : obj_out = self . obj . to_markdown ( ** kwargs ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = ( SpacedText ( obj_out . body . text , ( 0 , 1 )) + self . anchor . to_markdown ( ** kwargs ) . body ) else : res_body = obj_out . body return MdOut ( body = SpacedText ( res_body , ( 2 , 2 )), back = obj_out . back )","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Raw","text":"Class to encapsulate raw markdown. Source code in mkreports/md/base.py @register_md ( \"Raw\" ) @dataclass () class Raw ( MdObj ): \"\"\" Class to encapsulate raw markdown. \"\"\" raw : Text page_settings : Dict [ str , Any ] mkdocs_settings : Dict [ str , Any ] def __init__ ( self , raw : Text = \"\" , dedent = True , back = \"\" , page_settings = None , mkdocs_settings = None , ): super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) self . raw = raw self . back = back self . page_settings = page_settings self . mkdocs_settings = mkdocs_settings def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs return MdOut ( body = SpacedText ( self . raw ), back = SpacedText ( self . back ), settings = Settings ( page = self . page_settings if self . page_settings is not None else {}, mkdocs = self . mkdocs_settings if self . mkdocs_settings is not None else {}, ), )","title":"Raw"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Raw.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs return MdOut ( body = SpacedText ( self . raw ), back = SpacedText ( self . back ), settings = Settings ( page = self . page_settings if self . page_settings is not None else {}, mkdocs = self . mkdocs_settings if self . mkdocs_settings is not None else {}, ), )","title":"to_markdown()"},{"location":"Reference/mkreports/md/combo/","text":"CollapsedCodeFile ( MdObj ) Source code in mkreports/md/combo.py @register_md ( \"CollapsedCodeFile\" ) class CollapsedCodeFile ( MdObj ): def __init__ ( self , file : Path , store_path : Path , report_path : Path , javascript_path : Path , title : Optional [ str ] = None , ) -> None : self . obj = Admonition ( CodeFile ( file , title = title , store_path = store_path , report_path = report_path ), collapse = True , title = \"Code\" , kind = \"code\" , javascript_path = javascript_path , ) def to_markdown ( self , ** kwargs ) -> MdOut : md_out = self . obj . to_markdown ( ** kwargs ) return md_out to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/combo.py def to_markdown ( self , ** kwargs ) -> MdOut : md_out = self . obj . to_markdown ( ** kwargs ) return md_out","title":"combo"},{"location":"Reference/mkreports/md/combo/#mkreports.md.combo.CollapsedCodeFile","text":"Source code in mkreports/md/combo.py @register_md ( \"CollapsedCodeFile\" ) class CollapsedCodeFile ( MdObj ): def __init__ ( self , file : Path , store_path : Path , report_path : Path , javascript_path : Path , title : Optional [ str ] = None , ) -> None : self . obj = Admonition ( CodeFile ( file , title = title , store_path = store_path , report_path = report_path ), collapse = True , title = \"Code\" , kind = \"code\" , javascript_path = javascript_path , ) def to_markdown ( self , ** kwargs ) -> MdOut : md_out = self . obj . to_markdown ( ** kwargs ) return md_out","title":"CollapsedCodeFile"},{"location":"Reference/mkreports/md/combo/#mkreports.md.combo.CollapsedCodeFile.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/combo.py def to_markdown ( self , ** kwargs ) -> MdOut : md_out = self . obj . to_markdown ( ** kwargs ) return md_out","title":"to_markdown()"},{"location":"Reference/mkreports/md/containers/","text":"Admonition ( MdObj ) dataclass Admonition(text: Union[str, ForwardRef('SpacedText'), mkreports.md.base.MdObj], javascript_path: pathlib.Path, title: Optional[str] = None, kind: Literal['note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote', 'code'] = 'note', collapse: bool = False) Source code in mkreports/md/containers.py @register_md ( \"Admonition\" ) @dataclass class Admonition ( MdObj ): text : Union [ Text , MdObj ] javascript_path : Path title : Optional [ str ] = None kind : Literal [ \"note\" , \"abstract\" , \"info\" , \"tip\" , \"success\" , \"question\" , \"warning\" , \"failure\" , \"danger\" , \"bug\" , \"example\" , \"quote\" , \"code\" , ] = \"note\" collapse : bool = False def __post_init__ ( self ): if self . kind == \"code\" : # create a css file that creates a 'code' admonition self . css_path = self . javascript_path / \"code_admonition.css\" self . javascript_path . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"code_admonition.css\" , self . css_path , ) def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : # if code-admonition, we need to load additional css if self . kind == \"code\" : rel_css_path = relpath_html ( self . css_path , page_path ) page_settings = dict ( css = [ rel_css_path ]) else : page_settings = {} cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] }, page = page_settings , ) if isinstance ( self . text , MdObj ): admon_text , back , settings = self . text . to_markdown ( ** kwargs ) settings = cont_settings + settings else : admon_text , back , settings = str ( self . text ), SpacedText (), cont_settings if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' return MdOut ( body = SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ), ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )), back = back , settings = settings , ) to_markdown ( self , page_path , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : # if code-admonition, we need to load additional css if self . kind == \"code\" : rel_css_path = relpath_html ( self . css_path , page_path ) page_settings = dict ( css = [ rel_css_path ]) else : page_settings = {} cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] }, page = page_settings , ) if isinstance ( self . text , MdObj ): admon_text , back , settings = self . text . to_markdown ( ** kwargs ) settings = cont_settings + settings else : admon_text , back , settings = str ( self . text ), SpacedText (), cont_settings if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' return MdOut ( body = SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ), ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )), back = back , settings = settings , ) Code ( MdObj ) dataclass Wrapper class for code. Source code in mkreports/md/containers.py @register_md ( \"Code\" ) @dataclass ( frozen = True ) class Code ( MdObj ): \"\"\"Wrapper class for code.\"\"\" code : str title : Optional [ str ] = None first_line : Optional [ int ] = None hl_lines : Optional [ Tuple [ int , int ]] = None language : Optional [ str ] = \"python\" dedent : bool = True def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) return MdOut ( body = SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ), settings = settings , ) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) return MdOut ( body = SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ), settings = settings , ) CodeFile ( File ) Code block with the content of a file. Source code in mkreports/md/containers.py @register_md ( \"CodeFile\" ) class CodeFile ( File ): \"\"\" Code block with the content of a file. \"\"\" def __init__ ( self , path : Path , store_path : Path , report_path : Path , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Move a code-file into the store-dir and reference it in code block. \"\"\" super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) self . report_path = report_path self . title = title self . hl_lines = hl_lines self . language = language def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) return MdOut ( body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( self . report_path ) } '\" , annots ), ( 2 , 2 ), ), settings = settings , ) __init__ ( self , path , store_path , report_path , title = None , hl_lines = None , language = 'python' ) special Move a code-file into the store-dir and reference it in code block. Source code in mkreports/md/containers.py def __init__ ( self , path : Path , store_path : Path , report_path : Path , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Move a code-file into the store-dir and reference it in code block. \"\"\" super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) self . report_path = report_path self . title = title self . hl_lines = hl_lines self . language = language to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) return MdOut ( body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( self . report_path ) } '\" , annots ), ( 2 , 2 ), ), settings = settings , ) Tab ( MdObj ) dataclass Tab(text: Union[str, ForwardRef('SpacedText'), mkreports.md.base.MdObj], title: Optional[str] = None) Source code in mkreports/md/containers.py @register_md ( \"Tab\" ) @dataclass class Tab ( MdObj ): text : Union [ Text , MdObj ] title : Optional [ str ] = None def to_markdown ( self , ** kwargs ) -> MdOut : tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . text , MdObj ): tab_text , back , settings = self . text . to_markdown ( ** kwargs ) settings = tab_settings + settings else : tab_text , back , settings = str ( self . text ), SpacedText (), tab_settings if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" return MdOut ( body = SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 )), back = back , settings = settings , ) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , ** kwargs ) -> MdOut : tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . text , MdObj ): tab_text , back , settings = self . text . to_markdown ( ** kwargs ) settings = tab_settings + settings else : tab_text , back , settings = str ( self . text ), SpacedText (), tab_settings if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" return MdOut ( body = SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 )), back = back , settings = settings , )","title":"containers"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Admonition","text":"Admonition(text: Union[str, ForwardRef('SpacedText'), mkreports.md.base.MdObj], javascript_path: pathlib.Path, title: Optional[str] = None, kind: Literal['note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote', 'code'] = 'note', collapse: bool = False) Source code in mkreports/md/containers.py @register_md ( \"Admonition\" ) @dataclass class Admonition ( MdObj ): text : Union [ Text , MdObj ] javascript_path : Path title : Optional [ str ] = None kind : Literal [ \"note\" , \"abstract\" , \"info\" , \"tip\" , \"success\" , \"question\" , \"warning\" , \"failure\" , \"danger\" , \"bug\" , \"example\" , \"quote\" , \"code\" , ] = \"note\" collapse : bool = False def __post_init__ ( self ): if self . kind == \"code\" : # create a css file that creates a 'code' admonition self . css_path = self . javascript_path / \"code_admonition.css\" self . javascript_path . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"code_admonition.css\" , self . css_path , ) def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : # if code-admonition, we need to load additional css if self . kind == \"code\" : rel_css_path = relpath_html ( self . css_path , page_path ) page_settings = dict ( css = [ rel_css_path ]) else : page_settings = {} cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] }, page = page_settings , ) if isinstance ( self . text , MdObj ): admon_text , back , settings = self . text . to_markdown ( ** kwargs ) settings = cont_settings + settings else : admon_text , back , settings = str ( self . text ), SpacedText (), cont_settings if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' return MdOut ( body = SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ), ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )), back = back , settings = settings , )","title":"Admonition"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Admonition.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : # if code-admonition, we need to load additional css if self . kind == \"code\" : rel_css_path = relpath_html ( self . css_path , page_path ) page_settings = dict ( css = [ rel_css_path ]) else : page_settings = {} cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] }, page = page_settings , ) if isinstance ( self . text , MdObj ): admon_text , back , settings = self . text . to_markdown ( ** kwargs ) settings = cont_settings + settings else : admon_text , back , settings = str ( self . text ), SpacedText (), cont_settings if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' return MdOut ( body = SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ), ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )), back = back , settings = settings , )","title":"to_markdown()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Code","text":"Wrapper class for code. Source code in mkreports/md/containers.py @register_md ( \"Code\" ) @dataclass ( frozen = True ) class Code ( MdObj ): \"\"\"Wrapper class for code.\"\"\" code : str title : Optional [ str ] = None first_line : Optional [ int ] = None hl_lines : Optional [ Tuple [ int , int ]] = None language : Optional [ str ] = \"python\" dedent : bool = True def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) return MdOut ( body = SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ), settings = settings , )","title":"Code"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Code.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) return MdOut ( body = SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ), settings = settings , )","title":"to_markdown()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.CodeFile","text":"Code block with the content of a file. Source code in mkreports/md/containers.py @register_md ( \"CodeFile\" ) class CodeFile ( File ): \"\"\" Code block with the content of a file. \"\"\" def __init__ ( self , path : Path , store_path : Path , report_path : Path , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Move a code-file into the store-dir and reference it in code block. \"\"\" super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) self . report_path = report_path self . title = title self . hl_lines = hl_lines self . language = language def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) return MdOut ( body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( self . report_path ) } '\" , annots ), ( 2 , 2 ), ), settings = settings , )","title":"CodeFile"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.CodeFile.__init__","text":"Move a code-file into the store-dir and reference it in code block. Source code in mkreports/md/containers.py def __init__ ( self , path : Path , store_path : Path , report_path : Path , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Move a code-file into the store-dir and reference it in code block. \"\"\" super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) self . report_path = report_path self . title = title self . hl_lines = hl_lines self . language = language","title":"__init__()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.CodeFile.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) return MdOut ( body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( self . report_path ) } '\" , annots ), ( 2 , 2 ), ), settings = settings , )","title":"to_markdown()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Tab","text":"Tab(text: Union[str, ForwardRef('SpacedText'), mkreports.md.base.MdObj], title: Optional[str] = None) Source code in mkreports/md/containers.py @register_md ( \"Tab\" ) @dataclass class Tab ( MdObj ): text : Union [ Text , MdObj ] title : Optional [ str ] = None def to_markdown ( self , ** kwargs ) -> MdOut : tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . text , MdObj ): tab_text , back , settings = self . text . to_markdown ( ** kwargs ) settings = tab_settings + settings else : tab_text , back , settings = str ( self . text ), SpacedText (), tab_settings if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" return MdOut ( body = SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 )), back = back , settings = settings , )","title":"Tab"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Tab.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , ** kwargs ) -> MdOut : tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . text , MdObj ): tab_text , back , settings = self . text . to_markdown ( ** kwargs ) settings = tab_settings + settings else : tab_text , back , settings = str ( self . text ), SpacedText (), tab_settings if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" return MdOut ( body = SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 )), back = back , settings = settings , )","title":"to_markdown()"},{"location":"Reference/mkreports/md/docstring/","text":"Docstring ( MdObj ) Source code in mkreports/md/docstring.py @register_md ( \"Docstring\" ) class Docstring ( MdObj ): def __init__ ( self , obj_name : str ) -> None : super () . __init__ () self . obj_name = obj_name def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) return MdOut ( body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )), settings = cont_settings ) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/docstring.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) return MdOut ( body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )), settings = cont_settings )","title":"docstring"},{"location":"Reference/mkreports/md/docstring/#mkreports.md.docstring.Docstring","text":"Source code in mkreports/md/docstring.py @register_md ( \"Docstring\" ) class Docstring ( MdObj ): def __init__ ( self , obj_name : str ) -> None : super () . __init__ () self . obj_name = obj_name def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) return MdOut ( body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )), settings = cont_settings )","title":"Docstring"},{"location":"Reference/mkreports/md/docstring/#mkreports.md.docstring.Docstring.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/docstring.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) return MdOut ( body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )), settings = cont_settings )","title":"to_markdown()"},{"location":"Reference/mkreports/md/file/","text":"File ( MdObj ) Source code in mkreports/md/file.py @register_md ( 'File' ) class File ( MdObj ): path : Path allow_copy : bool store_path : Path use_hash : bool _hash : Optional [ str ] = None def __init__ ( self , path : Union [ str , Path ], store_path : Path , allow_copy : bool = True , use_hash : bool = False , ) -> None : super () . __init__ () # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path @property def hash ( self ) -> str : if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash def to_markdown ( self , page_path : Optional [ Path ] = None ) -> MdOut : del page_path return MdOut () to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/file.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> MdOut : del page_path return MdOut () relpath_html ( target , page_path ) Relative path as to be used for html Source code in mkreports/md/file.py def relpath_html ( target : Path , page_path : Path ): \"\"\" Relative path as to be used for html \"\"\" if page_path . stem == \"index\" : # here, for translating to html, this path is referred to as its parent return relpath ( target , page_path . parent ) else : # for translating to html, will be converted to path.parent / path.stem / index.html return relpath ( target , page_path ) true_stem ( path ) True stem of a path, without all suffixes, not just last. Source code in mkreports/md/file.py def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"file"},{"location":"Reference/mkreports/md/file/#mkreports.md.file.File","text":"Source code in mkreports/md/file.py @register_md ( 'File' ) class File ( MdObj ): path : Path allow_copy : bool store_path : Path use_hash : bool _hash : Optional [ str ] = None def __init__ ( self , path : Union [ str , Path ], store_path : Path , allow_copy : bool = True , use_hash : bool = False , ) -> None : super () . __init__ () # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path @property def hash ( self ) -> str : if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash def to_markdown ( self , page_path : Optional [ Path ] = None ) -> MdOut : del page_path return MdOut ()","title":"File"},{"location":"Reference/mkreports/md/file/#mkreports.md.file.File.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/file.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> MdOut : del page_path return MdOut ()","title":"to_markdown()"},{"location":"Reference/mkreports/md/file/#mkreports.md.file.relpath_html","text":"Relative path as to be used for html Source code in mkreports/md/file.py def relpath_html ( target : Path , page_path : Path ): \"\"\" Relative path as to be used for html \"\"\" if page_path . stem == \"index\" : # here, for translating to html, this path is referred to as its parent return relpath ( target , page_path . parent ) else : # for translating to html, will be converted to path.parent / path.stem / index.html return relpath ( target , page_path )","title":"relpath_html()"},{"location":"Reference/mkreports/md/file/#mkreports.md.file.true_stem","text":"True stem of a path, without all suffixes, not just last. Source code in mkreports/md/file.py def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"true_stem()"},{"location":"Reference/mkreports/md/header/","text":"Heading ( MdObj ) dataclass Heading(title: str, level: int, style: Literal['atx', 'setext'] = 'atx', anchor: Union[str, mkreports.md.base.Anchor, NoneType] = None) Source code in mkreports/md/header.py @register_md ( \"Heading\" ) @dataclass class Heading ( MdObj ): title : str level : int style : Literal [ \"atx\" , \"setext\" ] = \"atx\" anchor : Optional [ Union [ Anchor , str ]] = None def __post_init__ ( self ): if isinstance ( self . anchor , str ): self . anchor = Anchor ( self . anchor ) def to_markdown ( self , ** kwargs ) -> MdOut : heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . to_markdown ( ** kwargs ) . body . text return MdOut ( body = SpacedText ( heading , ( 2 , 2 ), ) ) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/header.py def to_markdown ( self , ** kwargs ) -> MdOut : heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . to_markdown ( ** kwargs ) . body . text return MdOut ( body = SpacedText ( heading , ( 2 , 2 ), ) )","title":"header"},{"location":"Reference/mkreports/md/header/#mkreports.md.header.Heading","text":"Heading(title: str, level: int, style: Literal['atx', 'setext'] = 'atx', anchor: Union[str, mkreports.md.base.Anchor, NoneType] = None) Source code in mkreports/md/header.py @register_md ( \"Heading\" ) @dataclass class Heading ( MdObj ): title : str level : int style : Literal [ \"atx\" , \"setext\" ] = \"atx\" anchor : Optional [ Union [ Anchor , str ]] = None def __post_init__ ( self ): if isinstance ( self . anchor , str ): self . anchor = Anchor ( self . anchor ) def to_markdown ( self , ** kwargs ) -> MdOut : heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . to_markdown ( ** kwargs ) . body . text return MdOut ( body = SpacedText ( heading , ( 2 , 2 ), ) )","title":"Heading"},{"location":"Reference/mkreports/md/header/#mkreports.md.header.Heading.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/header.py def to_markdown ( self , ** kwargs ) -> MdOut : heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . to_markdown ( ** kwargs ) . body . text return MdOut ( body = SpacedText ( heading , ( 2 , 2 ), ) )","title":"to_markdown()"},{"location":"Reference/mkreports/md/idstore/","text":"IDStore Source code in mkreports/md/idstore.py class IDStore : _counts : Dict [ str , int ] _used : set [ str ] def __init__ ( self , start_with : int = 0 , used_ids : set [ str ] = set ()) -> None : self . _count = defaultdict ( lambda : start_with - 1 ) self . _used = copy ( used_ids ) self . _start_with = start_with def _increment ( self , prefix : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" self . _count [ prefix ] += 1 return self . _count [ prefix ] def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id next_id ( self , prefix ) Returns an id with a counted number at the end. Source code in mkreports/md/idstore.py def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id","title":"idstore"},{"location":"Reference/mkreports/md/idstore/#mkreports.md.idstore.IDStore","text":"Source code in mkreports/md/idstore.py class IDStore : _counts : Dict [ str , int ] _used : set [ str ] def __init__ ( self , start_with : int = 0 , used_ids : set [ str ] = set ()) -> None : self . _count = defaultdict ( lambda : start_with - 1 ) self . _used = copy ( used_ids ) self . _start_with = start_with def _increment ( self , prefix : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" self . _count [ prefix ] += 1 return self . _count [ prefix ] def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id","title":"IDStore"},{"location":"Reference/mkreports/md/idstore/#mkreports.md.idstore.IDStore.next_id","text":"Returns an id with a counted number at the end. Source code in mkreports/md/idstore.py def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id","title":"next_id()"},{"location":"Reference/mkreports/md/image/","text":"Altair ( File ) Source code in mkreports/md/image.py @register_md ( \"Altair\" ) class Altair ( File ): def __init__ ( self , altair , store_path : Path , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"altair.csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ), settings = settings , ) to_markdown ( self , page_path , idstore , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ), settings = settings , ) ImageFile ( File ) Source code in mkreports/md/image.py @register_md ( \"ImageFile\" ) class ImageFile ( File ): text : str tooltip : str link_type : str def __init__ ( self , path : Union [ str , Path ], store_path : Path , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : super () . __init__ ( path = path , store_path = store_path , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : del kwargs if self . link_type == \"inline\" : return MdOut ( body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_path . parent )), tooltip = self . tooltip , ) ) ) elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" ) to_markdown ( self , page_path , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : del kwargs if self . link_type == \"inline\" : return MdOut ( body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_path . parent )), tooltip = self . tooltip , ) ) ) elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" ) Plotly ( File ) Source code in mkreports/md/image.py @register_md ( \"Plotly\" ) class Plotly ( File ): def __init__ ( self , plotly , store_path : Path , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"plotly.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ), settings = settings , ) to_markdown ( self , page_path , idstore , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ), settings = settings , )","title":"image"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Altair","text":"Source code in mkreports/md/image.py @register_md ( \"Altair\" ) class Altair ( File ): def __init__ ( self , altair , store_path : Path , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"altair.csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ), settings = settings , )","title":"Altair"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Altair.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ), settings = settings , )","title":"to_markdown()"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.ImageFile","text":"Source code in mkreports/md/image.py @register_md ( \"ImageFile\" ) class ImageFile ( File ): text : str tooltip : str link_type : str def __init__ ( self , path : Union [ str , Path ], store_path : Path , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : super () . __init__ ( path = path , store_path = store_path , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : del kwargs if self . link_type == \"inline\" : return MdOut ( body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_path . parent )), tooltip = self . tooltip , ) ) ) elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" )","title":"ImageFile"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.ImageFile.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path , ** kwargs ) -> MdOut : del kwargs if self . link_type == \"inline\" : return MdOut ( body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_path . parent )), tooltip = self . tooltip , ) ) ) elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" )","title":"to_markdown()"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Plotly","text":"Source code in mkreports/md/image.py @register_md ( \"Plotly\" ) class Plotly ( File ): def __init__ ( self , plotly , store_path : Path , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"plotly.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ), settings = settings , )","title":"Plotly"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Plotly.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ), settings = settings , )","title":"to_markdown()"},{"location":"Reference/mkreports/md/list/","text":"List ( MdObj ) Source code in mkreports/md/list.py @register_md ( \"List\" ) class List ( MdObj ): marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] list : MdSeq def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): super () . __init__ () self . list = MdSeq ( items ) self . marker = marker def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) def __len__ ( self ) -> int : return len ( self . list ) def __add__ ( self , other ) -> \"List\" : del other raise NotImplementedError ( \"Addition not supported for MdList\" ) def __radd__ ( self , other ) -> \"List\" : del other raise NotImplementedError ( \"Addition not supported for MdList\" ) def to_markdown ( self , ** kwargs ) -> MdOut : # create the markdown output for every item; indent it appropriately # and then put it all together. # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( len ( self ))] else : prefix = [ f \" { self . marker } \" ] * len ( self ) md_list = [ indent_hanging ( elem . to_markdown ( ** kwargs ) . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] return MdOut ( body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 ))) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/list.py def to_markdown ( self , ** kwargs ) -> MdOut : # create the markdown output for every item; indent it appropriately # and then put it all together. # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( len ( self ))] else : prefix = [ f \" { self . marker } \" ] * len ( self ) md_list = [ indent_hanging ( elem . to_markdown ( ** kwargs ) . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] return MdOut ( body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )))","title":"list"},{"location":"Reference/mkreports/md/list/#mkreports.md.list.List","text":"Source code in mkreports/md/list.py @register_md ( \"List\" ) class List ( MdObj ): marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] list : MdSeq def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): super () . __init__ () self . list = MdSeq ( items ) self . marker = marker def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) def __len__ ( self ) -> int : return len ( self . list ) def __add__ ( self , other ) -> \"List\" : del other raise NotImplementedError ( \"Addition not supported for MdList\" ) def __radd__ ( self , other ) -> \"List\" : del other raise NotImplementedError ( \"Addition not supported for MdList\" ) def to_markdown ( self , ** kwargs ) -> MdOut : # create the markdown output for every item; indent it appropriately # and then put it all together. # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( len ( self ))] else : prefix = [ f \" { self . marker } \" ] * len ( self ) md_list = [ indent_hanging ( elem . to_markdown ( ** kwargs ) . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] return MdOut ( body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )))","title":"List"},{"location":"Reference/mkreports/md/list/#mkreports.md.list.List.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/list.py def to_markdown ( self , ** kwargs ) -> MdOut : # create the markdown output for every item; indent it appropriately # and then put it all together. # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( len ( self ))] else : prefix = [ f \" { self . marker } \" ] * len ( self ) md_list = [ indent_hanging ( elem . to_markdown ( ** kwargs ) . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] return MdOut ( body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )))","title":"to_markdown()"},{"location":"Reference/mkreports/md/settings/","text":"Settings dataclass Settings(mkdocs: Dict[str, Any] = , page: Dict[str, Any] = ) Source code in mkreports/md/settings.py @dataclass class Settings : mkdocs : Dict [ str , Any ] = field ( default_factory = dict ) page : Dict [ str , Any ] = field ( default_factory = dict ) def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), ) __add__ ( self , other ) special Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. Source code in mkreports/md/settings.py def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), ) strategy_append_new ( config , path , base , nxt ) prepend nxt to base. Source code in mkreports/md/settings.py def strategy_append_new ( config , path , base , nxt ): \"\"\"prepend nxt to base.\"\"\" del config , path return base + [ x for x in nxt if x not in base ]","title":"settings"},{"location":"Reference/mkreports/md/settings/#mkreports.md.settings.Settings","text":"Settings(mkdocs: Dict[str, Any] = , page: Dict[str, Any] = ) Source code in mkreports/md/settings.py @dataclass class Settings : mkdocs : Dict [ str , Any ] = field ( default_factory = dict ) page : Dict [ str , Any ] = field ( default_factory = dict ) def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), )","title":"Settings"},{"location":"Reference/mkreports/md/settings/#mkreports.md.settings.Settings.__add__","text":"Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. Source code in mkreports/md/settings.py def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), )","title":"__add__()"},{"location":"Reference/mkreports/md/settings/#mkreports.md.settings.strategy_append_new","text":"prepend nxt to base. Source code in mkreports/md/settings.py def strategy_append_new ( config , path , base , nxt ): \"\"\"prepend nxt to base.\"\"\" del config , path return base + [ x for x in nxt if x not in base ]","title":"strategy_append_new()"},{"location":"Reference/mkreports/md/table/","text":"DataTable ( File ) Source code in mkreports/md/table.py @register_md ( \"DataTable\" ) class DataTable ( File ): def __init__ ( self , table : pd . DataFrame , store_path : Path , column_settings : Optional [ dict ] = None , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"datatable.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) # prepare the table settings col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs datatable_id = idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = serialize_json ( table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ), settings = settings , ) to_markdown ( self , page_path , idstore , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs datatable_id = idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = serialize_json ( table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ), settings = settings , ) Table ( MdObj ) Source code in mkreports/md/table.py @register_md ( \"Table\" ) class Table ( MdObj ): table : pd . DataFrame kwargs : Dict [ str , Any ] def __init__ ( self , table : pd . DataFrame , ** kwargs ): super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" return MdOut ( body = SpacedText ( table_md , ( 2 , 2 ))) to_markdown ( self , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" return MdOut ( body = SpacedText ( table_md , ( 2 , 2 ))) Tabulator ( File ) Source code in mkreports/md/table.py @register_md ( \"Tabulator\" ) class Tabulator ( File ): def __init__ ( self , table : pd . DataFrame , store_path : Path , javascript_path : Path , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"tabulator.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"records\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) # create the javascript file self . min_max_filter_path = javascript_path / \"min_max_filter.js\" self . min_max_filter_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"tabulator_js\" / \"min_max_filter.js\" , self . min_max_filter_path , ) # produce the column settings col_list = create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs tabulator_id = idstore . next_id ( \"tabulator_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_filter_path = relpath_html ( self . min_max_filter_path , page_path ) rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , rel_filter_path , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( tabulator_id ), settings = settings , ) to_markdown ( self , page_path , idstore , ** kwargs ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs tabulator_id = idstore . next_id ( \"tabulator_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_filter_path = relpath_html ( self . min_max_filter_path , page_path ) rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , rel_filter_path , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( tabulator_id ), settings = settings , )","title":"table"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.DataTable","text":"Source code in mkreports/md/table.py @register_md ( \"DataTable\" ) class DataTable ( File ): def __init__ ( self , table : pd . DataFrame , store_path : Path , column_settings : Optional [ dict ] = None , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"datatable.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) # prepare the table settings col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs datatable_id = idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = serialize_json ( table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ), settings = settings , )","title":"DataTable"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.DataTable.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs datatable_id = idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = serialize_json ( table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ), settings = settings , )","title":"to_markdown()"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.Table","text":"Source code in mkreports/md/table.py @register_md ( \"Table\" ) class Table ( MdObj ): table : pd . DataFrame kwargs : Dict [ str , Any ] def __init__ ( self , table : pd . DataFrame , ** kwargs ): super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" return MdOut ( body = SpacedText ( table_md , ( 2 , 2 )))","title":"Table"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.Table.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , ** kwargs ) -> MdOut : del kwargs table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" return MdOut ( body = SpacedText ( table_md , ( 2 , 2 )))","title":"to_markdown()"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.Tabulator","text":"Source code in mkreports/md/table.py @register_md ( \"Tabulator\" ) class Tabulator ( File ): def __init__ ( self , table : pd . DataFrame , store_path : Path , javascript_path : Path , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"tabulator.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"records\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) # create the javascript file self . min_max_filter_path = javascript_path / \"min_max_filter.js\" self . min_max_filter_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"tabulator_js\" / \"min_max_filter.js\" , self . min_max_filter_path , ) # produce the column settings col_list = create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs tabulator_id = idstore . next_id ( \"tabulator_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_filter_path = relpath_html ( self . min_max_filter_path , page_path ) rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , rel_filter_path , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( tabulator_id ), settings = settings , )","title":"Tabulator"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.Tabulator.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Path , idstore : IDStore , ** kwargs ) -> MdOut : del kwargs tabulator_id = idstore . next_id ( \"tabulator_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_filter_path = relpath_html ( self . min_max_filter_path , page_path ) rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , rel_filter_path , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) return MdOut ( body = SpacedText ( body_html , ( 2 , 2 )), back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( tabulator_id ), settings = settings , )","title":"to_markdown()"},{"location":"Reference/mkreports/md/text/","text":"SpacedText Representation of text with spaces before or after. Source code in mkreports/md/text.py class SpacedText : \"\"\"Representation of text with spaces before or after.\"\"\" text : str req_nl : Tuple [ int , int ] def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) def __eq__ ( self , other : Any ) -> bool : if type ( self ) != type ( other ): return False return self . text == other . text and self . req_nl == other . req_nl def __add__ ( self , follow : Text ) -> \"SpacedText\" : return _add_text ( self , SpacedText ( follow )) def __radd__ ( self , precede : Text ) -> \"SpacedText\" : return _add_text ( SpacedText ( precede ), self ) def format_text ( self , precede : Text = \"\" , follow : Text = \"\" ) -> str : add_before = _needed_nl_between ( SpacedText ( precede ), self ) add_after = _needed_nl_between ( self , SpacedText ( follow )) # return with the required additional newlines return ( \" \\n \" * add_before ) + self . text + ( \" \\n \" * add_after ) __str__ ( self ) special Return a formatted str. We assume that 3 newlines are before and after. That should be enough. Source code in mkreports/md/text.py def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) count_newlines ( x , before = True ) Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. Source code in mkreports/md/text.py def count_newlines ( x : str , before = True ) -> int : \"\"\" Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. \"\"\" num_nl = 0 whitespace = [ \" \" , \" \\r \" , \" \\t \" ] y = x if before else reversed ( x ) for ch in y : if ch == \" \\n \" : num_nl += 1 elif ch in whitespace : continue else : return num_nl return num_nl","title":"text"},{"location":"Reference/mkreports/md/text/#mkreports.md.text.SpacedText","text":"Representation of text with spaces before or after. Source code in mkreports/md/text.py class SpacedText : \"\"\"Representation of text with spaces before or after.\"\"\" text : str req_nl : Tuple [ int , int ] def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) def __eq__ ( self , other : Any ) -> bool : if type ( self ) != type ( other ): return False return self . text == other . text and self . req_nl == other . req_nl def __add__ ( self , follow : Text ) -> \"SpacedText\" : return _add_text ( self , SpacedText ( follow )) def __radd__ ( self , precede : Text ) -> \"SpacedText\" : return _add_text ( SpacedText ( precede ), self ) def format_text ( self , precede : Text = \"\" , follow : Text = \"\" ) -> str : add_before = _needed_nl_between ( SpacedText ( precede ), self ) add_after = _needed_nl_between ( self , SpacedText ( follow )) # return with the required additional newlines return ( \" \\n \" * add_before ) + self . text + ( \" \\n \" * add_after )","title":"SpacedText"},{"location":"Reference/mkreports/md/text/#mkreports.md.text.SpacedText.__str__","text":"Return a formatted str. We assume that 3 newlines are before and after. That should be enough. Source code in mkreports/md/text.py def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" )","title":"__str__()"},{"location":"Reference/mkreports/md/text/#mkreports.md.text.count_newlines","text":"Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. Source code in mkreports/md/text.py def count_newlines ( x : str , before = True ) -> int : \"\"\" Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. \"\"\" num_nl = 0 whitespace = [ \" \" , \" \\r \" , \" \\t \" ] y = x if before else reversed ( x ) for ch in y : if ch == \" \\n \" : num_nl += 1 elif ch in whitespace : continue else : return num_nl return num_nl","title":"count_newlines()"}]}