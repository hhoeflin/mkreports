{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Purpose of the project Introduction For data analysts, the output of a project is typically a report of the derived results of the dataset, be it an algorithm, the summary of a regression model and the significance of variables or some other sort of requested insight. In order to simplify the writing of such reports, various tools have been invented, the most well known ones being RMarkdown in R and Jupyter that is mostly used with Python (but supports many other languages as well). These tools are incarnations of a Literate Programming , that had its beginnings with tools such as noweb and aims to mix regular text with code in an article, but of course that have been developed much further since then to extend to interactively editing and running code such as in Jupyter, processing entire books (see e.g. bookdown or also inverting the text and code-blocks such that the regular text becomes comments inside a script in e.g. R or Python (see jupytext ). Jupyter and related tools As this package is only for Python, I will focus in the following on aspects of these tools for this language, but some comments are certainly also valid for other frameworks. Jupyter is for sure the most used framework for this purpose with a very large set of tools and users. Since its invention, it has certainly changed how datascience is being done in many organizations. Some of its most noteworthy advantages are: - Deployment through the browser without the need of direct access to hardware. Due to this it is also simpler to have users work with on-demand resources - A good console with outputs of tables and figures that make rapid development easy - Tools such as turning jupyter notebooks into websites - Jupyterlab, which is (almost) a full Python IDE Next to these positive sides are however also a few shortcomings. Shortcomings of Jupyter One of the side-effects of structure of Jupyter-notebooks is their linear form where code and output blocks are mixed, which can cause notebooks to become very large and particular places can be hard to find. Code sharing between notebooks is also not easily possible, requiring to write libraries outside the notebook to fulfill this purpose, mixing very different styles of coding. Also related to their design of one notebook, one html page, parametrization of notebooks can be cumbersome and is certainly not as simple and straightforward as a function. Another drawback is the fact that notebooks hard or impossible to edit in many IDEs, requiring the use of a different environment than the one the scientist is used to. Tools like jupytext can help here, but they still rely on the special interpretation of comments to function properly and inherently still follow the linear form and one file one document view of Jupyter (and pretty much any other Literate Programming approach). Next to these, some more issues are that: - Some debuggers such as pudb are not supported well supported. - Jupytext does not solve the issue that in remote ssh development shells the viewing of graphics can be complicated. - The display options for code and complex tables are limited. This package This package was developed to give an alternative to Jupyter providing more sophisticated ways to create reports while retaining (some) of the interactivity of the browser. All this will be done in pure python without any specially formatted file or overloading of the meaning of any comments. It will further retain the ability to include live code-blocks from the scripts in the output, but less intrusively than for Jupyter notebooks. In particular, it is intended to work by providing functions to easily write out markdown pages that are part of an mkdocs site. For this convenience functions for Figures and Tables as well as other objects are available. For viewing these results, mkdocs is used that contains a development server that automatically watches input files and updates the browser on any change. This update process is typically very fast. Last, a plugin for the ipython console is provided that writes any appropriate output in the console to a special markdown page that can then also be viewed using mkdocs. This way, it is easy to visualize figues and tables from the ipython console, where tables in the browser are sortable or can even be filtered, thus providing better functionality than default Jupyter tables in an output cell.","title":"Home"},{"location":"#purpose-of-the-project","text":"","title":"Purpose of the project"},{"location":"#introduction","text":"For data analysts, the output of a project is typically a report of the derived results of the dataset, be it an algorithm, the summary of a regression model and the significance of variables or some other sort of requested insight. In order to simplify the writing of such reports, various tools have been invented, the most well known ones being RMarkdown in R and Jupyter that is mostly used with Python (but supports many other languages as well). These tools are incarnations of a Literate Programming , that had its beginnings with tools such as noweb and aims to mix regular text with code in an article, but of course that have been developed much further since then to extend to interactively editing and running code such as in Jupyter, processing entire books (see e.g. bookdown or also inverting the text and code-blocks such that the regular text becomes comments inside a script in e.g. R or Python (see jupytext ).","title":"Introduction"},{"location":"#jupyter-and-related-tools","text":"As this package is only for Python, I will focus in the following on aspects of these tools for this language, but some comments are certainly also valid for other frameworks. Jupyter is for sure the most used framework for this purpose with a very large set of tools and users. Since its invention, it has certainly changed how datascience is being done in many organizations. Some of its most noteworthy advantages are: - Deployment through the browser without the need of direct access to hardware. Due to this it is also simpler to have users work with on-demand resources - A good console with outputs of tables and figures that make rapid development easy - Tools such as turning jupyter notebooks into websites - Jupyterlab, which is (almost) a full Python IDE Next to these positive sides are however also a few shortcomings.","title":"Jupyter and related tools"},{"location":"#shortcomings-of-jupyter","text":"One of the side-effects of structure of Jupyter-notebooks is their linear form where code and output blocks are mixed, which can cause notebooks to become very large and particular places can be hard to find. Code sharing between notebooks is also not easily possible, requiring to write libraries outside the notebook to fulfill this purpose, mixing very different styles of coding. Also related to their design of one notebook, one html page, parametrization of notebooks can be cumbersome and is certainly not as simple and straightforward as a function. Another drawback is the fact that notebooks hard or impossible to edit in many IDEs, requiring the use of a different environment than the one the scientist is used to. Tools like jupytext can help here, but they still rely on the special interpretation of comments to function properly and inherently still follow the linear form and one file one document view of Jupyter (and pretty much any other Literate Programming approach). Next to these, some more issues are that: - Some debuggers such as pudb are not supported well supported. - Jupytext does not solve the issue that in remote ssh development shells the viewing of graphics can be complicated. - The display options for code and complex tables are limited.","title":"Shortcomings of Jupyter"},{"location":"#this-package","text":"This package was developed to give an alternative to Jupyter providing more sophisticated ways to create reports while retaining (some) of the interactivity of the browser. All this will be done in pure python without any specially formatted file or overloading of the meaning of any comments. It will further retain the ability to include live code-blocks from the scripts in the output, but less intrusively than for Jupyter notebooks. In particular, it is intended to work by providing functions to easily write out markdown pages that are part of an mkdocs site. For this convenience functions for Figures and Tables as well as other objects are available. For viewing these results, mkdocs is used that contains a development server that automatically watches input files and updates the browser on any change. This update process is typically very fast. Last, a plugin for the ipython console is provided that writes any appropriate output in the console to a special markdown page that can then also be viewed using mkdocs. This way, it is easy to visualize figues and tables from the ipython console, where tables in the browser are sortable or can even be filtered, thus providing better functionality than default Jupyter tables in an output cell.","title":"This package"},{"location":"basic/","text":"Basic formatting elements Headings Available headings md . H1 ( \"Header type 1\" ) md . H2 ( \"Header type 2\" ) md . H3 ( \"Header type 3\" ) md . H4 ( \"Header type 4\" ) md . H5 ( \"Header type 5\" ) md . H6 ( \"Header type 6\" ) md . H7 ( \"Header type 7\" ) Lists Content Code First item Second item Third item Some fruit: apples pears strawberry A code block: Hello world print ( \"Hello world\" ) basic.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) Links A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) Content Code A link back to the first heading A link to another page Images Or just to any page Google Or of course also just straight markdown Google basic.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 x = md . P ( \"A link back to the \" + md . Link ( anchor = heading_anchor , text = \"first heading\" ) ) x += md . P ( \"A link to another page \" + md . Link ( \"Images\" , to_page_path = report . page ( \"images.md\" ) . path ) ) x += md . P ( \"Or just to any page \" + md . Link ( \"Google\" , url = \"https://google.com\" ) ) x += md . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Basic"},{"location":"basic/#basic-formatting-elements","text":"","title":"Basic formatting elements"},{"location":"basic/#headings","text":"Available headings md . H1 ( \"Header type 1\" ) md . H2 ( \"Header type 2\" ) md . H3 ( \"Header type 3\" ) md . H4 ( \"Header type 4\" ) md . H5 ( \"Header type 5\" ) md . H6 ( \"Header type 6\" ) md . H7 ( \"Header type 7\" )","title":"Headings"},{"location":"basic/#lists","text":"Content Code First item Second item Third item Some fruit: apples pears strawberry A code block: Hello world print ( \"Hello world\" ) basic.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), )","title":"Lists"},{"location":"basic/#links","text":"A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) Content Code A link back to the first heading A link to another page Images Or just to any page Google Or of course also just straight markdown Google basic.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 x = md . P ( \"A link back to the \" + md . Link ( anchor = heading_anchor , text = \"first heading\" ) ) x += md . P ( \"A link to another page \" + md . Link ( \"Images\" , to_page_path = report . page ( \"images.md\" ) . path ) ) x += md . P ( \"Or just to any page \" + md . Link ( \"Google\" , url = \"https://google.com\" ) ) x += md . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Links"},{"location":"code_blocks/","text":"Code blocks Tracking code One of the features of mkreports is that we can include code right from the script into the output. Not only does this include the code block in the script itself, but also the source of functions that are called in the block. Here as an example, the fibonacci sequence. This is enabled by the track_code method that is part of a page object and functions as a context manager which installs a tracing function, recording the code and all called functions and their source code. A code block that has been tracked can then be included when adding a markdown object to a page by usig the add_code=True parameter. This is then combined with the markdown object by adding tabs (the markdown object active under the 'Content' tab and the code block under 'Code'). Content Code fib(3) = 2 <main> fib code_blocks.py 43 44 x = 3 a = fib ( x ) code_blocks.py 4 5 6 7 8 9 10 def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) Relative to position In addition to tracking code as shown above, we can also refer to code blocks as either - the context around the current statement - A number of statements around the current one. Warning This is not yet implemented Adding code files In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. Info from mkreports import Report , md def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" with report . page ( \"code_blocks.md\" , append = False , append_code_file = __file__ ) as p : p . H1 ( \"Code blocks\" ) with p . H2 ( \"Tracking code\" ): p . add ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. Not only does this include the code block in the script itself, but also the source of functions that are called in the block. Here as an example, the fibonacci sequence. This is enabled by the `track_code` method that is part of a page object and functions as a context manager which installs a tracing function, recording the code and all called functions and their source code. A code block that has been tracked can then be included when adding a markdown object to a page by usig the `add_code=True` parameter. This is then combined with the markdown object by adding tabs (the markdown object active under the 'Content' tab and the code block under 'Code'). \"\"\" ) with p . track_code (): x = 3 a = fib ( x ) p . add ( f \"fib( { x } ) = { a } \" , add_code = True ) with p . H2 ( \"Relative to position\" ): p . add ( \"\"\" In addition to tracking code as shown above, we can also refer to code blocks as either - the context around the current statement - A number of statements around the current one. \"\"\" ) p . Admonition ( \"This is not yet implemented\" , kind = \"warning\" ) with p . H2 ( \"Adding code files\" ): p . add ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . Admonition ( p . md . CodeFile ( __file__ ), collapse = True , kind = \"info\" ) p . add ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) And at the end will add another copy of the code-file, but automatically when ending the page context manager. docs/staging/code_blocks.py from mkreports import Report , md def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" with report . page ( \"code_blocks.md\" , append = False , append_code_file = __file__ ) as p : p . H1 ( \"Code blocks\" ) with p . H2 ( \"Tracking code\" ): p . add ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. Not only does this include the code block in the script itself, but also the source of functions that are called in the block. Here as an example, the fibonacci sequence. This is enabled by the `track_code` method that is part of a page object and functions as a context manager which installs a tracing function, recording the code and all called functions and their source code. A code block that has been tracked can then be included when adding a markdown object to a page by usig the `add_code=True` parameter. This is then combined with the markdown object by adding tabs (the markdown object active under the 'Content' tab and the code block under 'Code'). \"\"\" ) with p . track_code (): x = 3 a = fib ( x ) p . add ( f \"fib( { x } ) = { a } \" , add_code = True ) with p . H2 ( \"Relative to position\" ): p . add ( \"\"\" In addition to tracking code as shown above, we can also refer to code blocks as either - the context around the current statement - A number of statements around the current one. \"\"\" ) p . Admonition ( \"This is not yet implemented\" , kind = \"warning\" ) with p . H2 ( \"Adding code files\" ): p . add ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . Admonition ( p . md . CodeFile ( __file__ ), collapse = True , kind = \"info\" ) p . add ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" )","title":"Code Blocks"},{"location":"code_blocks/#code-blocks","text":"","title":"Code blocks"},{"location":"code_blocks/#tracking-code","text":"One of the features of mkreports is that we can include code right from the script into the output. Not only does this include the code block in the script itself, but also the source of functions that are called in the block. Here as an example, the fibonacci sequence. This is enabled by the track_code method that is part of a page object and functions as a context manager which installs a tracing function, recording the code and all called functions and their source code. A code block that has been tracked can then be included when adding a markdown object to a page by usig the add_code=True parameter. This is then combined with the markdown object by adding tabs (the markdown object active under the 'Content' tab and the code block under 'Code'). Content Code fib(3) = 2 <main> fib code_blocks.py 43 44 x = 3 a = fib ( x ) code_blocks.py 4 5 6 7 8 9 10 def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 )","title":"Tracking code"},{"location":"code_blocks/#relative-to-position","text":"In addition to tracking code as shown above, we can also refer to code blocks as either - the context around the current statement - A number of statements around the current one. Warning This is not yet implemented","title":"Relative to position"},{"location":"code_blocks/#adding-code-files","text":"In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. Info from mkreports import Report , md def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" with report . page ( \"code_blocks.md\" , append = False , append_code_file = __file__ ) as p : p . H1 ( \"Code blocks\" ) with p . H2 ( \"Tracking code\" ): p . add ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. Not only does this include the code block in the script itself, but also the source of functions that are called in the block. Here as an example, the fibonacci sequence. This is enabled by the `track_code` method that is part of a page object and functions as a context manager which installs a tracing function, recording the code and all called functions and their source code. A code block that has been tracked can then be included when adding a markdown object to a page by usig the `add_code=True` parameter. This is then combined with the markdown object by adding tabs (the markdown object active under the 'Content' tab and the code block under 'Code'). \"\"\" ) with p . track_code (): x = 3 a = fib ( x ) p . add ( f \"fib( { x } ) = { a } \" , add_code = True ) with p . H2 ( \"Relative to position\" ): p . add ( \"\"\" In addition to tracking code as shown above, we can also refer to code blocks as either - the context around the current statement - A number of statements around the current one. \"\"\" ) p . Admonition ( \"This is not yet implemented\" , kind = \"warning\" ) with p . H2 ( \"Adding code files\" ): p . add ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . Admonition ( p . md . CodeFile ( __file__ ), collapse = True , kind = \"info\" ) p . add ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) And at the end will add another copy of the code-file, but automatically when ending the page context manager. docs/staging/code_blocks.py from mkreports import Report , md def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" with report . page ( \"code_blocks.md\" , append = False , append_code_file = __file__ ) as p : p . H1 ( \"Code blocks\" ) with p . H2 ( \"Tracking code\" ): p . add ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. Not only does this include the code block in the script itself, but also the source of functions that are called in the block. Here as an example, the fibonacci sequence. This is enabled by the `track_code` method that is part of a page object and functions as a context manager which installs a tracing function, recording the code and all called functions and their source code. A code block that has been tracked can then be included when adding a markdown object to a page by usig the `add_code=True` parameter. This is then combined with the markdown object by adding tabs (the markdown object active under the 'Content' tab and the code block under 'Code'). \"\"\" ) with p . track_code (): x = 3 a = fib ( x ) p . add ( f \"fib( { x } ) = { a } \" , add_code = True ) with p . H2 ( \"Relative to position\" ): p . add ( \"\"\" In addition to tracking code as shown above, we can also refer to code blocks as either - the context around the current statement - A number of statements around the current one. \"\"\" ) p . Admonition ( \"This is not yet implemented\" , kind = \"warning\" ) with p . H2 ( \"Adding code files\" ): p . add ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . Admonition ( p . md . CodeFile ( __file__ ), collapse = True , kind = \"info\" ) p . add ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" )","title":"Adding code files"},{"location":"images/","text":"Images Supported formats Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an ImageFile object. PIL PIL is the standard python image library. Image objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. Content Code images.py 32 33 34 35 36 37 38 39 40 41 42 43 p . add ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) Matplotlib For many scientific graphing purposes, matplotlib is either the direct choice or the backend being used for plotting. Content Code images.py 49 50 51 52 53 54 55 56 57 p . add ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) Plotnine Any plots created by plotnine can be included directly. The code below is from the beginner example of the library. Content Code images.py 62 63 64 65 66 67 68 69 70 71 72 73 74 p . add ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) pn_image = p . md . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) Seaborn Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the figure attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. Content Code images.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset sea_img = p . md . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) Altair Content Code images.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) altair_chart = p . md . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) vegaEmbed(\"#altair-a7a2eb773c7d9454c694b490a77e5a7e_1\", \"../images_gen_assets/altair-a7a2eb773c7d9454c694b490a77e5a7e.csv\") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); Plotly Content Code images.py 132 133 134 import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) fetch('../images_gen_assets/plotly-2c4e085bcb294e03c4c01a147570a8c5.json') .then(function (response) { return response.json(); }) .then(function (data) { doPlotly(data); }) .catch(function (err) { console.log('error: ' + err); }); function doPlotly(plotlyJson) { Plotly.newPlot(\"plotly-2c4e085bcb294e03c4c01a147570a8c5\", { \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }) } Different image sizes Warning Still to be implemented","title":"Images"},{"location":"images/#images","text":"","title":"Images"},{"location":"images/#supported-formats","text":"Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an ImageFile object.","title":"Supported formats"},{"location":"images/#pil","text":"PIL is the standard python image library. Image objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. Content Code images.py 32 33 34 35 36 37 38 39 40 41 42 43 p . add ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np )","title":"PIL"},{"location":"images/#matplotlib","text":"For many scientific graphing purposes, matplotlib is either the direct choice or the backend being used for plotting. Content Code images.py 49 50 51 52 53 54 55 56 57 p . add ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ])","title":"Matplotlib"},{"location":"images/#plotnine","text":"Any plots created by plotnine can be included directly. The code below is from the beginner example of the library. Content Code images.py 62 63 64 65 66 67 68 69 70 71 72 73 74 p . add ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) pn_image = p . md . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), )","title":"Plotnine"},{"location":"images/#seaborn","text":"Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the figure attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. Content Code images.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset sea_img = p . md . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), )","title":"Seaborn"},{"location":"images/#altair","text":"Content Code images.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) altair_chart = p . md . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) vegaEmbed(\"#altair-a7a2eb773c7d9454c694b490a77e5a7e_1\", \"../images_gen_assets/altair-a7a2eb773c7d9454c694b490a77e5a7e.csv\") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn);","title":"Altair"},{"location":"images/#plotly","text":"Content Code images.py 132 133 134 import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) fetch('../images_gen_assets/plotly-2c4e085bcb294e03c4c01a147570a8c5.json') .then(function (response) { return response.json(); }) .then(function (data) { doPlotly(data); }) .catch(function (err) { console.log('error: ' + err); }); function doPlotly(plotlyJson) { Plotly.newPlot(\"plotly-2c4e085bcb294e03c4c01a147570a8c5\", { \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }) }","title":"Plotly"},{"location":"images/#different-image-sizes","text":"Warning Still to be implemented","title":"Different image sizes"},{"location":"markdown/","text":"Adding markdown elements to a page Opening pages The first step is to define a report directory and open a page in it. There is always at least the 'index.md' page included in any report, which is listed in the navigation under Home . from mkreports import Report report = Report () page = report . page ( 'index.md' ) Adding markdown There are overall 3 ways to use and add markdown elements to a page. Each of these provides a different level of convenient. As a summary for the user: - If you want to add an element immediately to a page, use the markdown classes directly available as attributes in the page itself. These preset certain parameters and add the markdown object directly to the page after it is instantiated. - If you need to build up more complicated markdown objects before adding it to a page (e.g. in the case of nested objects), use the Page.md attribute to get the markdown object that pre-populates certain parameters to sensible defaults - In some special circumstances it may be necessary to get the raw markdown with full control. In this case the mkreports.md module can be used. In more detail below the three options, in reverse order from most basic to most convenient. md module The mkreports.md module provides all markdown functionality that can be used in the package. In the rest of this documentation, various of these are being explained. As the most basic there is however certain information that can get cumbersome to input. One example is the store_path . Certain markdown elements, such as tables, store the information to be displayed in a file in subdirectory of the reports directory. As the page on which the markdown element is added is not specified at this point (and neither is the report), this store_path needs to be explicitly passed into the element. For most use-cases, this basic level does not need to be used by the end-user. This markdown object then has to be added to a page using the add method. md-attribute of a page Each Page instance also md attribute. This attribute is a proxy-object to the md -submodule. When requesting an object, the store_path and certain required ids (e.g. for Altair or DataTable objects) will be pre-populated by the page instance so that the user doesn't have to worry about it. The resulting markdown object then has to be added to the page again using the add method. Markdown attributes of a page This is very similar to the Page.md attribute, except that the markdown classes are directly available as attributes on the Page class. After instantiating the markdown element, it immediately gets added to the page automatically. Keyword parameters that are available on Page.add can also be specified and will be passed along appropriately.","title":"Markdown"},{"location":"markdown/#adding-markdown-elements-to-a-page","text":"","title":"Adding markdown elements to a page"},{"location":"markdown/#opening-pages","text":"The first step is to define a report directory and open a page in it. There is always at least the 'index.md' page included in any report, which is listed in the navigation under Home . from mkreports import Report report = Report () page = report . page ( 'index.md' )","title":"Opening pages"},{"location":"markdown/#adding-markdown","text":"There are overall 3 ways to use and add markdown elements to a page. Each of these provides a different level of convenient. As a summary for the user: - If you want to add an element immediately to a page, use the markdown classes directly available as attributes in the page itself. These preset certain parameters and add the markdown object directly to the page after it is instantiated. - If you need to build up more complicated markdown objects before adding it to a page (e.g. in the case of nested objects), use the Page.md attribute to get the markdown object that pre-populates certain parameters to sensible defaults - In some special circumstances it may be necessary to get the raw markdown with full control. In this case the mkreports.md module can be used. In more detail below the three options, in reverse order from most basic to most convenient.","title":"Adding markdown"},{"location":"markdown/#md-module","text":"The mkreports.md module provides all markdown functionality that can be used in the package. In the rest of this documentation, various of these are being explained. As the most basic there is however certain information that can get cumbersome to input. One example is the store_path . Certain markdown elements, such as tables, store the information to be displayed in a file in subdirectory of the reports directory. As the page on which the markdown element is added is not specified at this point (and neither is the report), this store_path needs to be explicitly passed into the element. For most use-cases, this basic level does not need to be used by the end-user. This markdown object then has to be added to a page using the add method.","title":"md module"},{"location":"markdown/#md-attribute-of-a-page","text":"Each Page instance also md attribute. This attribute is a proxy-object to the md -submodule. When requesting an object, the store_path and certain required ids (e.g. for Altair or DataTable objects) will be pre-populated by the page instance so that the user doesn't have to worry about it. The resulting markdown object then has to be added to the page again using the add method.","title":"md-attribute of a page"},{"location":"markdown/#markdown-attributes-of-a-page","text":"This is very similar to the Page.md attribute, except that the markdown classes are directly available as attributes on the Page class. After instantiating the markdown element, it immediately gets added to the page automatically. Keyword parameters that are available on Page.add can also be specified and will be passed along appropriately.","title":"Markdown attributes of a page"},{"location":"tables/","text":"Different ways of handling tables Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. Markdown tables Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. name mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 DataTable javascript library Here the same table, but displayed using the DataTables plugin. With this, we get automatic paging, searching as well as sorting by columns. $(document).ready( function () { $('#datatable-ca9b6f052f673e1d46f468ebb1ccc5d1_1').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"name\"}, {\"title\": \"mpg\"}, {\"title\": \"cyl\"}, {\"title\": \"disp\"}, {\"title\": \"hp\"}, {\"title\": \"drat\"}, {\"title\": \"wt\"}, {\"title\": \"qsec\"}, {\"title\": \"vs\"}, {\"title\": \"am\"}, {\"title\": \"gear\"}, {\"title\": \"carb\"}], \"ajax\": \"../tables_gen_assets/datatable-ca9b6f052f673e1d46f468ebb1ccc5d1.json\"}); } ); Tabulator javascript library This time, we use the Tabulator library. A library with a lot of interesting functionality. Currently limited support. var table = new Tabulator('#tabulator-c8469972d60cd61d98262704e068f4e9', {\"autoColumns\": true, \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"ajaxURL\": \"../tables_gen_assets/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Tables"},{"location":"tables/#different-ways-of-handling-tables","text":"Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed.","title":"Different ways of handling tables"},{"location":"tables/#markdown-tables","text":"Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. name mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4","title":"Markdown tables"},{"location":"tables/#datatable-javascript-library","text":"Here the same table, but displayed using the DataTables plugin. With this, we get automatic paging, searching as well as sorting by columns. $(document).ready( function () { $('#datatable-ca9b6f052f673e1d46f468ebb1ccc5d1_1').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"name\"}, {\"title\": \"mpg\"}, {\"title\": \"cyl\"}, {\"title\": \"disp\"}, {\"title\": \"hp\"}, {\"title\": \"drat\"}, {\"title\": \"wt\"}, {\"title\": \"qsec\"}, {\"title\": \"vs\"}, {\"title\": \"am\"}, {\"title\": \"gear\"}, {\"title\": \"carb\"}], \"ajax\": \"../tables_gen_assets/datatable-ca9b6f052f673e1d46f468ebb1ccc5d1.json\"}); } );","title":"DataTable javascript library"},{"location":"tables/#tabulator-javascript-library","text":"This time, we use the Tabulator library. A library with a lot of interesting functionality. Currently limited support. var table = new Tabulator('#tabulator-c8469972d60cd61d98262704e068f4e9', {\"autoColumns\": true, \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"ajaxURL\": \"../tables_gen_assets/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Tabulator javascript library"},{"location":"Reference/mkreports/counters/","text":"Counters Source code in mkreports/counters.py class Counters : _counts : Dict [ str , int ] def __init__ ( self , start_with : int = 0 ) -> None : self . _counts = {} self . _start_with = start_with def count ( self , name : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" if name in self . _counts : self . _counts [ name ] += 1 else : self . _counts [ name ] = self . _start_with return self . _counts [ name ] def counted_id ( self , prefix : str , omit_1 : bool = False ) -> str : \"\"\" Returns an id with a counted number at the end. \"\"\" prefix_count = self . count ( prefix ) if omit_1 and prefix_count == 1 : return prefix else : return f \" { prefix } _ { self . count ( prefix ) } \" count ( self , name ) Returns the next value of the counter (and increments). Source code in mkreports/counters.py def count ( self , name : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" if name in self . _counts : self . _counts [ name ] += 1 else : self . _counts [ name ] = self . _start_with return self . _counts [ name ] counted_id ( self , prefix , omit_1 = False ) Returns an id with a counted number at the end. Source code in mkreports/counters.py def counted_id ( self , prefix : str , omit_1 : bool = False ) -> str : \"\"\" Returns an id with a counted number at the end. \"\"\" prefix_count = self . count ( prefix ) if omit_1 and prefix_count == 1 : return prefix else : return f \" { prefix } _ { self . count ( prefix ) } \"","title":"counters"},{"location":"Reference/mkreports/counters/#mkreports.counters.Counters","text":"Source code in mkreports/counters.py class Counters : _counts : Dict [ str , int ] def __init__ ( self , start_with : int = 0 ) -> None : self . _counts = {} self . _start_with = start_with def count ( self , name : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" if name in self . _counts : self . _counts [ name ] += 1 else : self . _counts [ name ] = self . _start_with return self . _counts [ name ] def counted_id ( self , prefix : str , omit_1 : bool = False ) -> str : \"\"\" Returns an id with a counted number at the end. \"\"\" prefix_count = self . count ( prefix ) if omit_1 and prefix_count == 1 : return prefix else : return f \" { prefix } _ { self . count ( prefix ) } \"","title":"Counters"},{"location":"Reference/mkreports/counters/#mkreports.counters.Counters.count","text":"Returns the next value of the counter (and increments). Source code in mkreports/counters.py def count ( self , name : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" if name in self . _counts : self . _counts [ name ] += 1 else : self . _counts [ name ] = self . _start_with return self . _counts [ name ]","title":"count()"},{"location":"Reference/mkreports/counters/#mkreports.counters.Counters.counted_id","text":"Returns an id with a counted number at the end. Source code in mkreports/counters.py def counted_id ( self , prefix : str , omit_1 : bool = False ) -> str : \"\"\" Returns an id with a counted number at the end. \"\"\" prefix_count = self . count ( prefix ) if omit_1 and prefix_count == 1 : return prefix else : return f \" { prefix } _ { self . count ( prefix ) } \"","title":"counted_id()"},{"location":"Reference/mkreports/docs/","text":"add_pkg_docs ( pkg_path , parent_name , report ) Add docstrings of the object to the report Source code in mkreports/docs.py def add_pkg_docs ( pkg_path : Path , parent_name : Union [ NavEntry , Path , str ], report : Report , ): \"\"\" Add docstrings of the object to the report \"\"\" # we need the parent name as a nav_entry if isinstance ( parent_name , str ): parent_name = Path ( parent_name ) if isinstance ( parent_name , Path ): parent_name = path_to_nav_entry ( parent_name ) # now iterate through all python entries for path in sorted ( pkg_path . glob ( \"**/*.py\" )): module_path = path . relative_to ( pkg_path . parent ) . with_suffix ( \"\" ) if module_path . name == \"__init__\" : continue else : # now create the new nav_entry for this page module_nav_entry = ( parent_name [ 0 ] + list ( module_path . parts ), ( parent_name [ 1 ] / module_path ) . with_suffix ( \".md\" ), ) # now create a new page and add the doc-entry page = report . page ( module_nav_entry , append = False ) page . add ( page . md . Docstring ( \".\" . join ( module_path . parts )))","title":"docs"},{"location":"Reference/mkreports/docs/#mkreports.docs.add_pkg_docs","text":"Add docstrings of the object to the report Source code in mkreports/docs.py def add_pkg_docs ( pkg_path : Path , parent_name : Union [ NavEntry , Path , str ], report : Report , ): \"\"\" Add docstrings of the object to the report \"\"\" # we need the parent name as a nav_entry if isinstance ( parent_name , str ): parent_name = Path ( parent_name ) if isinstance ( parent_name , Path ): parent_name = path_to_nav_entry ( parent_name ) # now iterate through all python entries for path in sorted ( pkg_path . glob ( \"**/*.py\" )): module_path = path . relative_to ( pkg_path . parent ) . with_suffix ( \"\" ) if module_path . name == \"__init__\" : continue else : # now create the new nav_entry for this page module_nav_entry = ( parent_name [ 0 ] + list ( module_path . parts ), ( parent_name [ 1 ] / module_path ) . with_suffix ( \".md\" ), ) # now create a new page and add the doc-entry page = report . page ( module_nav_entry , append = False ) page . add ( page . md . Docstring ( \".\" . join ( module_path . parts )))","title":"add_pkg_docs()"},{"location":"Reference/mkreports/exceptions/","text":"All Exception classes that we are using in the package.","title":"exceptions"},{"location":"Reference/mkreports/ipython/","text":"ConsoleWriter ( Magics ) Source code in mkreports/ipython.py @magics_class class ConsoleWriter ( Magics ): handlers : List [ Handler ] console : Page def __init__ ( self , ip ): super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] self . _set_default_handlers () # identify an mkreport if \"MKREPORTS_DIR\" in os . environ : self . report = Report ( os . environ [ \"MKREPORTS_DIR\" ], site_name = \"Mkreports console\" , create = True ) self . open_console () else : raise Exception ( \"No 'MKREPORTS_DIR' in environment\" ) def _set_default_handlers ( self ): self . handlers = [] # handler for tables try : import pandas as pd self . handlers . append ( Handler ( name = \"datatable\" , class_type = pd . DataFrame , func = lambda x : self . console . md . DataTable ( x ), add_code = True , ) ) except Exception : pass # handler for matplotlib try : from matplotlib.figure import Figure as MplFigure self . handlers . append ( Handler ( name = \"matplotlib\" , class_type = MplFigure , func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass try : from plotnine.ggplot import ggplot self . handlers . append ( Handler ( name = \"plotnine\" , class_type = ggplot , func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass try : from seaborn import FacetGrid as SnsFacetGrid from seaborn import JointGrid as SnsJointGrid from seaborn import PairGrid as SnsPairGrid self . handlers . append ( Handler ( name = \"seaborn\" , class_type = ( SnsFacetGrid , SnsJointGrid , SnsPairGrid ), func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass self . handlers . append ( Handler ( name = \"mdobj\" , class_type = md . MdObj , func = lambda x : x , add_code = False ) ) def get_handler ( self , obj : Any ) -> Optional [ Handler ]: for handler in self . handlers : if isinstance ( obj , handler . class_type ): return handler else : return None def open_console ( self ) -> None : self . console = self . report . page ( Path ( \"console/active.md\" ), init_counter_time = True ) # make sure the table of contents does not get shown self . console . add ( md . Raw ( page_settings = { \"hide\" : [ \"toc\" ]}, ) ) @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. \"\"\" # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } .md\" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . open_console () def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . get_handler ( result . result ) if handler is not None : md_obj = handler . func ( result . result ) if handler . add_code : # we now want to attach this together with the stored code content = md . Tab ( md_obj , title = \"Content\" ) code = md . Tab ( md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ), title = \"Code\" , ) md_obj = content + code # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + md_obj + md . Raw ( md . SpacedText ( \"---\" , ( 2 , 2 ))) ) self . console . add ( post , add_code = False , bottom = False ) self . stored_code = [] archive_console ( self , line ) Function to archive the console. This is also a line magic, however the line itself will be ignored. Source code in mkreports/ipython.py @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. \"\"\" # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } .md\" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . open_console () post_run_cell ( self , result ) Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. Source code in mkreports/ipython.py def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . get_handler ( result . result ) if handler is not None : md_obj = handler . func ( result . result ) if handler . add_code : # we now want to attach this together with the stored code content = md . Tab ( md_obj , title = \"Content\" ) code = md . Tab ( md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ), title = \"Code\" , ) md_obj = content + code # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + md_obj + md . Raw ( md . SpacedText ( \"---\" , ( 2 , 2 ))) ) self . console . add ( post , add_code = False , bottom = False ) self . stored_code = [] Handler dataclass Handler(name: str, class_type: Union[type, Tuple[type, ...]], func: Callable, add_code: bool) Source code in mkreports/ipython.py @dataclass class Handler : name : str class_type : Union [ type , Tuple [ type , ... ]] func : Callable add_code : bool load_ipython_extension ( ip ) Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. Source code in mkreports/ipython.py def load_ipython_extension ( ip ): \"\"\" Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. \"\"\" cw = ConsoleWriter ( ip ) cw . shell . push ({ \"md\" : cw . console . md , \"cons\" : cw . console }) ip . events . register ( \"post_run_cell\" , cw . post_run_cell ) ip . register_magics ( cw )","title":"ipython"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.ConsoleWriter","text":"Source code in mkreports/ipython.py @magics_class class ConsoleWriter ( Magics ): handlers : List [ Handler ] console : Page def __init__ ( self , ip ): super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] self . _set_default_handlers () # identify an mkreport if \"MKREPORTS_DIR\" in os . environ : self . report = Report ( os . environ [ \"MKREPORTS_DIR\" ], site_name = \"Mkreports console\" , create = True ) self . open_console () else : raise Exception ( \"No 'MKREPORTS_DIR' in environment\" ) def _set_default_handlers ( self ): self . handlers = [] # handler for tables try : import pandas as pd self . handlers . append ( Handler ( name = \"datatable\" , class_type = pd . DataFrame , func = lambda x : self . console . md . DataTable ( x ), add_code = True , ) ) except Exception : pass # handler for matplotlib try : from matplotlib.figure import Figure as MplFigure self . handlers . append ( Handler ( name = \"matplotlib\" , class_type = MplFigure , func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass try : from plotnine.ggplot import ggplot self . handlers . append ( Handler ( name = \"plotnine\" , class_type = ggplot , func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass try : from seaborn import FacetGrid as SnsFacetGrid from seaborn import JointGrid as SnsJointGrid from seaborn import PairGrid as SnsPairGrid self . handlers . append ( Handler ( name = \"seaborn\" , class_type = ( SnsFacetGrid , SnsJointGrid , SnsPairGrid ), func = lambda x : self . console . md . Image ( x ), add_code = True , ) ) except Exception : pass self . handlers . append ( Handler ( name = \"mdobj\" , class_type = md . MdObj , func = lambda x : x , add_code = False ) ) def get_handler ( self , obj : Any ) -> Optional [ Handler ]: for handler in self . handlers : if isinstance ( obj , handler . class_type ): return handler else : return None def open_console ( self ) -> None : self . console = self . report . page ( Path ( \"console/active.md\" ), init_counter_time = True ) # make sure the table of contents does not get shown self . console . add ( md . Raw ( page_settings = { \"hide\" : [ \"toc\" ]}, ) ) @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. \"\"\" # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } .md\" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . open_console () def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . get_handler ( result . result ) if handler is not None : md_obj = handler . func ( result . result ) if handler . add_code : # we now want to attach this together with the stored code content = md . Tab ( md_obj , title = \"Content\" ) code = md . Tab ( md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ), title = \"Code\" , ) md_obj = content + code # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + md_obj + md . Raw ( md . SpacedText ( \"---\" , ( 2 , 2 ))) ) self . console . add ( post , add_code = False , bottom = False ) self . stored_code = []","title":"ConsoleWriter"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.ConsoleWriter.archive_console","text":"Function to archive the console. This is also a line magic, however the line itself will be ignored. Source code in mkreports/ipython.py @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. \"\"\" # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } .md\" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . open_console ()","title":"archive_console()"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.ConsoleWriter.post_run_cell","text":"Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. Source code in mkreports/ipython.py def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . get_handler ( result . result ) if handler is not None : md_obj = handler . func ( result . result ) if handler . add_code : # we now want to attach this together with the stored code content = md . Tab ( md_obj , title = \"Content\" ) code = md . Tab ( md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ), title = \"Code\" , ) md_obj = content + code # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + md_obj + md . Raw ( md . SpacedText ( \"---\" , ( 2 , 2 ))) ) self . console . add ( post , add_code = False , bottom = False ) self . stored_code = []","title":"post_run_cell()"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.Handler","text":"Handler(name: str, class_type: Union[type, Tuple[type, ...]], func: Callable, add_code: bool) Source code in mkreports/ipython.py @dataclass class Handler : name : str class_type : Union [ type , Tuple [ type , ... ]] func : Callable add_code : bool","title":"Handler"},{"location":"Reference/mkreports/ipython/#mkreports.ipython.load_ipython_extension","text":"Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. Source code in mkreports/ipython.py def load_ipython_extension ( ip ): \"\"\" Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. \"\"\" cw = ConsoleWriter ( ip ) cw . shell . push ({ \"md\" : cw . console . md , \"cons\" : cw . console }) ip . events . register ( \"post_run_cell\" , cw . post_run_cell ) ip . register_magics ( cw )","title":"load_ipython_extension()"},{"location":"Reference/mkreports/md_proxy/","text":"","title":"md_proxy"},{"location":"Reference/mkreports/parser/","text":"A simple class to provide access to full extent of statements with starting and ending lines. closest_after ( tree , lineno ) Return the closest item strictly before lineno. Source code in mkreports/parser.py def closest_after ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line # rest by difference to current line after_list = [ x for x in tree_list if ( x . begin > lineno )] after_list . sort ( key = lambda x : x . begin - lineno ) if len ( after_list ) > 0 : return after_list [ 0 ] else : return None closest_before ( tree , lineno ) Return the closest item strictly before lineno. Source code in mkreports/parser.py def closest_before ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line before_list = [ x for x in tree_list if ( x . begin < lineno )] before_list . sort ( key = lambda x : lineno - x . begin ) if len ( before_list ) > 0 : return before_list [ 0 ] else : return None get_neighbors ( tree , lineno ) For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Source code in mkreports/parser.py def get_neighbors ( tree : IntervalTree , lineno : int ) -> Tuple [ Optional [ Interval ], Optional [ Interval ], Optional [ Interval ]]: \"\"\" For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. \"\"\" return ( closest_before ( tree , lineno ), smallest_overlap ( tree , lineno ), closest_after ( tree , lineno ), ) get_stmt_ranges ( pyfile ) Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Source code in mkreports/parser.py def get_stmt_ranges ( pyfile : Path ) -> IntervalTree : \"\"\" Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. \"\"\" # first we parse the python file into an AST with pyfile . open ( \"r\" ) as f : file_ast = ast . parse ( f . read ()) inttree = IntervalTree () # now we want to walk along the tree and get the line extent of # all nodes that are statements; as data payload we attach # the parsed nodes for node in ast . walk ( file_ast ): if isinstance ( node , ast . stmt ): if node . lineno is not None and node . end_lineno is not None : inttree . add ( Interval ( begin = node . lineno , end = node . end_lineno + 1 , data = node ) ) return inttree smallest_overlap ( tree , lineno ) Find the closest match that overlaps and is shortests. Source code in mkreports/parser.py def smallest_overlap ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Find the closest match that overlaps and is shortests. \"\"\" overlap_set = tree . at ( lineno ) if len ( overlap_set ) > 0 : # we take the shortest overlap_list = list ( overlap_set ) overlap_list . sort ( key = lambda x : x . end - x . begin ) return overlap_list [ 0 ] else : return None","title":"parser"},{"location":"Reference/mkreports/parser/#mkreports.parser.closest_after","text":"Return the closest item strictly before lineno. Source code in mkreports/parser.py def closest_after ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line # rest by difference to current line after_list = [ x for x in tree_list if ( x . begin > lineno )] after_list . sort ( key = lambda x : x . begin - lineno ) if len ( after_list ) > 0 : return after_list [ 0 ] else : return None","title":"closest_after()"},{"location":"Reference/mkreports/parser/#mkreports.parser.closest_before","text":"Return the closest item strictly before lineno. Source code in mkreports/parser.py def closest_before ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line before_list = [ x for x in tree_list if ( x . begin < lineno )] before_list . sort ( key = lambda x : lineno - x . begin ) if len ( before_list ) > 0 : return before_list [ 0 ] else : return None","title":"closest_before()"},{"location":"Reference/mkreports/parser/#mkreports.parser.get_neighbors","text":"For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Source code in mkreports/parser.py def get_neighbors ( tree : IntervalTree , lineno : int ) -> Tuple [ Optional [ Interval ], Optional [ Interval ], Optional [ Interval ]]: \"\"\" For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. \"\"\" return ( closest_before ( tree , lineno ), smallest_overlap ( tree , lineno ), closest_after ( tree , lineno ), )","title":"get_neighbors()"},{"location":"Reference/mkreports/parser/#mkreports.parser.get_stmt_ranges","text":"Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Source code in mkreports/parser.py def get_stmt_ranges ( pyfile : Path ) -> IntervalTree : \"\"\" Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. \"\"\" # first we parse the python file into an AST with pyfile . open ( \"r\" ) as f : file_ast = ast . parse ( f . read ()) inttree = IntervalTree () # now we want to walk along the tree and get the line extent of # all nodes that are statements; as data payload we attach # the parsed nodes for node in ast . walk ( file_ast ): if isinstance ( node , ast . stmt ): if node . lineno is not None and node . end_lineno is not None : inttree . add ( Interval ( begin = node . lineno , end = node . end_lineno + 1 , data = node ) ) return inttree","title":"get_stmt_ranges()"},{"location":"Reference/mkreports/parser/#mkreports.parser.smallest_overlap","text":"Find the closest match that overlaps and is shortests. Source code in mkreports/parser.py def smallest_overlap ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Find the closest match that overlaps and is shortests. \"\"\" overlap_set = tree . at ( lineno ) if len ( overlap_set ) > 0 : # we take the shortest overlap_list = list ( overlap_set ) overlap_list . sort ( key = lambda x : x . end - x . begin ) return overlap_list [ 0 ] else : return None","title":"smallest_overlap()"},{"location":"Reference/mkreports/report/","text":"Base class for the whole report. This corresponds to a mkdocs project. The class is mainly responsible for creating a mkdocs project if it doesn't exist already and ensuring that the neccessary settings are all included. Page Source code in mkreports/report.py class Page : def __init__ ( self , path : Path , report : Report , page_settings : Optional [ Dict [ str , Any ]] = None , mkdocs_settings : Optional [ Dict [ str , Any ]] = None , init_counter_time : bool = False , append_code_file : Optional [ Union [ Path , str ]] = None , ) -> None : self . _path = path . absolute () if init_counter_time : # use time in ms self . _counters = Counters ( start_with = int ( time . time () * 1000 )) else : self . _counters = Counters () self . report = report # check if the page already exists if not self . _path . exists (): # we create the file with the settings self . add ( Raw ( page_settings = page_settings , mkdocs_settings = mkdocs_settings )) self . _md = MdProxy ( store_path = self . gen_asset_path , report_path = self . report . path , datatable_id = lambda hash : self . _counters . counted_id ( f \"datatable- { hash } \" ), altair_id = lambda hash : self . _counters . counted_id ( f \"altair- { hash } \" ), ) self . append_code_file = append_code_file # a tracker for tracking code to be printed self . reset_tracker () def __enter__ ( self ) -> \"Page\" : return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : if self . append_code_file : try : self . add ( self . md . Admonition ( self . md . CodeFile ( self . append_code_file ), collapse = True , kind = \"info\" , title = relative_repo_root ( self . append_code_file ), ) ) except Exception : pass def __getattr__ ( self , name ): md_class = self . md . __getattr__ ( name ) def md_and_add ( * args , ** kwargs ): kwargs_add = { name : value for name , value in kwargs . items () if name in [ \"add_code\" , \"bottom\" ] } kwargs_md = { name : value for name , value in kwargs . items () if name not in [ \"add_code\" , \"bottom\" ] } # now apply to md md_obj = md_class ( * args , ** kwargs_md ) return self . add ( md_obj , ** kwargs_add ) return md_and_add @property def path ( self ) -> Path : return self . _path @property def gen_asset_path ( self ) -> Path : return self . path . parent / ( self . _path . stem + \"_gen_assets\" ) def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . gen_asset_path ) self . path . unlink () def reset_tracker ( self ) -> None : # note: tracker is designed to be passed outside self . tracker = Tracker ( omit_levels = 0 ) def track_code ( self ): self . reset_tracker () return self . tracker def track_code_start ( self ): self . tracker . __enter__ () def track_code_end ( self ): self . tracker . __exit__ ( None , None , None ) def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\"Print code as markdown that has been tracked.\"\"\" if self . tracker . ctx_active : raise TrackerIncompleteError ( \"The tracker has not finished.\" ) if self . tracker . tree is None : raise TrackerEmptyError ( \"The tracker has not been started.\" ) return self . tracker . tree . md_tree ( highlight = highlight , full_filename = full_filename ) def add ( self , item : Union [ MdObj , Text ], add_code : bool = False , bottom : bool = True ) -> ContextManager [ \"Page\" ]: # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) if add_code : # we wrap it all in a tabs, with one tab the main output, the other # the code; item = Tab ( item , title = \"Content\" ) + Tab ( self . md_code ( highlight = False ), title = \"Code\" ) # reset the tracker self . reset_tracker () # call the markdown and the backmatter md_text = item . to_md_with_bm ( page_path = self . path ) req = item . req_settings () if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in mkdocs\" ) mkdocs_settings = load_yaml ( self . report . mkdocs_file ) mkdocs_settings = merge_settings ( mkdocs_settings , req . mkdocs ) save_yaml ( mkdocs_settings , self . report . mkdocs_file ) if bottom : self . _add_to_page ( top = None , bottom = md_text , page_settings = req . page ) else : self . _add_to_page ( top = md_text , bottom = None , page_settings = req . page ) return contextlib . nullcontext ( self ) def _add_to_page ( self , top : Optional [ SpacedText ], bottom : Optional [ SpacedText ], page_settings : Dict [ str , Any ], ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , page_settings ) if top is not None : content = top . format_text ( \"\" , content ) + content if bottom is not None : content = content + bottom . format_text ( content , \"\" ) write_page ( self . path , metadata , content ) @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule that specifies 'store_path' where possible. \"\"\" return self . _md md : MdProxy property readonly A proxy for the 'md' submodule that specifies 'store_path' where possible. clear ( self ) Clear the page markdown file and the generated assets directory. Source code in mkreports/report.py def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . gen_asset_path ) self . path . unlink () md_code ( self , highlight = True , full_filename = False ) Print code as markdown that has been tracked. Source code in mkreports/report.py def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\"Print code as markdown that has been tracked.\"\"\" if self . tracker . ctx_active : raise TrackerIncompleteError ( \"The tracker has not finished.\" ) if self . tracker . tree is None : raise TrackerEmptyError ( \"The tracker has not been started.\" ) return self . tracker . tree . md_tree ( highlight = highlight , full_filename = full_filename )","title":"report"},{"location":"Reference/mkreports/report/#mkreports.report.Page","text":"Source code in mkreports/report.py class Page : def __init__ ( self , path : Path , report : Report , page_settings : Optional [ Dict [ str , Any ]] = None , mkdocs_settings : Optional [ Dict [ str , Any ]] = None , init_counter_time : bool = False , append_code_file : Optional [ Union [ Path , str ]] = None , ) -> None : self . _path = path . absolute () if init_counter_time : # use time in ms self . _counters = Counters ( start_with = int ( time . time () * 1000 )) else : self . _counters = Counters () self . report = report # check if the page already exists if not self . _path . exists (): # we create the file with the settings self . add ( Raw ( page_settings = page_settings , mkdocs_settings = mkdocs_settings )) self . _md = MdProxy ( store_path = self . gen_asset_path , report_path = self . report . path , datatable_id = lambda hash : self . _counters . counted_id ( f \"datatable- { hash } \" ), altair_id = lambda hash : self . _counters . counted_id ( f \"altair- { hash } \" ), ) self . append_code_file = append_code_file # a tracker for tracking code to be printed self . reset_tracker () def __enter__ ( self ) -> \"Page\" : return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : if self . append_code_file : try : self . add ( self . md . Admonition ( self . md . CodeFile ( self . append_code_file ), collapse = True , kind = \"info\" , title = relative_repo_root ( self . append_code_file ), ) ) except Exception : pass def __getattr__ ( self , name ): md_class = self . md . __getattr__ ( name ) def md_and_add ( * args , ** kwargs ): kwargs_add = { name : value for name , value in kwargs . items () if name in [ \"add_code\" , \"bottom\" ] } kwargs_md = { name : value for name , value in kwargs . items () if name not in [ \"add_code\" , \"bottom\" ] } # now apply to md md_obj = md_class ( * args , ** kwargs_md ) return self . add ( md_obj , ** kwargs_add ) return md_and_add @property def path ( self ) -> Path : return self . _path @property def gen_asset_path ( self ) -> Path : return self . path . parent / ( self . _path . stem + \"_gen_assets\" ) def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . gen_asset_path ) self . path . unlink () def reset_tracker ( self ) -> None : # note: tracker is designed to be passed outside self . tracker = Tracker ( omit_levels = 0 ) def track_code ( self ): self . reset_tracker () return self . tracker def track_code_start ( self ): self . tracker . __enter__ () def track_code_end ( self ): self . tracker . __exit__ ( None , None , None ) def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\"Print code as markdown that has been tracked.\"\"\" if self . tracker . ctx_active : raise TrackerIncompleteError ( \"The tracker has not finished.\" ) if self . tracker . tree is None : raise TrackerEmptyError ( \"The tracker has not been started.\" ) return self . tracker . tree . md_tree ( highlight = highlight , full_filename = full_filename ) def add ( self , item : Union [ MdObj , Text ], add_code : bool = False , bottom : bool = True ) -> ContextManager [ \"Page\" ]: # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) if add_code : # we wrap it all in a tabs, with one tab the main output, the other # the code; item = Tab ( item , title = \"Content\" ) + Tab ( self . md_code ( highlight = False ), title = \"Code\" ) # reset the tracker self . reset_tracker () # call the markdown and the backmatter md_text = item . to_md_with_bm ( page_path = self . path ) req = item . req_settings () if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in mkdocs\" ) mkdocs_settings = load_yaml ( self . report . mkdocs_file ) mkdocs_settings = merge_settings ( mkdocs_settings , req . mkdocs ) save_yaml ( mkdocs_settings , self . report . mkdocs_file ) if bottom : self . _add_to_page ( top = None , bottom = md_text , page_settings = req . page ) else : self . _add_to_page ( top = md_text , bottom = None , page_settings = req . page ) return contextlib . nullcontext ( self ) def _add_to_page ( self , top : Optional [ SpacedText ], bottom : Optional [ SpacedText ], page_settings : Dict [ str , Any ], ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , page_settings ) if top is not None : content = top . format_text ( \"\" , content ) + content if bottom is not None : content = content + bottom . format_text ( content , \"\" ) write_page ( self . path , metadata , content ) @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule that specifies 'store_path' where possible. \"\"\" return self . _md","title":"Page"},{"location":"Reference/mkreports/report/#mkreports.report.Page.md","text":"A proxy for the 'md' submodule that specifies 'store_path' where possible.","title":"md"},{"location":"Reference/mkreports/report/#mkreports.report.Page.clear","text":"Clear the page markdown file and the generated assets directory. Source code in mkreports/report.py def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . gen_asset_path ) self . path . unlink ()","title":"clear()"},{"location":"Reference/mkreports/report/#mkreports.report.Page.md_code","text":"Print code as markdown that has been tracked. Source code in mkreports/report.py def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\"Print code as markdown that has been tracked.\"\"\" if self . tracker . ctx_active : raise TrackerIncompleteError ( \"The tracker has not finished.\" ) if self . tracker . tree is None : raise TrackerEmptyError ( \"The tracker has not been started.\" ) return self . tracker . tree . md_tree ( highlight = highlight , full_filename = full_filename )","title":"md_code()"},{"location":"Reference/mkreports/settings/","text":"Settings dataclass Settings(mkdocs: Dict[str, Any] = , page: Dict[str, Any] = ) Source code in mkreports/settings.py @dataclass class Settings : mkdocs : Dict [ str , Any ] = field ( default_factory = dict ) page : Dict [ str , Any ] = field ( default_factory = dict ) def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), ) __add__ ( self , other ) special Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. Source code in mkreports/settings.py def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), ) mkdocs_to_nav ( mkdocs_nav ) Convert an mkdovs nav to a list of NavEntry. Source code in mkreports/settings.py def mkdocs_to_nav ( mkdocs_nav : MkdocsNav ) -> Nav : \"\"\" Convert an mkdovs nav to a list of NavEntry. \"\"\" res = [] for entry in mkdocs_nav : if isinstance ( entry , str ): res . append (([], Path ( entry ))) elif isinstance ( entry , Mapping ): key , val = check_length_one ( entry ) if isinstance ( val , str ): res . append (([ key ], Path ( val ))) elif isinstance ( val , List ): res = res + [([ key ] + h , p ) for ( h , p ) in mkdocs_to_nav ( val )] else : raise Exception ( \"Not expected type\" ) else : raise Exception ( \"Not expected type\" ) return res nav_to_mkdocs ( nav ) Convert a list of nav-entries into mkdocs format. Source code in mkreports/settings.py def nav_to_mkdocs ( nav : Nav ) -> MkdocsNav : \"\"\" Convert a list of nav-entries into mkdocs format. \"\"\" split_nokey , split_keys = split_nav ( nav ) res : MkdocsNav = [ str ( p ) for p in split_nokey ] for key , val in split_keys . items (): mkdocs_for_key = nav_to_mkdocs ( val ) # if it is a list of length 1 with a string, treat it special if len ( mkdocs_for_key ) == 1 and isinstance ( mkdocs_for_key [ 0 ], str ): res . append ({ key : mkdocs_for_key [ 0 ]}) else : res . append ({ key : mkdocs_for_key }) return res snake_to_text ( x ) Convert snake case to regular text, with each word capitalized. Source code in mkreports/settings.py def snake_to_text ( x : str ) -> str : \"\"\"Convert snake case to regular text, with each word capitalized.\"\"\" return \" \" . join ([ w . capitalize () for w in x . split ( \"_\" )]) strategy_append_new ( config , path , base , nxt ) prepend nxt to base. Source code in mkreports/settings.py def strategy_append_new ( config , path , base , nxt ): \"\"\"prepend nxt to base.\"\"\" return base + [ x for x in nxt if x not in base ] true_stem ( path ) True stem of a path, without all suffixes, not just last. Source code in mkreports/settings.py def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"settings"},{"location":"Reference/mkreports/settings/#mkreports.settings.Settings","text":"Settings(mkdocs: Dict[str, Any] = , page: Dict[str, Any] = ) Source code in mkreports/settings.py @dataclass class Settings : mkdocs : Dict [ str , Any ] = field ( default_factory = dict ) page : Dict [ str , Any ] = field ( default_factory = dict ) def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), )","title":"Settings"},{"location":"Reference/mkreports/settings/#mkreports.settings.Settings.__add__","text":"Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. Source code in mkreports/settings.py def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), )","title":"__add__()"},{"location":"Reference/mkreports/settings/#mkreports.settings.mkdocs_to_nav","text":"Convert an mkdovs nav to a list of NavEntry. Source code in mkreports/settings.py def mkdocs_to_nav ( mkdocs_nav : MkdocsNav ) -> Nav : \"\"\" Convert an mkdovs nav to a list of NavEntry. \"\"\" res = [] for entry in mkdocs_nav : if isinstance ( entry , str ): res . append (([], Path ( entry ))) elif isinstance ( entry , Mapping ): key , val = check_length_one ( entry ) if isinstance ( val , str ): res . append (([ key ], Path ( val ))) elif isinstance ( val , List ): res = res + [([ key ] + h , p ) for ( h , p ) in mkdocs_to_nav ( val )] else : raise Exception ( \"Not expected type\" ) else : raise Exception ( \"Not expected type\" ) return res","title":"mkdocs_to_nav()"},{"location":"Reference/mkreports/settings/#mkreports.settings.nav_to_mkdocs","text":"Convert a list of nav-entries into mkdocs format. Source code in mkreports/settings.py def nav_to_mkdocs ( nav : Nav ) -> MkdocsNav : \"\"\" Convert a list of nav-entries into mkdocs format. \"\"\" split_nokey , split_keys = split_nav ( nav ) res : MkdocsNav = [ str ( p ) for p in split_nokey ] for key , val in split_keys . items (): mkdocs_for_key = nav_to_mkdocs ( val ) # if it is a list of length 1 with a string, treat it special if len ( mkdocs_for_key ) == 1 and isinstance ( mkdocs_for_key [ 0 ], str ): res . append ({ key : mkdocs_for_key [ 0 ]}) else : res . append ({ key : mkdocs_for_key }) return res","title":"nav_to_mkdocs()"},{"location":"Reference/mkreports/settings/#mkreports.settings.snake_to_text","text":"Convert snake case to regular text, with each word capitalized. Source code in mkreports/settings.py def snake_to_text ( x : str ) -> str : \"\"\"Convert snake case to regular text, with each word capitalized.\"\"\" return \" \" . join ([ w . capitalize () for w in x . split ( \"_\" )])","title":"snake_to_text()"},{"location":"Reference/mkreports/settings/#mkreports.settings.strategy_append_new","text":"prepend nxt to base. Source code in mkreports/settings.py def strategy_append_new ( config , path , base , nxt ): \"\"\"prepend nxt to base.\"\"\" return base + [ x for x in nxt if x not in base ]","title":"strategy_append_new()"},{"location":"Reference/mkreports/settings/#mkreports.settings.true_stem","text":"True stem of a path, without all suffixes, not just last. Source code in mkreports/settings.py def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"true_stem()"},{"location":"Reference/mkreports/stack/","text":"FrameInfo ( NodeMixin ) Source code in mkreports/stack.py class FrameInfo ( NodeMixin ): filename : str code_interval : Interval hilite_interval : Optional [ Interval ] curlineno : int code : List [ str ] co_name : str def __init__ ( self , filename : str , code_interval : Interval , hilite_interval : Optional [ Interval ], curlineno : int , code : List [ str ], co_name : str , parent : Optional [ FrameInfo ], children : Optional [ List [ FrameInfo ]], ): self . filename = filename self . code_interval = code_interval self . hilite_interval = hilite_interval self . curlineno = curlineno self . code = code self . co_name = co_name self . parent = parent if children : self . children = children def __str__ ( self ): header = f \"File: { self . filename } \" position = f \" { self . hilite_interval } in { self . code_interval } \" return \" \\n \" . join ([ header , position , self . focus_code ]) @property def name ( self ): return f \" { self . filename } : { self . code_interval . begin } - { self . code_interval . end } \" @property def focus_interval ( self ): if self . hilite_interval is None : return self . code_interval else : return self . hilite_interval @property def focus_code ( self ): display_code = \"\" . join ( self . code [ ( self . focus_interval . begin - self . code_interval . begin ) : ( self . focus_interval . end - self . code_interval . begin ) ] ) return display_code def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> Code : if highlight : code = \"\" . join ( self . code ) first_line = self . code_interval . begin if self . code_interval == self . focus_interval : hl_lines = None else : hl_lines = ( self . focus_interval . begin , self . focus_interval . end - 1 ) else : # no highlight, so we take the focused range code = self . focus_code first_line = self . focus_interval . begin hl_lines = None return Code ( code = dedent ( code ), title = self . filename if full_filename else Path ( self . filename ) . name , first_line = first_line , hl_lines = hl_lines , language = \"python\" , ) def _md_collect ( self , highlight ) -> List [ Tuple [ str , Code ]]: res = [( self . co_name , self . md_code ( highlight = highlight ))] for child in self . children : res . extend ( child . _md_collect ( highlight )) return res def md_tree ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\" Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. \"\"\" code_list = self . _md_collect ( highlight ) # now only take the unique ones code_list = list ({ key : None for key in code_list } . keys ()) # now we want to de-duplicate the list if len ( code_list ) > 0 : if len ( code_list ) == 1 : return code_list [ 0 ][ 1 ] else : res = Tab ( code_list [ 0 ][ 1 ], title = \"<main>\" ) for i in range ( 1 , len ( code_list )): res = res + Tab ( code_list [ i ][ 1 ], title = code_list [ i ][ 0 ] if full_filename else Path ( code_list [ i ][ 0 ]) . name , ) return res else : return Raw ( \"\" ) @classmethod def from_frame ( cls , frame , parent = None , children = None ) -> \"FrameInfo\" : code = frame . f_code # if higher_frame is None and code.co_firstlineno != 1: # raise Exception( # f\"Did not expect first line {code.co_firstlineno} when upper frame is None.\" # ) # if higher_frame is None: # code_lines = read_file(Path(code.co_filename)) # else: try : if code . co_name == \"<module>\" : code_lines = read_file ( Path ( code . co_filename )) else : code_lines = inspect . getsourcelines ( code )[ 0 ] except Exception : code_lines = [ \"Count not get source \\n \" ] return FrameInfo ( filename = code . co_filename , co_name = code . co_name , code_interval = Interval ( code . co_firstlineno , code . co_firstlineno + len ( code_lines ), ), hilite_interval = None , curlineno = frame . f_lineno , code = code_lines , parent = parent , children = children , ) md_tree ( self , highlight = True , full_filename = False ) Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. Source code in mkreports/stack.py def md_tree ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\" Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. \"\"\" code_list = self . _md_collect ( highlight ) # now only take the unique ones code_list = list ({ key : None for key in code_list } . keys ()) # now we want to de-duplicate the list if len ( code_list ) > 0 : if len ( code_list ) == 1 : return code_list [ 0 ][ 1 ] else : res = Tab ( code_list [ 0 ][ 1 ], title = \"<main>\" ) for i in range ( 1 , len ( code_list )): res = res + Tab ( code_list [ i ][ 1 ], title = code_list [ i ][ 0 ] if full_filename else Path ( code_list [ i ][ 0 ]) . name , ) return res else : return Raw ( \"\" ) StackDiff Source code in mkreports/stack.py class StackDiff : def __init__ ( self , first_stack : Stack , second_stack : Stack ): \"\"\" Calculate the difference of two stacks. Shows the code executed between the old stack and the new. \"\"\" self . first = first_stack self . second = second_stack self . equal = [] for idx in range ( min ( len ( self . first ), len ( self . second ))): frame_old = self . first [ idx ] frame_new = self . second [ idx ] if ( frame_old . filename == frame_new . filename and frame_old . code_interval == frame_new . code_interval ): # this is within the same function if frame_old . hilite_interval == frame_new . hilite_interval : # this is the same, no change self . equal . append ( frame_old ) else : # execution has at least moved by one code line # store the lower levels of the old frame # then the difference in the current frame to the new # then the lower levels of the new frame self . old_lower = [ FrameInfo ( filename = frame . filename , code_interval = frame . code_interval , hilite_interval = Interval ( frame . curlineno , frame . code_interval . end ), curlineno = frame . code_interval . end , code = frame . code , co_name = frame . co_name , parent = None , children = None , ) for frame in self . first [ idx + 1 :] ] middle_frame = copy ( self . first [ idx ]) middle_frame . hilite_interval = Interval ( self . first [ idx ] . focus_interval . end - 1 , self . second [ idx ] . focus_interval . end , ) self . middle = [ middle_frame ] self . new_lower = [ frame for frame in self . second [ idx + 1 :]] self . changed = self . old_lower + self . middle + self . new_lower return __init__ ( self , first_stack , second_stack ) special Calculate the difference of two stacks. Shows the code executed between the old stack and the new. Source code in mkreports/stack.py def __init__ ( self , first_stack : Stack , second_stack : Stack ): \"\"\" Calculate the difference of two stacks. Shows the code executed between the old stack and the new. \"\"\" self . first = first_stack self . second = second_stack self . equal = [] for idx in range ( min ( len ( self . first ), len ( self . second ))): frame_old = self . first [ idx ] frame_new = self . second [ idx ] if ( frame_old . filename == frame_new . filename and frame_old . code_interval == frame_new . code_interval ): # this is within the same function if frame_old . hilite_interval == frame_new . hilite_interval : # this is the same, no change self . equal . append ( frame_old ) else : # execution has at least moved by one code line # store the lower levels of the old frame # then the difference in the current frame to the new # then the lower levels of the new frame self . old_lower = [ FrameInfo ( filename = frame . filename , code_interval = frame . code_interval , hilite_interval = Interval ( frame . curlineno , frame . code_interval . end ), curlineno = frame . code_interval . end , code = frame . code , co_name = frame . co_name , parent = None , children = None , ) for frame in self . first [ idx + 1 :] ] middle_frame = copy ( self . first [ idx ]) middle_frame . hilite_interval = Interval ( self . first [ idx ] . focus_interval . end - 1 , self . second [ idx ] . focus_interval . end , ) self . middle = [ middle_frame ] self . new_lower = [ frame for frame in self . second [ idx + 1 :]] self . changed = self . old_lower + self . middle + self . new_lower return Tracker Used to profile the code in order to detect executed functions. It is intended to be used as a context manager. When entering the context, the profiler will be set and all subsequent function calls will be recorded. Afterwards the profiling is stopped. Source code in mkreports/stack.py class Tracker : \"\"\" Used to profile the code in order to detect executed functions. It is intended to be used as a context manager. When entering the context, the profiler will be set and all subsequent function calls will be recorded. Afterwards the profiling is stopped. \"\"\" def __init__ ( self , dirs : Optional [ Union [ AnyPath , Sequence [ AnyPath ]]] = None , packages : Optional [ Union [ ModuleType , Sequence [ ModuleType ]]] = None , omit_levels : int = 0 , ): if isinstance ( dirs , Sequence ) and not isinstance ( dirs , str ): my_dirs = list ( dirs ) # don't need to do anything elif isinstance ( dirs , ( str , Path )): my_dirs = [ dirs ] else : my_dirs = [] if isinstance ( packages , Sequence ): packages = list ( packages ) elif isinstance ( packages , ModuleType ): packages = [ packages ] else : packages = [] # for the packages, we also convert them to directories for package in packages : # always use the first element of the list my_dirs . append ( Path ( package . __path__ [ 0 ])) # make the directories strings with a slash at the end self . dirs = [ str ( x ) + \"/\" for x in my_dirs ] self . omit_levels = omit_levels self . ctx_active = False self . tree = None self . cur_node = None def start ( self , omit_levels = 0 ): \"\"\"Activate the tracking.\"\"\" if self . ctx_active : raise TrackerActiveError ( \"Context manager is already active\" ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # save the tree for storing the information self . tree = FrameInfo . from_frame ( frame ) # include the current file in the directories to accept self . active_dirs = copy ( self . dirs ) self . active_dirs . append ( str ( Path ( self . tree . filename ) . parent ) + \"/\" ) self . active_dirs = list ( set ( self . active_dirs )) # here we actually want the next command self . cur_node = self . tree stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) stmt_after = parser . closest_after ( stmt_tree , frame . f_lineno ) if stmt_after is None : self . entry_lineno = frame . f_lineno else : self . entry_lineno = stmt_after . begin self . ctx_active = True # we get the directory of the callee if sys . gettrace () is None : sys . settrace ( self . trace ) # sys.settrace(None) else : logger . warning ( f \"Logger already set to { sys . gettrace () } \" ) return self def stop ( self , omit_levels = 0 ): if not self . ctx_active : raise TrackerNotActiveError ( \"Context manager is not active\" ) sys . settrace ( None ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # we set the display range # the display_range should go to the end of the current statement if self . tree is not None : # here we want to have the true ending line number stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) cur_stmt_lines = parser . smallest_overlap ( stmt_tree , frame . f_lineno ) if cur_stmt_lines is not None : self . tree . hilite_interval = Interval ( self . entry_lineno , cur_stmt_lines . end ) else : raise Exception ( \"Could not find current statement\" ) else : raise Exception ( \"__enter__ has not been called.\" ) self . ctx_active = False def __enter__ ( self ) -> \"Tracker\" : \"\"\"Enter context manager and set the profiler.\"\"\" return self . start ( omit_levels = 1 ) def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\"Remove the profiler when exiting the context manager.\"\"\" self . stop ( omit_levels = 1 ) @property def finished ( self ) -> bool : \"\"\"Tracker ctx manager has been finished.\"\"\" # The tracker context manager has been finished if # the node is not None, but also the ctx-manager is not active. return self . tree is not None and not self . ctx_active def _get_callee_frame ( self , omit_levels : int ) -> FrameType : frame = inspect . currentframe () # need to jump over the specified number of levels for _ in range ( omit_levels + 1 ): if frame is None : raise Exception ( \"frame is None\" ) frame = frame . f_back if frame is None : raise Exception ( \"frame is None\" ) return frame def frame_traceable ( self , frame : FrameType ) -> bool : frame_path = frame . f_code . co_filename for dir in self . active_dirs : if frame_path . startswith ( dir ): return True return False def notrace ( self , frame , event , arg ): return None def trace_reset_on_return ( self , frame , event , arg ): if event == \"return\" : sys . settrace ( self . trace ) return self . trace def trace ( self , frame , event , arg ): # when tracing, only care if it is a 'call' event if event == \"call\" : # if it is inside the approved dirs, keep tracing; # otherwise we turn it off if self . frame_traceable ( frame ): # add the code object to the things that are traced # we put this as part of the tree self . cur_node = FrameInfo . from_frame ( frame , parent = self . cur_node ) return self . trace else : # we stop tracing sys . settrace ( self . notrace ) return self . trace_reset_on_return elif event == \"return\" : # set the current node to the parent in the tree if self . cur_node is not None : self . cur_node = self . cur_node . parent sys . settrace ( self . trace ) else : raise Exception ( \"cur_node should not be None\" ) pass else : return self . trace finished : bool property readonly Tracker ctx manager has been finished. __enter__ ( self ) special Enter context manager and set the profiler. Source code in mkreports/stack.py def __enter__ ( self ) -> \"Tracker\" : \"\"\"Enter context manager and set the profiler.\"\"\" return self . start ( omit_levels = 1 ) __exit__ ( self , exc_type , exc_val , traceback ) special Remove the profiler when exiting the context manager. Source code in mkreports/stack.py def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\"Remove the profiler when exiting the context manager.\"\"\" self . stop ( omit_levels = 1 ) start ( self , omit_levels = 0 ) Activate the tracking. Source code in mkreports/stack.py def start ( self , omit_levels = 0 ): \"\"\"Activate the tracking.\"\"\" if self . ctx_active : raise TrackerActiveError ( \"Context manager is already active\" ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # save the tree for storing the information self . tree = FrameInfo . from_frame ( frame ) # include the current file in the directories to accept self . active_dirs = copy ( self . dirs ) self . active_dirs . append ( str ( Path ( self . tree . filename ) . parent ) + \"/\" ) self . active_dirs = list ( set ( self . active_dirs )) # here we actually want the next command self . cur_node = self . tree stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) stmt_after = parser . closest_after ( stmt_tree , frame . f_lineno ) if stmt_after is None : self . entry_lineno = frame . f_lineno else : self . entry_lineno = stmt_after . begin self . ctx_active = True # we get the directory of the callee if sys . gettrace () is None : sys . settrace ( self . trace ) # sys.settrace(None) else : logger . warning ( f \"Logger already set to { sys . gettrace () } \" ) return self get_stack ( omit_levels = 0 ) Get a simplified version of the stack. Source code in mkreports/stack.py def get_stack ( omit_levels : int = 0 ) -> Stack : \"\"\" Get a simplified version of the stack. \"\"\" frame = inspect . currentframe () # need to jump over the specified number of levels for _ in range ( omit_levels + 1 ): if frame is None : raise Exception ( \"frame is None\" ) frame = frame . f_back stack = [] while frame is not None : stack . append ( FrameInfo . from_frame ( frame )) frame = frame . f_back return list ( reversed ( stack )) read_file ( path , from_line = None , to_line = None ) Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Source code in mkreports/stack.py def read_file ( path : Path , from_line : Optional [ int ] = None , to_line : Optional [ int ] = None ) -> List [ str ]: \"\"\" Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. \"\"\" with path . open ( \"r\" ) as f : lines = f . readlines () return lines [ slice ( from_line , to_line , 1 )]","title":"stack"},{"location":"Reference/mkreports/stack/#mkreports.stack.FrameInfo","text":"Source code in mkreports/stack.py class FrameInfo ( NodeMixin ): filename : str code_interval : Interval hilite_interval : Optional [ Interval ] curlineno : int code : List [ str ] co_name : str def __init__ ( self , filename : str , code_interval : Interval , hilite_interval : Optional [ Interval ], curlineno : int , code : List [ str ], co_name : str , parent : Optional [ FrameInfo ], children : Optional [ List [ FrameInfo ]], ): self . filename = filename self . code_interval = code_interval self . hilite_interval = hilite_interval self . curlineno = curlineno self . code = code self . co_name = co_name self . parent = parent if children : self . children = children def __str__ ( self ): header = f \"File: { self . filename } \" position = f \" { self . hilite_interval } in { self . code_interval } \" return \" \\n \" . join ([ header , position , self . focus_code ]) @property def name ( self ): return f \" { self . filename } : { self . code_interval . begin } - { self . code_interval . end } \" @property def focus_interval ( self ): if self . hilite_interval is None : return self . code_interval else : return self . hilite_interval @property def focus_code ( self ): display_code = \"\" . join ( self . code [ ( self . focus_interval . begin - self . code_interval . begin ) : ( self . focus_interval . end - self . code_interval . begin ) ] ) return display_code def md_code ( self , highlight : bool = True , full_filename : bool = False ) -> Code : if highlight : code = \"\" . join ( self . code ) first_line = self . code_interval . begin if self . code_interval == self . focus_interval : hl_lines = None else : hl_lines = ( self . focus_interval . begin , self . focus_interval . end - 1 ) else : # no highlight, so we take the focused range code = self . focus_code first_line = self . focus_interval . begin hl_lines = None return Code ( code = dedent ( code ), title = self . filename if full_filename else Path ( self . filename ) . name , first_line = first_line , hl_lines = hl_lines , language = \"python\" , ) def _md_collect ( self , highlight ) -> List [ Tuple [ str , Code ]]: res = [( self . co_name , self . md_code ( highlight = highlight ))] for child in self . children : res . extend ( child . _md_collect ( highlight )) return res def md_tree ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\" Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. \"\"\" code_list = self . _md_collect ( highlight ) # now only take the unique ones code_list = list ({ key : None for key in code_list } . keys ()) # now we want to de-duplicate the list if len ( code_list ) > 0 : if len ( code_list ) == 1 : return code_list [ 0 ][ 1 ] else : res = Tab ( code_list [ 0 ][ 1 ], title = \"<main>\" ) for i in range ( 1 , len ( code_list )): res = res + Tab ( code_list [ i ][ 1 ], title = code_list [ i ][ 0 ] if full_filename else Path ( code_list [ i ][ 0 ]) . name , ) return res else : return Raw ( \"\" ) @classmethod def from_frame ( cls , frame , parent = None , children = None ) -> \"FrameInfo\" : code = frame . f_code # if higher_frame is None and code.co_firstlineno != 1: # raise Exception( # f\"Did not expect first line {code.co_firstlineno} when upper frame is None.\" # ) # if higher_frame is None: # code_lines = read_file(Path(code.co_filename)) # else: try : if code . co_name == \"<module>\" : code_lines = read_file ( Path ( code . co_filename )) else : code_lines = inspect . getsourcelines ( code )[ 0 ] except Exception : code_lines = [ \"Count not get source \\n \" ] return FrameInfo ( filename = code . co_filename , co_name = code . co_name , code_interval = Interval ( code . co_firstlineno , code . co_firstlineno + len ( code_lines ), ), hilite_interval = None , curlineno = frame . f_lineno , code = code_lines , parent = parent , children = children , )","title":"FrameInfo"},{"location":"Reference/mkreports/stack/#mkreports.stack.FrameInfo.md_tree","text":"Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. Source code in mkreports/stack.py def md_tree ( self , highlight : bool = True , full_filename : bool = False ) -> MdObj : \"\"\" Return the code in a tree. If there is only a single node, a simple Code object is returned, otherwise Tabs are produced for the code. In the tabs, functions that occur earlier in the code are listed first. Also, functions are only listed once even if they occur deeper in the tree. \"\"\" code_list = self . _md_collect ( highlight ) # now only take the unique ones code_list = list ({ key : None for key in code_list } . keys ()) # now we want to de-duplicate the list if len ( code_list ) > 0 : if len ( code_list ) == 1 : return code_list [ 0 ][ 1 ] else : res = Tab ( code_list [ 0 ][ 1 ], title = \"<main>\" ) for i in range ( 1 , len ( code_list )): res = res + Tab ( code_list [ i ][ 1 ], title = code_list [ i ][ 0 ] if full_filename else Path ( code_list [ i ][ 0 ]) . name , ) return res else : return Raw ( \"\" )","title":"md_tree()"},{"location":"Reference/mkreports/stack/#mkreports.stack.StackDiff","text":"Source code in mkreports/stack.py class StackDiff : def __init__ ( self , first_stack : Stack , second_stack : Stack ): \"\"\" Calculate the difference of two stacks. Shows the code executed between the old stack and the new. \"\"\" self . first = first_stack self . second = second_stack self . equal = [] for idx in range ( min ( len ( self . first ), len ( self . second ))): frame_old = self . first [ idx ] frame_new = self . second [ idx ] if ( frame_old . filename == frame_new . filename and frame_old . code_interval == frame_new . code_interval ): # this is within the same function if frame_old . hilite_interval == frame_new . hilite_interval : # this is the same, no change self . equal . append ( frame_old ) else : # execution has at least moved by one code line # store the lower levels of the old frame # then the difference in the current frame to the new # then the lower levels of the new frame self . old_lower = [ FrameInfo ( filename = frame . filename , code_interval = frame . code_interval , hilite_interval = Interval ( frame . curlineno , frame . code_interval . end ), curlineno = frame . code_interval . end , code = frame . code , co_name = frame . co_name , parent = None , children = None , ) for frame in self . first [ idx + 1 :] ] middle_frame = copy ( self . first [ idx ]) middle_frame . hilite_interval = Interval ( self . first [ idx ] . focus_interval . end - 1 , self . second [ idx ] . focus_interval . end , ) self . middle = [ middle_frame ] self . new_lower = [ frame for frame in self . second [ idx + 1 :]] self . changed = self . old_lower + self . middle + self . new_lower return","title":"StackDiff"},{"location":"Reference/mkreports/stack/#mkreports.stack.StackDiff.__init__","text":"Calculate the difference of two stacks. Shows the code executed between the old stack and the new. Source code in mkreports/stack.py def __init__ ( self , first_stack : Stack , second_stack : Stack ): \"\"\" Calculate the difference of two stacks. Shows the code executed between the old stack and the new. \"\"\" self . first = first_stack self . second = second_stack self . equal = [] for idx in range ( min ( len ( self . first ), len ( self . second ))): frame_old = self . first [ idx ] frame_new = self . second [ idx ] if ( frame_old . filename == frame_new . filename and frame_old . code_interval == frame_new . code_interval ): # this is within the same function if frame_old . hilite_interval == frame_new . hilite_interval : # this is the same, no change self . equal . append ( frame_old ) else : # execution has at least moved by one code line # store the lower levels of the old frame # then the difference in the current frame to the new # then the lower levels of the new frame self . old_lower = [ FrameInfo ( filename = frame . filename , code_interval = frame . code_interval , hilite_interval = Interval ( frame . curlineno , frame . code_interval . end ), curlineno = frame . code_interval . end , code = frame . code , co_name = frame . co_name , parent = None , children = None , ) for frame in self . first [ idx + 1 :] ] middle_frame = copy ( self . first [ idx ]) middle_frame . hilite_interval = Interval ( self . first [ idx ] . focus_interval . end - 1 , self . second [ idx ] . focus_interval . end , ) self . middle = [ middle_frame ] self . new_lower = [ frame for frame in self . second [ idx + 1 :]] self . changed = self . old_lower + self . middle + self . new_lower return","title":"__init__()"},{"location":"Reference/mkreports/stack/#mkreports.stack.Tracker","text":"Used to profile the code in order to detect executed functions. It is intended to be used as a context manager. When entering the context, the profiler will be set and all subsequent function calls will be recorded. Afterwards the profiling is stopped. Source code in mkreports/stack.py class Tracker : \"\"\" Used to profile the code in order to detect executed functions. It is intended to be used as a context manager. When entering the context, the profiler will be set and all subsequent function calls will be recorded. Afterwards the profiling is stopped. \"\"\" def __init__ ( self , dirs : Optional [ Union [ AnyPath , Sequence [ AnyPath ]]] = None , packages : Optional [ Union [ ModuleType , Sequence [ ModuleType ]]] = None , omit_levels : int = 0 , ): if isinstance ( dirs , Sequence ) and not isinstance ( dirs , str ): my_dirs = list ( dirs ) # don't need to do anything elif isinstance ( dirs , ( str , Path )): my_dirs = [ dirs ] else : my_dirs = [] if isinstance ( packages , Sequence ): packages = list ( packages ) elif isinstance ( packages , ModuleType ): packages = [ packages ] else : packages = [] # for the packages, we also convert them to directories for package in packages : # always use the first element of the list my_dirs . append ( Path ( package . __path__ [ 0 ])) # make the directories strings with a slash at the end self . dirs = [ str ( x ) + \"/\" for x in my_dirs ] self . omit_levels = omit_levels self . ctx_active = False self . tree = None self . cur_node = None def start ( self , omit_levels = 0 ): \"\"\"Activate the tracking.\"\"\" if self . ctx_active : raise TrackerActiveError ( \"Context manager is already active\" ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # save the tree for storing the information self . tree = FrameInfo . from_frame ( frame ) # include the current file in the directories to accept self . active_dirs = copy ( self . dirs ) self . active_dirs . append ( str ( Path ( self . tree . filename ) . parent ) + \"/\" ) self . active_dirs = list ( set ( self . active_dirs )) # here we actually want the next command self . cur_node = self . tree stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) stmt_after = parser . closest_after ( stmt_tree , frame . f_lineno ) if stmt_after is None : self . entry_lineno = frame . f_lineno else : self . entry_lineno = stmt_after . begin self . ctx_active = True # we get the directory of the callee if sys . gettrace () is None : sys . settrace ( self . trace ) # sys.settrace(None) else : logger . warning ( f \"Logger already set to { sys . gettrace () } \" ) return self def stop ( self , omit_levels = 0 ): if not self . ctx_active : raise TrackerNotActiveError ( \"Context manager is not active\" ) sys . settrace ( None ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # we set the display range # the display_range should go to the end of the current statement if self . tree is not None : # here we want to have the true ending line number stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) cur_stmt_lines = parser . smallest_overlap ( stmt_tree , frame . f_lineno ) if cur_stmt_lines is not None : self . tree . hilite_interval = Interval ( self . entry_lineno , cur_stmt_lines . end ) else : raise Exception ( \"Could not find current statement\" ) else : raise Exception ( \"__enter__ has not been called.\" ) self . ctx_active = False def __enter__ ( self ) -> \"Tracker\" : \"\"\"Enter context manager and set the profiler.\"\"\" return self . start ( omit_levels = 1 ) def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\"Remove the profiler when exiting the context manager.\"\"\" self . stop ( omit_levels = 1 ) @property def finished ( self ) -> bool : \"\"\"Tracker ctx manager has been finished.\"\"\" # The tracker context manager has been finished if # the node is not None, but also the ctx-manager is not active. return self . tree is not None and not self . ctx_active def _get_callee_frame ( self , omit_levels : int ) -> FrameType : frame = inspect . currentframe () # need to jump over the specified number of levels for _ in range ( omit_levels + 1 ): if frame is None : raise Exception ( \"frame is None\" ) frame = frame . f_back if frame is None : raise Exception ( \"frame is None\" ) return frame def frame_traceable ( self , frame : FrameType ) -> bool : frame_path = frame . f_code . co_filename for dir in self . active_dirs : if frame_path . startswith ( dir ): return True return False def notrace ( self , frame , event , arg ): return None def trace_reset_on_return ( self , frame , event , arg ): if event == \"return\" : sys . settrace ( self . trace ) return self . trace def trace ( self , frame , event , arg ): # when tracing, only care if it is a 'call' event if event == \"call\" : # if it is inside the approved dirs, keep tracing; # otherwise we turn it off if self . frame_traceable ( frame ): # add the code object to the things that are traced # we put this as part of the tree self . cur_node = FrameInfo . from_frame ( frame , parent = self . cur_node ) return self . trace else : # we stop tracing sys . settrace ( self . notrace ) return self . trace_reset_on_return elif event == \"return\" : # set the current node to the parent in the tree if self . cur_node is not None : self . cur_node = self . cur_node . parent sys . settrace ( self . trace ) else : raise Exception ( \"cur_node should not be None\" ) pass else : return self . trace","title":"Tracker"},{"location":"Reference/mkreports/stack/#mkreports.stack.Tracker.finished","text":"Tracker ctx manager has been finished.","title":"finished"},{"location":"Reference/mkreports/stack/#mkreports.stack.Tracker.__enter__","text":"Enter context manager and set the profiler. Source code in mkreports/stack.py def __enter__ ( self ) -> \"Tracker\" : \"\"\"Enter context manager and set the profiler.\"\"\" return self . start ( omit_levels = 1 )","title":"__enter__()"},{"location":"Reference/mkreports/stack/#mkreports.stack.Tracker.__exit__","text":"Remove the profiler when exiting the context manager. Source code in mkreports/stack.py def __exit__ ( self , exc_type , exc_val , traceback ) -> None : \"\"\"Remove the profiler when exiting the context manager.\"\"\" self . stop ( omit_levels = 1 )","title":"__exit__()"},{"location":"Reference/mkreports/stack/#mkreports.stack.Tracker.start","text":"Activate the tracking. Source code in mkreports/stack.py def start ( self , omit_levels = 0 ): \"\"\"Activate the tracking.\"\"\" if self . ctx_active : raise TrackerActiveError ( \"Context manager is already active\" ) frame = self . _get_callee_frame ( omit_levels = omit_levels + 1 ) # save the tree for storing the information self . tree = FrameInfo . from_frame ( frame ) # include the current file in the directories to accept self . active_dirs = copy ( self . dirs ) self . active_dirs . append ( str ( Path ( self . tree . filename ) . parent ) + \"/\" ) self . active_dirs = list ( set ( self . active_dirs )) # here we actually want the next command self . cur_node = self . tree stmt_tree = parser . get_stmt_ranges ( Path ( frame . f_code . co_filename )) stmt_after = parser . closest_after ( stmt_tree , frame . f_lineno ) if stmt_after is None : self . entry_lineno = frame . f_lineno else : self . entry_lineno = stmt_after . begin self . ctx_active = True # we get the directory of the callee if sys . gettrace () is None : sys . settrace ( self . trace ) # sys.settrace(None) else : logger . warning ( f \"Logger already set to { sys . gettrace () } \" ) return self","title":"start()"},{"location":"Reference/mkreports/stack/#mkreports.stack.get_stack","text":"Get a simplified version of the stack. Source code in mkreports/stack.py def get_stack ( omit_levels : int = 0 ) -> Stack : \"\"\" Get a simplified version of the stack. \"\"\" frame = inspect . currentframe () # need to jump over the specified number of levels for _ in range ( omit_levels + 1 ): if frame is None : raise Exception ( \"frame is None\" ) frame = frame . f_back stack = [] while frame is not None : stack . append ( FrameInfo . from_frame ( frame )) frame = frame . f_back return list ( reversed ( stack ))","title":"get_stack()"},{"location":"Reference/mkreports/stack/#mkreports.stack.read_file","text":"Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Source code in mkreports/stack.py def read_file ( path : Path , from_line : Optional [ int ] = None , to_line : Optional [ int ] = None ) -> List [ str ]: \"\"\" Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. \"\"\" with path . open ( \"r\" ) as f : lines = f . readlines () return lines [ slice ( from_line , to_line , 1 )]","title":"read_file()"},{"location":"Reference/mkreports/utils/","text":"relative_repo_root ( path ) Path relative to repo root or just the name. Source code in mkreports/utils.py def relative_repo_root ( path : Union [ Path , str ]) -> str : \"\"\" Path relative to repo root or just the name. \"\"\" try : repo = git . Repo ( \".\" , search_parent_directories = True ) root_dir = repo . working_tree_dir if root_dir is not None : return str ( Path ( path ) . relative_to ( root_dir )) except Exception : pass return Path ( path ) . name","title":"utils"},{"location":"Reference/mkreports/utils/#mkreports.utils.relative_repo_root","text":"Path relative to repo root or just the name. Source code in mkreports/utils.py def relative_repo_root ( path : Union [ Path , str ]) -> str : \"\"\" Path relative to repo root or just the name. \"\"\" try : repo = git . Repo ( \".\" , search_parent_directories = True ) root_dir = repo . working_tree_dir if root_dir is not None : return str ( Path ( path ) . relative_to ( root_dir )) except Exception : pass return Path ( path ) . name","title":"relative_repo_root()"},{"location":"Reference/mkreports/md/base/","text":"Anchor ( MdObj ) dataclass Anchor(name: str) Source code in mkreports/md/base.py @dataclass () class Anchor ( MdObj ): name : str def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( f \"[]() {{ :name=' { self . name } ' }} \" , ( 0 , 0 )) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( f \"[]() {{ :name=' { self . name } ' }} \" , ( 0 , 0 )) Link ( MdObj ) dataclass Link(text: str = '', to_page_path: Optional[pathlib.Path] = None, anchor: Union[str, mkreports.md.base.Anchor, NoneType] = None, url: Optional[str] = None) Source code in mkreports/md/base.py @dataclass () class Link ( MdObj ): text : str = \"\" to_page_path : Optional [ Path ] = None anchor : Optional [ Union [ str , Anchor ]] = None url : Optional [ str ] = None def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if self . url is not None : link = self . url else : if page_path is None or self . to_page_path is None : if self . anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \"# { anchor_id } \" else : # both are not none, do relative if self . anchor is None : link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } \" else : anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } # { anchor_id } \" return SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 )) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if self . url is not None : link = self . url else : if page_path is None or self . to_page_path is None : if self . anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \"# { anchor_id } \" else : # both are not none, do relative if self . anchor is None : link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } \" else : anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } # { anchor_id } \" return SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 )) MdObj ( ABC ) A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. Source code in mkreports/md/base.py class MdObj ( ABC ): \"\"\" A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. \"\"\" def __add__ ( self , other ) -> \"MdSeq\" : first = self if isinstance ( self , MdSeq ) else MdSeq ([ self ]) second = other if isinstance ( other , MdSeq ) else MdSeq ([ other ]) return first + second def __radd__ ( self , other ) -> \"MdSeq\" : first = other if isinstance ( self , MdSeq ) else MdSeq ([ other ]) second = self if isinstance ( other , MdSeq ) else MdSeq ([ self ]) return first + second def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Return the parts of the object required for the backmatter.\"\"\" return SpacedText ( \"\" ) @abstractmethod def to_markdown ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\" Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. \"\"\" pass def to_md_with_bm ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\" Convert to markdown and attach the backmatter. \"\"\" backmatter = self . backmatter ( page_path ) if backmatter . text == \"\" : return self . to_markdown ( page_path ) else : return SpacedText ( self . to_markdown ( page_path ), ( 1 , 2 )) + SpacedText ( self . backmatter ( page_path ), ( 2 , 1 ) ) def req_settings ( self ) -> Settings : return Settings () backmatter ( self , page_path ) Return the parts of the object required for the backmatter. Source code in mkreports/md/base.py def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Return the parts of the object required for the backmatter.\"\"\" return SpacedText ( \"\" ) to_markdown ( self , page_path ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py @abstractmethod def to_markdown ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\" Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. \"\"\" pass to_md_with_bm ( self , page_path ) Convert to markdown and attach the backmatter. Source code in mkreports/md/base.py def to_md_with_bm ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\" Convert to markdown and attach the backmatter. \"\"\" backmatter = self . backmatter ( page_path ) if backmatter . text == \"\" : return self . to_markdown ( page_path ) else : return SpacedText ( self . to_markdown ( page_path ), ( 1 , 2 )) + SpacedText ( self . backmatter ( page_path ), ( 2 , 1 ) ) MdSeq ( MdObj , Sequence ) Class to caputre a list of other MdObjs. Source code in mkreports/md/base.py class MdSeq ( MdObj , Sequence ): \"\"\" Class to caputre a list of other MdObjs. \"\"\" items : Tuple [ MdObj , ... ] def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) def __getitem__ ( self , index : int ) -> MdObj : return self . items [ index ] def __len__ ( self ) -> int : return len ( self . items ) def __add__ ( self , other ) -> \"MdSeq\" : second_items = other . items if type ( other ) == MdSeq else ( other ,) return MdSeq ( self . items + second_items ) def __radd__ ( self , other ) -> \"MdSeq\" : second_items = other if type ( other ) == MdSeq else ( other ,) return MdSeq ( second_items + self . items ) def backmatter ( self , path : Optional [ Path ] = None ) -> SpacedText : return functools . reduce ( lambda x , y : x + y , [ elem . backmatter ( path ) for elem in self . items ] ) def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : return functools . reduce ( lambda x , y : x + y , [ elem . to_markdown ( path ) for elem in self . items ] ) def req_settings ( self ) -> Settings : \"\"\"Requirements for the object.\"\"\" # merge the requirements for all individual elements res = Settings () for elem in self . items : res += elem . req_settings () return res __init__ ( self , items = ()) special Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Source code in mkreports/md/base.py def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) backmatter ( self , path = None ) Return the parts of the object required for the backmatter. Source code in mkreports/md/base.py def backmatter ( self , path : Optional [ Path ] = None ) -> SpacedText : return functools . reduce ( lambda x , y : x + y , [ elem . backmatter ( path ) for elem in self . items ] ) req_settings ( self ) Requirements for the object. Source code in mkreports/md/base.py def req_settings ( self ) -> Settings : \"\"\"Requirements for the object.\"\"\" # merge the requirements for all individual elements res = Settings () for elem in self . items : res += elem . req_settings () return res to_markdown ( self , path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : return functools . reduce ( lambda x , y : x + y , [ elem . to_markdown ( path ) for elem in self . items ] ) Paragraph ( MdObj ) dataclass Wraps an object in a paragraph. Source code in mkreports/md/base.py @dataclass class Paragraph ( MdObj ): \"\"\" Wraps an object in a paragraph. \"\"\" obj : MdObj anchor : Optional [ Union [ Anchor , str ]] def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) def backmatter ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return self . obj . backmatter ( page_path ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : p_text = self . obj . to_markdown ( page_path ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init p_text = SpacedText ( p_text . text , ( 0 , 1 )) + self . anchor . to_markdown ( page_path ) return SpacedText ( p_text , ( 2 , 2 )) backmatter ( self , page_path = None ) Return the parts of the object required for the backmatter. Source code in mkreports/md/base.py def backmatter ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return self . obj . backmatter ( page_path ) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : p_text = self . obj . to_markdown ( page_path ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init p_text = SpacedText ( p_text . text , ( 0 , 1 )) + self . anchor . to_markdown ( page_path ) return SpacedText ( p_text , ( 2 , 2 )) Raw ( MdObj ) dataclass Class to encapsulate raw markdown. Source code in mkreports/md/base.py @dataclass () class Raw ( MdObj ): \"\"\" Class to encapsulate raw markdown. \"\"\" raw : Text page_settings : Dict [ str , Any ] mkdocs_settings : Dict [ str , Any ] def __init__ ( self , raw : Text = \"\" , dedent = True , page_settings = None , mkdocs_settings = None ): super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) self . raw = raw self . page_settings = page_settings self . mkdocs_settings = mkdocs_settings def req_settings ( self ) -> Settings : return Settings ( page = self . page_settings if self . page_settings is not None else {}, mkdocs = self . mkdocs_settings if self . mkdocs_settings is not None else {}, ) def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( self . raw ) to_markdown ( self , path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( self . raw )","title":"base"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Anchor","text":"Anchor(name: str) Source code in mkreports/md/base.py @dataclass () class Anchor ( MdObj ): name : str def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( f \"[]() {{ :name=' { self . name } ' }} \" , ( 0 , 0 ))","title":"Anchor"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Anchor.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( f \"[]() {{ :name=' { self . name } ' }} \" , ( 0 , 0 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Link","text":"Link(text: str = '', to_page_path: Optional[pathlib.Path] = None, anchor: Union[str, mkreports.md.base.Anchor, NoneType] = None, url: Optional[str] = None) Source code in mkreports/md/base.py @dataclass () class Link ( MdObj ): text : str = \"\" to_page_path : Optional [ Path ] = None anchor : Optional [ Union [ str , Anchor ]] = None url : Optional [ str ] = None def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if self . url is not None : link = self . url else : if page_path is None or self . to_page_path is None : if self . anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \"# { anchor_id } \" else : # both are not none, do relative if self . anchor is None : link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } \" else : anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } # { anchor_id } \" return SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 ))","title":"Link"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Link.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if self . url is not None : link = self . url else : if page_path is None or self . to_page_path is None : if self . anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \"# { anchor_id } \" else : # both are not none, do relative if self . anchor is None : link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } \" else : anchor_id = ( self . anchor if isinstance ( self . anchor , str ) else self . anchor . name ) link = f \" { relpath ( self . to_page_path , start = page_path . parent ) } # { anchor_id } \" return SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdObj","text":"A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. Source code in mkreports/md/base.py class MdObj ( ABC ): \"\"\" A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. \"\"\" def __add__ ( self , other ) -> \"MdSeq\" : first = self if isinstance ( self , MdSeq ) else MdSeq ([ self ]) second = other if isinstance ( other , MdSeq ) else MdSeq ([ other ]) return first + second def __radd__ ( self , other ) -> \"MdSeq\" : first = other if isinstance ( self , MdSeq ) else MdSeq ([ other ]) second = self if isinstance ( other , MdSeq ) else MdSeq ([ self ]) return first + second def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Return the parts of the object required for the backmatter.\"\"\" return SpacedText ( \"\" ) @abstractmethod def to_markdown ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\" Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. \"\"\" pass def to_md_with_bm ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\" Convert to markdown and attach the backmatter. \"\"\" backmatter = self . backmatter ( page_path ) if backmatter . text == \"\" : return self . to_markdown ( page_path ) else : return SpacedText ( self . to_markdown ( page_path ), ( 1 , 2 )) + SpacedText ( self . backmatter ( page_path ), ( 2 , 1 ) ) def req_settings ( self ) -> Settings : return Settings ()","title":"MdObj"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdObj.backmatter","text":"Return the parts of the object required for the backmatter. Source code in mkreports/md/base.py def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Return the parts of the object required for the backmatter.\"\"\" return SpacedText ( \"\" )","title":"backmatter()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdObj.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py @abstractmethod def to_markdown ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\" Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. \"\"\" pass","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdObj.to_md_with_bm","text":"Convert to markdown and attach the backmatter. Source code in mkreports/md/base.py def to_md_with_bm ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\" Convert to markdown and attach the backmatter. \"\"\" backmatter = self . backmatter ( page_path ) if backmatter . text == \"\" : return self . to_markdown ( page_path ) else : return SpacedText ( self . to_markdown ( page_path ), ( 1 , 2 )) + SpacedText ( self . backmatter ( page_path ), ( 2 , 1 ) )","title":"to_md_with_bm()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdSeq","text":"Class to caputre a list of other MdObjs. Source code in mkreports/md/base.py class MdSeq ( MdObj , Sequence ): \"\"\" Class to caputre a list of other MdObjs. \"\"\" items : Tuple [ MdObj , ... ] def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) def __getitem__ ( self , index : int ) -> MdObj : return self . items [ index ] def __len__ ( self ) -> int : return len ( self . items ) def __add__ ( self , other ) -> \"MdSeq\" : second_items = other . items if type ( other ) == MdSeq else ( other ,) return MdSeq ( self . items + second_items ) def __radd__ ( self , other ) -> \"MdSeq\" : second_items = other if type ( other ) == MdSeq else ( other ,) return MdSeq ( second_items + self . items ) def backmatter ( self , path : Optional [ Path ] = None ) -> SpacedText : return functools . reduce ( lambda x , y : x + y , [ elem . backmatter ( path ) for elem in self . items ] ) def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : return functools . reduce ( lambda x , y : x + y , [ elem . to_markdown ( path ) for elem in self . items ] ) def req_settings ( self ) -> Settings : \"\"\"Requirements for the object.\"\"\" # merge the requirements for all individual elements res = Settings () for elem in self . items : res += elem . req_settings () return res","title":"MdSeq"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdSeq.__init__","text":"Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Source code in mkreports/md/base.py def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ])","title":"__init__()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdSeq.backmatter","text":"Return the parts of the object required for the backmatter. Source code in mkreports/md/base.py def backmatter ( self , path : Optional [ Path ] = None ) -> SpacedText : return functools . reduce ( lambda x , y : x + y , [ elem . backmatter ( path ) for elem in self . items ] )","title":"backmatter()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdSeq.req_settings","text":"Requirements for the object. Source code in mkreports/md/base.py def req_settings ( self ) -> Settings : \"\"\"Requirements for the object.\"\"\" # merge the requirements for all individual elements res = Settings () for elem in self . items : res += elem . req_settings () return res","title":"req_settings()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.MdSeq.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : return functools . reduce ( lambda x , y : x + y , [ elem . to_markdown ( path ) for elem in self . items ] )","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Paragraph","text":"Wraps an object in a paragraph. Source code in mkreports/md/base.py @dataclass class Paragraph ( MdObj ): \"\"\" Wraps an object in a paragraph. \"\"\" obj : MdObj anchor : Optional [ Union [ Anchor , str ]] def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) def backmatter ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return self . obj . backmatter ( page_path ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : p_text = self . obj . to_markdown ( page_path ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init p_text = SpacedText ( p_text . text , ( 0 , 1 )) + self . anchor . to_markdown ( page_path ) return SpacedText ( p_text , ( 2 , 2 ))","title":"Paragraph"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Paragraph.backmatter","text":"Return the parts of the object required for the backmatter. Source code in mkreports/md/base.py def backmatter ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return self . obj . backmatter ( page_path )","title":"backmatter()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Paragraph.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : p_text = self . obj . to_markdown ( page_path ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init p_text = SpacedText ( p_text . text , ( 0 , 1 )) + self . anchor . to_markdown ( page_path ) return SpacedText ( p_text , ( 2 , 2 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Raw","text":"Class to encapsulate raw markdown. Source code in mkreports/md/base.py @dataclass () class Raw ( MdObj ): \"\"\" Class to encapsulate raw markdown. \"\"\" raw : Text page_settings : Dict [ str , Any ] mkdocs_settings : Dict [ str , Any ] def __init__ ( self , raw : Text = \"\" , dedent = True , page_settings = None , mkdocs_settings = None ): super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) self . raw = raw self . page_settings = page_settings self . mkdocs_settings = mkdocs_settings def req_settings ( self ) -> Settings : return Settings ( page = self . page_settings if self . page_settings is not None else {}, mkdocs = self . mkdocs_settings if self . mkdocs_settings is not None else {}, ) def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( self . raw )","title":"Raw"},{"location":"Reference/mkreports/md/base/#mkreports.md.base.Raw.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/base.py def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( self . raw )","title":"to_markdown()"},{"location":"Reference/mkreports/md/containers/","text":"Admonition ( MdObj ) dataclass Admonition(text: Union[str, ForwardRef('SpacedText'), mkreports.md.base.MdObj], title: Optional[str] = None, kind: Literal['note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote'] = 'note', collapse: bool = False) Source code in mkreports/md/containers.py @dataclass class Admonition ( MdObj ): text : Union [ Text , MdObj ] title : Optional [ str ] = None kind : Literal [ \"note\" , \"abstract\" , \"info\" , \"tip\" , \"success\" , \"question\" , \"warning\" , \"failure\" , \"danger\" , \"bug\" , \"example\" , \"quote\" , ] = \"note\" collapse : bool = False def req_settings ( self ) -> Settings : cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] } ) if isinstance ( self . text , MdObj ): return cont_settings + self . text . req_settings () else : return cont_settings def backmatter ( self , page_path : Optional [ Path ] = None ): if isinstance ( self . text , MdObj ): return self . text . backmatter ( page_path ) else : return SpacedText ( \"\" ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if isinstance ( self . text , MdObj ): admon_text = self . text . to_markdown ( page_path ) else : admon_text = str ( self . text ) if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' return ( SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ), ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )) ) backmatter ( self , page_path = None ) Return the parts of the object required for the backmatter. Source code in mkreports/md/containers.py def backmatter ( self , page_path : Optional [ Path ] = None ): if isinstance ( self . text , MdObj ): return self . text . backmatter ( page_path ) else : return SpacedText ( \"\" ) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if isinstance ( self . text , MdObj ): admon_text = self . text . to_markdown ( page_path ) else : admon_text = str ( self . text ) if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' return ( SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ), ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )) ) Code ( MdObj ) dataclass Wrapper class for code. Source code in mkreports/md/containers.py @dataclass ( frozen = True ) class Code ( MdObj ): \"\"\"Wrapper class for code.\"\"\" code : str title : Optional [ str ] = None first_line : Optional [ int ] = None hl_lines : Optional [ Tuple [ int , int ]] = None language : Optional [ str ] = \"python\" dedent : bool = True def req_settings ( self ): settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) return settings def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' return SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' return SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ) CodeFile ( File ) Code block with the content of a file. Source code in mkreports/md/containers.py class CodeFile ( File ): \"\"\" Code block with the content of a file. \"\"\" def __init__ ( self , path : Path , store_path : Path , report_path : Path , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Move a code-file into the store-dir and reference it in code block. \"\"\" super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) self . report_path = report_path self . title = title self . hl_lines = hl_lines self . language = language def req_settings ( self ): settings = Settings ( mkdocs = dict ( markdown_extensions = \"pymdownx.snippets\" )) settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) return settings def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' return SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( self . report_path ) } '\" , annots ), ( 2 , 2 ), ) __init__ ( self , path , store_path , report_path , title = None , hl_lines = None , language = 'python' ) special Move a code-file into the store-dir and reference it in code block. Source code in mkreports/md/containers.py def __init__ ( self , path : Path , store_path : Path , report_path : Path , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Move a code-file into the store-dir and reference it in code block. \"\"\" super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) self . report_path = report_path self . title = title self . hl_lines = hl_lines self . language = language to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' return SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( self . report_path ) } '\" , annots ), ( 2 , 2 ), ) Tab ( MdObj ) dataclass Tab(text: Union[str, ForwardRef('SpacedText'), mkreports.md.base.MdObj], title: Optional[str] = None) Source code in mkreports/md/containers.py @dataclass class Tab ( MdObj ): text : Union [ Text , MdObj ] title : Optional [ str ] = None def req_settings ( self ) -> Settings : tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . text , MdObj ): return tab_settings + self . text . req_settings () else : return tab_settings def backmatter ( self , page_path : Optional [ Path ] = None ): if isinstance ( self . text , MdObj ): return self . text . backmatter ( page_path ) else : return SpacedText ( \"\" ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if isinstance ( self . text , MdObj ): tab_text = self . text . to_markdown ( page_path ) else : tab_text = str ( self . text ) if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" return SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 ) ) backmatter ( self , page_path = None ) Return the parts of the object required for the backmatter. Source code in mkreports/md/containers.py def backmatter ( self , page_path : Optional [ Path ] = None ): if isinstance ( self . text , MdObj ): return self . text . backmatter ( page_path ) else : return SpacedText ( \"\" ) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if isinstance ( self . text , MdObj ): tab_text = self . text . to_markdown ( page_path ) else : tab_text = str ( self . text ) if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" return SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 ) )","title":"containers"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Admonition","text":"Admonition(text: Union[str, ForwardRef('SpacedText'), mkreports.md.base.MdObj], title: Optional[str] = None, kind: Literal['note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote'] = 'note', collapse: bool = False) Source code in mkreports/md/containers.py @dataclass class Admonition ( MdObj ): text : Union [ Text , MdObj ] title : Optional [ str ] = None kind : Literal [ \"note\" , \"abstract\" , \"info\" , \"tip\" , \"success\" , \"question\" , \"warning\" , \"failure\" , \"danger\" , \"bug\" , \"example\" , \"quote\" , ] = \"note\" collapse : bool = False def req_settings ( self ) -> Settings : cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] } ) if isinstance ( self . text , MdObj ): return cont_settings + self . text . req_settings () else : return cont_settings def backmatter ( self , page_path : Optional [ Path ] = None ): if isinstance ( self . text , MdObj ): return self . text . backmatter ( page_path ) else : return SpacedText ( \"\" ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if isinstance ( self . text , MdObj ): admon_text = self . text . to_markdown ( page_path ) else : admon_text = str ( self . text ) if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' return ( SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ), ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )) )","title":"Admonition"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Admonition.backmatter","text":"Return the parts of the object required for the backmatter. Source code in mkreports/md/containers.py def backmatter ( self , page_path : Optional [ Path ] = None ): if isinstance ( self . text , MdObj ): return self . text . backmatter ( page_path ) else : return SpacedText ( \"\" )","title":"backmatter()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Admonition.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if isinstance ( self . text , MdObj ): admon_text = self . text . to_markdown ( page_path ) else : admon_text = str ( self . text ) if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' return ( SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ), ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )) )","title":"to_markdown()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Code","text":"Wrapper class for code. Source code in mkreports/md/containers.py @dataclass ( frozen = True ) class Code ( MdObj ): \"\"\"Wrapper class for code.\"\"\" code : str title : Optional [ str ] = None first_line : Optional [ int ] = None hl_lines : Optional [ Tuple [ int , int ]] = None language : Optional [ str ] = \"python\" dedent : bool = True def req_settings ( self ): settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) return settings def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' return SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) )","title":"Code"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Code.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' return SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) )","title":"to_markdown()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.CodeFile","text":"Code block with the content of a file. Source code in mkreports/md/containers.py class CodeFile ( File ): \"\"\" Code block with the content of a file. \"\"\" def __init__ ( self , path : Path , store_path : Path , report_path : Path , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Move a code-file into the store-dir and reference it in code block. \"\"\" super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) self . report_path = report_path self . title = title self . hl_lines = hl_lines self . language = language def req_settings ( self ): settings = Settings ( mkdocs = dict ( markdown_extensions = \"pymdownx.snippets\" )) settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) return settings def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' return SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( self . report_path ) } '\" , annots ), ( 2 , 2 ), )","title":"CodeFile"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.CodeFile.__init__","text":"Move a code-file into the store-dir and reference it in code block. Source code in mkreports/md/containers.py def __init__ ( self , path : Path , store_path : Path , report_path : Path , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Move a code-file into the store-dir and reference it in code block. \"\"\" super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) self . report_path = report_path self . title = title self . hl_lines = hl_lines self . language = language","title":"__init__()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.CodeFile.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' return SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( self . report_path ) } '\" , annots ), ( 2 , 2 ), )","title":"to_markdown()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Tab","text":"Tab(text: Union[str, ForwardRef('SpacedText'), mkreports.md.base.MdObj], title: Optional[str] = None) Source code in mkreports/md/containers.py @dataclass class Tab ( MdObj ): text : Union [ Text , MdObj ] title : Optional [ str ] = None def req_settings ( self ) -> Settings : tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . text , MdObj ): return tab_settings + self . text . req_settings () else : return tab_settings def backmatter ( self , page_path : Optional [ Path ] = None ): if isinstance ( self . text , MdObj ): return self . text . backmatter ( page_path ) else : return SpacedText ( \"\" ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if isinstance ( self . text , MdObj ): tab_text = self . text . to_markdown ( page_path ) else : tab_text = str ( self . text ) if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" return SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 ) )","title":"Tab"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Tab.backmatter","text":"Return the parts of the object required for the backmatter. Source code in mkreports/md/containers.py def backmatter ( self , page_path : Optional [ Path ] = None ): if isinstance ( self . text , MdObj ): return self . text . backmatter ( page_path ) else : return SpacedText ( \"\" )","title":"backmatter()"},{"location":"Reference/mkreports/md/containers/#mkreports.md.containers.Tab.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/containers.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : if isinstance ( self . text , MdObj ): tab_text = self . text . to_markdown ( page_path ) else : tab_text = str ( self . text ) if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" return SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 ) )","title":"to_markdown()"},{"location":"Reference/mkreports/md/docstring/","text":"Docstring ( MdObj ) Source code in mkreports/md/docstring.py class Docstring ( MdObj ): def __init__ ( self , obj_name : str ) -> None : super () . __init__ () self . obj_name = obj_name def req_settings ( self ) -> Settings : cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) return cont_settings def to_markdown ( self , page_path : Optional [ Path ] = None ): return SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/docstring.py def to_markdown ( self , page_path : Optional [ Path ] = None ): return SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 ))","title":"docstring"},{"location":"Reference/mkreports/md/docstring/#mkreports.md.docstring.Docstring","text":"Source code in mkreports/md/docstring.py class Docstring ( MdObj ): def __init__ ( self , obj_name : str ) -> None : super () . __init__ () self . obj_name = obj_name def req_settings ( self ) -> Settings : cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) return cont_settings def to_markdown ( self , page_path : Optional [ Path ] = None ): return SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 ))","title":"Docstring"},{"location":"Reference/mkreports/md/docstring/#mkreports.md.docstring.Docstring.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/docstring.py def to_markdown ( self , page_path : Optional [ Path ] = None ): return SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/file/","text":"File ( MdObj ) Source code in mkreports/md/file.py class File ( MdObj ): path : Path allow_copy : bool store_path : Path use_hash : bool _hash : Optional [ str ] = None def __init__ ( self , path : Union [ str , Path ], store_path : Path , allow_copy : bool = True , use_hash : bool = False , ) -> None : super () . __init__ () # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path @property def hash ( self ) -> str : if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( \"\" ) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/file.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( \"\" ) relpath_html ( target , page_path ) Relative path as to be used for html Source code in mkreports/md/file.py def relpath_html ( target : Path , page_path : Path ): \"\"\" Relative path as to be used for html \"\"\" if page_path . stem == \"index\" : # here, for translating to html, this path is referred to as its parent return relpath ( target , page_path . parent ) else : # for translating to html, will be converted to path.parent / path.stem / index.html return relpath ( target , page_path ) true_stem ( path ) True stem of a path, without all suffixes, not just last. Source code in mkreports/md/file.py def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"file"},{"location":"Reference/mkreports/md/file/#mkreports.md.file.File","text":"Source code in mkreports/md/file.py class File ( MdObj ): path : Path allow_copy : bool store_path : Path use_hash : bool _hash : Optional [ str ] = None def __init__ ( self , path : Union [ str , Path ], store_path : Path , allow_copy : bool = True , use_hash : bool = False , ) -> None : super () . __init__ () # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path @property def hash ( self ) -> str : if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( \"\" )","title":"File"},{"location":"Reference/mkreports/md/file/#mkreports.md.file.File.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/file.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : return SpacedText ( \"\" )","title":"to_markdown()"},{"location":"Reference/mkreports/md/file/#mkreports.md.file.relpath_html","text":"Relative path as to be used for html Source code in mkreports/md/file.py def relpath_html ( target : Path , page_path : Path ): \"\"\" Relative path as to be used for html \"\"\" if page_path . stem == \"index\" : # here, for translating to html, this path is referred to as its parent return relpath ( target , page_path . parent ) else : # for translating to html, will be converted to path.parent / path.stem / index.html return relpath ( target , page_path )","title":"relpath_html()"},{"location":"Reference/mkreports/md/file/#mkreports.md.file.true_stem","text":"True stem of a path, without all suffixes, not just last. Source code in mkreports/md/file.py def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"true_stem()"},{"location":"Reference/mkreports/md/header/","text":"Heading ( MdObj ) dataclass Heading(title: str, level: int, style: Literal['atx', 'setext'] = 'atx', anchor: Union[str, mkreports.md.base.Anchor, NoneType] = None) Source code in mkreports/md/header.py @dataclass class Heading ( MdObj ): title : str level : int style : Literal [ \"atx\" , \"setext\" ] = \"atx\" anchor : Optional [ Union [ Anchor , str ]] = None def __post_init__ ( self ): if isinstance ( self . anchor , str ): self . anchor = Anchor ( self . anchor ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . to_markdown ( page_path ) . text return SpacedText ( heading , ( 2 , 2 ), ) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/header.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . to_markdown ( page_path ) . text return SpacedText ( heading , ( 2 , 2 ), )","title":"header"},{"location":"Reference/mkreports/md/header/#mkreports.md.header.Heading","text":"Heading(title: str, level: int, style: Literal['atx', 'setext'] = 'atx', anchor: Union[str, mkreports.md.base.Anchor, NoneType] = None) Source code in mkreports/md/header.py @dataclass class Heading ( MdObj ): title : str level : int style : Literal [ \"atx\" , \"setext\" ] = \"atx\" anchor : Optional [ Union [ Anchor , str ]] = None def __post_init__ ( self ): if isinstance ( self . anchor , str ): self . anchor = Anchor ( self . anchor ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . to_markdown ( page_path ) . text return SpacedText ( heading , ( 2 , 2 ), )","title":"Heading"},{"location":"Reference/mkreports/md/header/#mkreports.md.header.Heading.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/header.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . to_markdown ( page_path ) . text return SpacedText ( heading , ( 2 , 2 ), )","title":"to_markdown()"},{"location":"Reference/mkreports/md/image/","text":"Altair ( File ) Source code in mkreports/md/image.py class Altair ( File ): def __init__ ( self , altair , store_path : Path , altair_id : Union [ str , Callable [[ str ], str ]] = lambda hash : f \"altair- { hash } \" , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"altair.csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) if isinstance ( altair_id , Callable ): self . altair_id = altair_id ( self . hash ) else : self . altair_id = altair_id def req_settings ( self ): settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) return settings def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Set the script tag into backmatter.\"\"\" if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_spec_path = str ( relpath_html ( self . path , page_path )) raw_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { self . altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # note; here we just insert the div. The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . altair_id } '> </div> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) backmatter ( self , page_path ) Set the script tag into backmatter. Source code in mkreports/md/image.py def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Set the script tag into backmatter.\"\"\" if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_spec_path = str ( relpath_html ( self . path , page_path )) raw_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { self . altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) to_markdown ( self , page_path ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # note; here we just insert the div. The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . altair_id } '> </div> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) ImageFile ( File ) Source code in mkreports/md/image.py class ImageFile ( File ): text : str tooltip : str link_type : str def __init__ ( self , path : Union [ str , Path ], store_path : Path , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : super () . __init__ ( path = path , store_path = store_path , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type def to_markdown ( self , page_path : Path ) -> SpacedText : if page_path is None : raise ValueError ( \"Page path cannot be None\" ) if self . link_type == \"inline\" : return SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_path . parent )), tooltip = self . tooltip , ) ) elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" ) to_markdown ( self , page_path ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path ) -> SpacedText : if page_path is None : raise ValueError ( \"Page path cannot be None\" ) if self . link_type == \"inline\" : return SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_path . parent )), tooltip = self . tooltip , ) ) elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" ) Plotly ( File ) Source code in mkreports/md/image.py class Plotly ( File ): def __init__ ( self , plotly , store_path : Path , plotly_id : Union [ str , Callable [[ str ], str ]] = lambda hash : f \"plotly- { hash } \" , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"plotly.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) if isinstance ( plotly_id , Callable ): self . plotly_id = plotly_id ( self . hash ) else : self . plotly_id = plotly_id def req_settings ( self ): settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) return settings def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Set the script tag into backmatter.\"\"\" if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_spec_path = str ( relpath_html ( self . path , page_path )) raw_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { self . plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # note; here we just insert the div. The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . plotly_id } '> </div> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) backmatter ( self , page_path ) Set the script tag into backmatter. Source code in mkreports/md/image.py def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Set the script tag into backmatter.\"\"\" if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_spec_path = str ( relpath_html ( self . path , page_path )) raw_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { self . plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) to_markdown ( self , page_path ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # note; here we just insert the div. The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . plotly_id } '> </div> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"image"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Altair","text":"Source code in mkreports/md/image.py class Altair ( File ): def __init__ ( self , altair , store_path : Path , altair_id : Union [ str , Callable [[ str ], str ]] = lambda hash : f \"altair- { hash } \" , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"altair.csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) if isinstance ( altair_id , Callable ): self . altair_id = altair_id ( self . hash ) else : self . altair_id = altair_id def req_settings ( self ): settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) return settings def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Set the script tag into backmatter.\"\"\" if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_spec_path = str ( relpath_html ( self . path , page_path )) raw_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { self . altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # note; here we just insert the div. The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . altair_id } '> </div> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"Altair"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Altair.backmatter","text":"Set the script tag into backmatter. Source code in mkreports/md/image.py def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Set the script tag into backmatter.\"\"\" if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_spec_path = str ( relpath_html ( self . path , page_path )) raw_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { self . altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"backmatter()"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Altair.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # note; here we just insert the div. The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . altair_id } '> </div> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.ImageFile","text":"Source code in mkreports/md/image.py class ImageFile ( File ): text : str tooltip : str link_type : str def __init__ ( self , path : Union [ str , Path ], store_path : Path , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : super () . __init__ ( path = path , store_path = store_path , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type def to_markdown ( self , page_path : Path ) -> SpacedText : if page_path is None : raise ValueError ( \"Page path cannot be None\" ) if self . link_type == \"inline\" : return SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_path . parent )), tooltip = self . tooltip , ) ) elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" )","title":"ImageFile"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.ImageFile.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path ) -> SpacedText : if page_path is None : raise ValueError ( \"Page path cannot be None\" ) if self . link_type == \"inline\" : return SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_path . parent )), tooltip = self . tooltip , ) ) elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" )","title":"to_markdown()"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Plotly","text":"Source code in mkreports/md/image.py class Plotly ( File ): def __init__ ( self , plotly , store_path : Path , plotly_id : Union [ str , Callable [[ str ], str ]] = lambda hash : f \"plotly- { hash } \" , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"plotly.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) if isinstance ( plotly_id , Callable ): self . plotly_id = plotly_id ( self . hash ) else : self . plotly_id = plotly_id def req_settings ( self ): settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) return settings def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Set the script tag into backmatter.\"\"\" if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_spec_path = str ( relpath_html ( self . path , page_path )) raw_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { self . plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # note; here we just insert the div. The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . plotly_id } '> </div> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"Plotly"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Plotly.backmatter","text":"Set the script tag into backmatter. Source code in mkreports/md/image.py def backmatter ( self , page_path : Optional [ Path ]) -> SpacedText : \"\"\"Set the script tag into backmatter.\"\"\" if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_spec_path = str ( relpath_html ( self . path , page_path )) raw_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { self . plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"backmatter()"},{"location":"Reference/mkreports/md/image/#mkreports.md.image.Plotly.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/image.py def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # note; here we just insert the div. The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . plotly_id } '> </div> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/list/","text":"List ( MdObj ) Source code in mkreports/md/list.py class List ( MdObj ): marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] list : MdSeq def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): super () . __init__ () self . list = MdSeq ( items ) self . marker = marker def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) def __len__ ( self ) -> int : return len ( self . list ) def __add__ ( self , other ) -> \"List\" : raise NotImplementedError ( \"Addition not supported for MdList\" ) def __radd__ ( self , other ) -> \"List\" : raise NotImplementedError ( \"Addition not supported for MdList\" ) def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : # create the markdown output for every item; indent it appropriately # and then put it all together. # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( len ( self ))] else : prefix = [ f \" { self . marker } \" ] * len ( self ) md_list = [ indent_hanging ( elem . to_markdown ( path ) . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] return SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) to_markdown ( self , path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/list.py def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : # create the markdown output for every item; indent it appropriately # and then put it all together. # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( len ( self ))] else : prefix = [ f \" { self . marker } \" ] * len ( self ) md_list = [ indent_hanging ( elem . to_markdown ( path ) . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] return SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 ))","title":"list"},{"location":"Reference/mkreports/md/list/#mkreports.md.list.List","text":"Source code in mkreports/md/list.py class List ( MdObj ): marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] list : MdSeq def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): super () . __init__ () self . list = MdSeq ( items ) self . marker = marker def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) def __len__ ( self ) -> int : return len ( self . list ) def __add__ ( self , other ) -> \"List\" : raise NotImplementedError ( \"Addition not supported for MdList\" ) def __radd__ ( self , other ) -> \"List\" : raise NotImplementedError ( \"Addition not supported for MdList\" ) def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : # create the markdown output for every item; indent it appropriately # and then put it all together. # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( len ( self ))] else : prefix = [ f \" { self . marker } \" ] * len ( self ) md_list = [ indent_hanging ( elem . to_markdown ( path ) . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] return SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 ))","title":"List"},{"location":"Reference/mkreports/md/list/#mkreports.md.list.List.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/list.py def to_markdown ( self , path : Optional [ Path ] = None ) -> SpacedText : # create the markdown output for every item; indent it appropriately # and then put it all together. # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( len ( self ))] else : prefix = [ f \" { self . marker } \" ] * len ( self ) md_list = [ indent_hanging ( elem . to_markdown ( path ) . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] return SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/table/","text":"DataTable ( File ) Source code in mkreports/md/table.py class DataTable ( File ): def __init__ ( self , table : pd . DataFrame , store_path : Path , table_id : Union [ str , Callable [[ str ], str ]] = lambda hash : f \"datatable- { hash } \" , column_settings : Optional [ dict ] = None , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"datatable.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) # use the hashed table name as the id if there is no other if isinstance ( table_id , Callable ): self . table_id = table_id ( self . hash ) else : self . table_id = table_id # prepare the table settings col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } def req_settings ( self ): settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" ], ) ) return settings def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = json . dumps ( table_settings ) raw_html = inspect . cleandoc ( f \"\"\" <table id=' { self . table_id } ' class='display' style='width:100%'> </table> <script> $(document).ready( function () {{ $('# { self . table_id } ').DataTable( { settings_str } ); }} ); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) to_markdown ( self , page_path ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = json . dumps ( table_settings ) raw_html = inspect . cleandoc ( f \"\"\" <table id=' { self . table_id } ' class='display' style='width:100%'> </table> <script> $(document).ready( function () {{ $('# { self . table_id } ').DataTable( { settings_str } ); }} ); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) Table ( MdObj ) Source code in mkreports/md/table.py class Table ( MdObj ): table : pd . DataFrame kwargs : Dict [ str , Any ] def __init__ ( self , table : pd . DataFrame , ** kwargs ): super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" return SpacedText ( table_md , ( 2 , 2 )) to_markdown ( self , page_path = None ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" return SpacedText ( table_md , ( 2 , 2 )) Tabulator ( File ) Source code in mkreports/md/table.py class Tabulator ( File ): def __init__ ( self , table : pd . DataFrame , store_path : Path , table_id : Union [ str , Callable [[ str ], str ]] = lambda hash : f \"tabulator- { hash } \" , column_settings : Optional [ dict ] = None , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"tabulator.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"records\" , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) # use the hashed table name as the id if there is no other if isinstance ( table_id , Callable ): self . table_id = table_id ( self . hash ) else : self . table_id = table_id # prepare the table settings col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . table_settings : Dict [ str , Any ] = dict ( autoColumns = True , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ) def req_settings ( self ): settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) return settings def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) settings_str = json . dumps ( table_settings ) raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . table_id } ' class='display' style='width:100%'> </div> <script> var table = new Tabulator('# { self . table_id } ', { settings_str } ); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 )) to_markdown ( self , page_path ) Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) settings_str = json . dumps ( table_settings ) raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . table_id } ' class='display' style='width:100%'> </div> <script> var table = new Tabulator('# { self . table_id } ', { settings_str } ); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"table"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.DataTable","text":"Source code in mkreports/md/table.py class DataTable ( File ): def __init__ ( self , table : pd . DataFrame , store_path : Path , table_id : Union [ str , Callable [[ str ], str ]] = lambda hash : f \"datatable- { hash } \" , column_settings : Optional [ dict ] = None , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"datatable.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) # use the hashed table name as the id if there is no other if isinstance ( table_id , Callable ): self . table_id = table_id ( self . hash ) else : self . table_id = table_id # prepare the table settings col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } def req_settings ( self ): settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" ], ) ) return settings def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = json . dumps ( table_settings ) raw_html = inspect . cleandoc ( f \"\"\" <table id=' { self . table_id } ' class='display' style='width:100%'> </table> <script> $(document).ready( function () {{ $('# { self . table_id } ').DataTable( { settings_str } ); }} ); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"DataTable"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.DataTable.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = json . dumps ( table_settings ) raw_html = inspect . cleandoc ( f \"\"\" <table id=' { self . table_id } ' class='display' style='width:100%'> </table> <script> $(document).ready( function () {{ $('# { self . table_id } ').DataTable( { settings_str } ); }} ); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.Table","text":"Source code in mkreports/md/table.py class Table ( MdObj ): table : pd . DataFrame kwargs : Dict [ str , Any ] def __init__ ( self , table : pd . DataFrame , ** kwargs ): super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" return SpacedText ( table_md , ( 2 , 2 ))","title":"Table"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.Table.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Optional [ Path ] = None ) -> SpacedText : table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" return SpacedText ( table_md , ( 2 , 2 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.Tabulator","text":"Source code in mkreports/md/table.py class Tabulator ( File ): def __init__ ( self , table : pd . DataFrame , store_path : Path , table_id : Union [ str , Callable [[ str ], str ]] = lambda hash : f \"tabulator- { hash } \" , column_settings : Optional [ dict ] = None , ** kwargs , ): with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"tabulator.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"records\" , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , store_path = store_path , allow_copy = True , use_hash = True ) # use the hashed table name as the id if there is no other if isinstance ( table_id , Callable ): self . table_id = table_id ( self . hash ) else : self . table_id = table_id # prepare the table settings col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . table_settings : Dict [ str , Any ] = dict ( autoColumns = True , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ) def req_settings ( self ): settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) return settings def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) settings_str = json . dumps ( table_settings ) raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . table_id } ' class='display' style='width:100%'> </div> <script> var table = new Tabulator('# { self . table_id } ', { settings_str } ); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"Tabulator"},{"location":"Reference/mkreports/md/table/#mkreports.md.table.Tabulator.to_markdown","text":"Convert the object to markdown. Assumes that all other processing steps are done, such as storing, and counting. Source code in mkreports/md/table.py def to_markdown ( self , page_path : Path ): if page_path is None : raise ValueError ( \"page_path must be set for relative referencing of json data file.\" ) # now we insert the data table on the page # note: as we are inserting directly into html, we have to do one addition # level deeper for the relative path rel_table_path = relpath_html ( self . path , page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) settings_str = json . dumps ( table_settings ) raw_html = inspect . cleandoc ( f \"\"\" <div id=' { self . table_id } ' class='display' style='width:100%'> </div> <script> var table = new Tabulator('# { self . table_id } ', { settings_str } ); </script> \"\"\" ) return SpacedText ( raw_html , ( 2 , 2 ))","title":"to_markdown()"},{"location":"Reference/mkreports/md/text/","text":"SpacedText Representation of text with spaces before or after. Source code in mkreports/md/text.py class SpacedText : \"\"\"Representation of text with spaces before or after.\"\"\" text : str req_nl : Tuple [ int , int ] def __init__ ( self , text : Text , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) def __eq__ ( self , other : Any ) -> bool : if type ( self ) != type ( other ): return False return self . text == other . text and self . req_nl == other . req_nl def __add__ ( self , follow : Text ) -> \"SpacedText\" : return _add_text ( self , SpacedText ( follow )) def __radd__ ( self , precede : Text ) -> \"SpacedText\" : return _add_text ( SpacedText ( precede ), self ) def format_text ( self , precede : Text = \"\" , follow : Text = \"\" ) -> str : add_before = _needed_nl_between ( SpacedText ( precede ), self ) add_after = _needed_nl_between ( self , SpacedText ( follow )) # return with the required additional newlines return ( \" \\n \" * add_before ) + self . text + ( \" \\n \" * add_after ) __str__ ( self ) special Return a formatted str. We assume that 3 newlines are before and after. That should be enough. Source code in mkreports/md/text.py def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) count_newlines ( x , before = True ) Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. Source code in mkreports/md/text.py def count_newlines ( x : str , before = True ) -> int : \"\"\" Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. \"\"\" num_nl = 0 whitespace = [ \" \" , \" \\r \" , \" \\t \" ] y = x if before else reversed ( x ) for ch in y : if ch == \" \\n \" : num_nl += 1 elif ch in whitespace : continue else : return num_nl return num_nl","title":"text"},{"location":"Reference/mkreports/md/text/#mkreports.md.text.SpacedText","text":"Representation of text with spaces before or after. Source code in mkreports/md/text.py class SpacedText : \"\"\"Representation of text with spaces before or after.\"\"\" text : str req_nl : Tuple [ int , int ] def __init__ ( self , text : Text , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) def __eq__ ( self , other : Any ) -> bool : if type ( self ) != type ( other ): return False return self . text == other . text and self . req_nl == other . req_nl def __add__ ( self , follow : Text ) -> \"SpacedText\" : return _add_text ( self , SpacedText ( follow )) def __radd__ ( self , precede : Text ) -> \"SpacedText\" : return _add_text ( SpacedText ( precede ), self ) def format_text ( self , precede : Text = \"\" , follow : Text = \"\" ) -> str : add_before = _needed_nl_between ( SpacedText ( precede ), self ) add_after = _needed_nl_between ( self , SpacedText ( follow )) # return with the required additional newlines return ( \" \\n \" * add_before ) + self . text + ( \" \\n \" * add_after )","title":"SpacedText"},{"location":"Reference/mkreports/md/text/#mkreports.md.text.SpacedText.__str__","text":"Return a formatted str. We assume that 3 newlines are before and after. That should be enough. Source code in mkreports/md/text.py def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" )","title":"__str__()"},{"location":"Reference/mkreports/md/text/#mkreports.md.text.count_newlines","text":"Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. Source code in mkreports/md/text.py def count_newlines ( x : str , before = True ) -> int : \"\"\" Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. \"\"\" num_nl = 0 whitespace = [ \" \" , \" \\r \" , \" \\t \" ] y = x if before else reversed ( x ) for ch in y : if ch == \" \\n \" : num_nl += 1 elif ch in whitespace : continue else : return num_nl return num_nl","title":"count_newlines()"}]}