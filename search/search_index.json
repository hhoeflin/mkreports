{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Purpose of the project Introduction For data analysts, the output of a project is typically a report of the derived results of the dataset, be it an algorithm, the summary of a regression model and the significance of variables or some other sort of requested insight. In order to simplify the writing of such reports, various tools have been invented, the most well known ones being RMarkdown in R and Jupyter that is mostly used with Python (but supports many other languages as well). These tools are incarnations of a Literate Programming , that had its beginnings with tools such as noweb and aims to mix regular text with code in an article, but of course that have been developed much further since then to extend to interactively editing and running code such as in Jupyter, processing entire books (see e.g. bookdown or also inverting the text and code-blocks such that the regular text becomes comments inside a script in e.g. R or Python (see jupytext ). Jupyter and related tools As this package is only for Python, I will focus in the following on aspects of these tools for this language, but some comments are certainly also valid for other frameworks. Jupyter is for sure the most used framework for this purpose with a very large set of tools and users. Since its invention, it has certainly changed how datascience is being done in many organizations. Some of its most noteworthy advantages are: - Deployment through the browser without the need of direct access to hardware. Due to this it is also simpler to have users work with on-demand resources - A good console with outputs of tables and figures that make rapid development easy - Tools such as turning jupyter notebooks into websites - Jupyterlab, which is (almost) a full Python IDE Next to these positive sides are however also a few shortcomings. Shortcomings of Jupyter One of the side-effects of structure of Jupyter-notebooks is their linear form where code and output blocks are mixed, which can cause notebooks to become very large and particular places can be hard to find. Code sharing between notebooks is also not easily possible, requiring to write libraries outside the notebook to fulfill this purpose, mixing very different styles of coding. Also related to their design of one notebook, one html page, parametrization of notebooks can be cumbersome and is certainly not as simple and straightforward as a function. Another drawback is the fact that notebooks hard or impossible to edit in many IDEs, requiring the use of a different environment than the one the scientist is used to. Tools like jupytext can help here, but they still rely on the special interpretation of comments to function properly and inherently still follow the linear form and one file one document view of Jupyter (and pretty much any other Literate Programming approach). Next to these, some more issues are that: - Some debuggers such as pudb are not supported well supported. - Jupytext does not solve the issue that in remote ssh development shells the viewing of graphics can be complicated. - The display options for code and complex tables are limited. This package This package was developed to give an alternative to Jupyter providing more sophisticated ways to create reports while retaining (some) of the interactivity of the browser. All this will be done in pure python without any specially formatted file or overloading of the meaning of any comments. It will further retain the ability to include live code-blocks from the scripts in the output, but less intrusively than for Jupyter notebooks. In particular, it is intended to work by providing functions to easily write out markdown pages that are part of an mkdocs site. For this convenience functions for Figures and Tables as well as other objects are available. For viewing these results, mkdocs is used that contains a development server that automatically watches input files and updates the browser on any change. This update process is typically very fast. Last, a plugin for the ipython console is provided that writes any appropriate output in the console to a special markdown page that can then also be viewed using mkdocs. This way, it is easy to visualize figues and tables from the ipython console, where tables in the browser are sortable or can even be filtered, thus providing better functionality than default Jupyter tables in an output cell.","title":"Home"},{"location":"#purpose-of-the-project","text":"","title":"Purpose of the project"},{"location":"#introduction","text":"For data analysts, the output of a project is typically a report of the derived results of the dataset, be it an algorithm, the summary of a regression model and the significance of variables or some other sort of requested insight. In order to simplify the writing of such reports, various tools have been invented, the most well known ones being RMarkdown in R and Jupyter that is mostly used with Python (but supports many other languages as well). These tools are incarnations of a Literate Programming , that had its beginnings with tools such as noweb and aims to mix regular text with code in an article, but of course that have been developed much further since then to extend to interactively editing and running code such as in Jupyter, processing entire books (see e.g. bookdown or also inverting the text and code-blocks such that the regular text becomes comments inside a script in e.g. R or Python (see jupytext ).","title":"Introduction"},{"location":"#jupyter-and-related-tools","text":"As this package is only for Python, I will focus in the following on aspects of these tools for this language, but some comments are certainly also valid for other frameworks. Jupyter is for sure the most used framework for this purpose with a very large set of tools and users. Since its invention, it has certainly changed how datascience is being done in many organizations. Some of its most noteworthy advantages are: - Deployment through the browser without the need of direct access to hardware. Due to this it is also simpler to have users work with on-demand resources - A good console with outputs of tables and figures that make rapid development easy - Tools such as turning jupyter notebooks into websites - Jupyterlab, which is (almost) a full Python IDE Next to these positive sides are however also a few shortcomings.","title":"Jupyter and related tools"},{"location":"#shortcomings-of-jupyter","text":"One of the side-effects of structure of Jupyter-notebooks is their linear form where code and output blocks are mixed, which can cause notebooks to become very large and particular places can be hard to find. Code sharing between notebooks is also not easily possible, requiring to write libraries outside the notebook to fulfill this purpose, mixing very different styles of coding. Also related to their design of one notebook, one html page, parametrization of notebooks can be cumbersome and is certainly not as simple and straightforward as a function. Another drawback is the fact that notebooks hard or impossible to edit in many IDEs, requiring the use of a different environment than the one the scientist is used to. Tools like jupytext can help here, but they still rely on the special interpretation of comments to function properly and inherently still follow the linear form and one file one document view of Jupyter (and pretty much any other Literate Programming approach). Next to these, some more issues are that: - Some debuggers such as pudb are not supported well supported. - Jupytext does not solve the issue that in remote ssh development shells the viewing of graphics can be complicated. - The display options for code and complex tables are limited.","title":"Shortcomings of Jupyter"},{"location":"#this-package","text":"This package was developed to give an alternative to Jupyter providing more sophisticated ways to create reports while retaining (some) of the interactivity of the browser. All this will be done in pure python without any specially formatted file or overloading of the meaning of any comments. It will further retain the ability to include live code-blocks from the scripts in the output, but less intrusively than for Jupyter notebooks. In particular, it is intended to work by providing functions to easily write out markdown pages that are part of an mkdocs site. For this convenience functions for Figures and Tables as well as other objects are available. For viewing these results, mkdocs is used that contains a development server that automatically watches input files and updates the browser on any change. This update process is typically very fast. Last, a plugin for the ipython console is provided that writes any appropriate output in the console to a special markdown page that can then also be viewed using mkdocs. This way, it is easy to visualize figues and tables from the ipython console, where tables in the browser are sortable or can even be filtered, thus providing better functionality than default Jupyter tables in an output cell.","title":"This package"},{"location":"images/","text":"","title":"Images"},{"location":"quickstart/","text":"Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-1', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-2', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-3', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-4', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-5', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-6', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-7', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-8', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"quickstart/#quickstart_1","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table_1","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-1', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots_1","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"quickstart/#quickstart_2","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table_2","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-2', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots_2","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"quickstart/#quickstart_3","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table_3","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-3', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots_3","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"quickstart/#quickstart_4","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table_4","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-4', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots_4","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"quickstart/#quickstart_5","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table_5","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-5', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots_5","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"quickstart/#quickstart_6","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table_6","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-6', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots_6","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"quickstart/#quickstart_7","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table_7","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-7', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots_7","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"quickstart/#quickstart_8","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table_8","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-8', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots_8","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"Reference/code_context/","text":"Module providing a class and context manager for tracking code. The way of tracking code and displaying it is handled through a context manager, which is the return value obtained when adding an object to a page. The context manager gives different options on how to display the code and the results such as: A code block at the top followed by the output similar to standard jupyter notebooks. A Tab-format where output and code are on separate tabs A collapsed code block followed by the output or the output followed by a collapsed code block. CodeContext Context manager for the code tracking and content accumulation. Source code in mkreports/code_context.py class CodeContext : \"\"\" Context manager for the code tracking and content accumulation. \"\"\" tracker : BaseTracker def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): \"\"\" Initialize the context manager. This should usually not be needed by end users. Args: layout (Layouts): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. relative_to (Optional[Path]): Path relative to where the code file will be named. name_only (bool): For the code file, use name instead of path? add_bottom (bool): Should content be added to bottom or top of page? stack_level (int): Levels lower in the stack where the code is to be tracked. \"\"\" self . layout : Layouts = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only self . _active = False def __enter__ ( self ) -> \"CodeContext\" : if self . do_tracking : self . tracker . start ( inspect . stack ()[ self . stack_level ]) self . _active = True return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : del exc_type , exc_val , traceback self . _active = False if self . do_tracking : self . tracker . stop ( inspect . stack ()[ self . stack_level ]) @property def active ( self ): \"\"\"Indicates if the context-manager is active.\"\"\" return self . _active def add ( self , md_obj : MdObj ) -> None : \"\"\" Add a new content object. Args: md_obj (MdObj): The content to be added. \"\"\" if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj ) def md_obj ( self , page_info : PageInfo ) -> MdObj : \"\"\" Return the markdown object that represents output and code. Args: page_info (PageInfo): PageInfo object about the page where the content is to be added. Returns: MdObj: Markdown object representing the formatted output in the requested layout \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : code_final = None else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] return do_layout ( code = code_final , content = content , page_info = page_info , layout = self . layout ) active property readonly Indicates if the context-manager is active. __init__ ( self , layout , relative_to = None , name_only = False , add_bottom = True , stack_level = 2 ) special Initialize the context manager. This should usually not be needed by end users. Parameters: Name Type Description Default layout Layouts The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. required relative_to Optional[Path] Path relative to where the code file will be named. None name_only bool For the code file, use name instead of path? False add_bottom bool Should content be added to bottom or top of page? True stack_level int Levels lower in the stack where the code is to be tracked. 2 Source code in mkreports/code_context.py def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): \"\"\" Initialize the context manager. This should usually not be needed by end users. Args: layout (Layouts): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. relative_to (Optional[Path]): Path relative to where the code file will be named. name_only (bool): For the code file, use name instead of path? add_bottom (bool): Should content be added to bottom or top of page? stack_level (int): Levels lower in the stack where the code is to be tracked. \"\"\" self . layout : Layouts = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only self . _active = False add ( self , md_obj ) Add a new content object. Parameters: Name Type Description Default md_obj MdObj The content to be added. required Source code in mkreports/code_context.py def add ( self , md_obj : MdObj ) -> None : \"\"\" Add a new content object. Args: md_obj (MdObj): The content to be added. \"\"\" if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj ) md_obj ( self , page_info ) Return the markdown object that represents output and code. Parameters: Name Type Description Default page_info PageInfo PageInfo object about the page where the content is to be added. required Returns: Type Description MdObj Markdown object representing the formatted output in the requested layout Source code in mkreports/code_context.py def md_obj ( self , page_info : PageInfo ) -> MdObj : \"\"\" Return the markdown object that represents output and code. Args: page_info (PageInfo): PageInfo object about the page where the content is to be added. Returns: MdObj: Markdown object representing the formatted output in the requested layout \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : code_final = None else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] return do_layout ( code = code_final , content = content , page_info = page_info , layout = self . layout ) do_layout ( code , content , layout , page_info ) Do the layouting for a content and code block. Parameters: Name Type Description Default code Optional[MdObj] The MdObj for the code. If layout is 'nocode', can be None. required content MdObj The content to add. Can't be missing. required layout Layouts Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. required page_info PageInfo PageInfo object corresponding to the page to which it should be added. required Returns: Type Description MdObj A MdObj with the requested layout. Source code in mkreports/code_context.py def do_layout ( code : Optional [ MdObj ], content : MdObj , layout : Layouts , page_info : PageInfo ) -> MdObj : \"\"\" Do the layouting for a content and code block. Args: code (Optional[MdObj]): The MdObj for the code. If layout is 'nocode', can be None. content (MdObj): The content to add. Can't be missing. layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. page_info (PageInfo): PageInfo object corresponding to the page to which it should be added. Returns: A MdObj with the requested layout. \"\"\" if layout == \"nocode\" : return content else : assert code is not None if layout == \"top-c\" : return ( Admonition ( code , page_info = page_info , collapse = True , title = \"Code\" , kind = \"code\" , ) + content + HLine () ) elif layout == \"top-o\" : return code + content + HLine () elif layout == \"bottom-c\" : return ( content + Admonition ( code , page_info = page_info , collapse = True , title = \"Code\" , kind = \"code\" , ) + HLine () ) elif layout == \"bottom-o\" : return content + code + HLine () elif layout == \"tabbed\" : return Tab ( content , title = \"Content\" ) + Tab ( code , title = \"Code\" ) + HLine () else : raise Exception ( \"Unknown layout type.\" )","title":"code_context"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext","text":"Context manager for the code tracking and content accumulation. Source code in mkreports/code_context.py class CodeContext : \"\"\" Context manager for the code tracking and content accumulation. \"\"\" tracker : BaseTracker def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): \"\"\" Initialize the context manager. This should usually not be needed by end users. Args: layout (Layouts): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. relative_to (Optional[Path]): Path relative to where the code file will be named. name_only (bool): For the code file, use name instead of path? add_bottom (bool): Should content be added to bottom or top of page? stack_level (int): Levels lower in the stack where the code is to be tracked. \"\"\" self . layout : Layouts = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only self . _active = False def __enter__ ( self ) -> \"CodeContext\" : if self . do_tracking : self . tracker . start ( inspect . stack ()[ self . stack_level ]) self . _active = True return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : del exc_type , exc_val , traceback self . _active = False if self . do_tracking : self . tracker . stop ( inspect . stack ()[ self . stack_level ]) @property def active ( self ): \"\"\"Indicates if the context-manager is active.\"\"\" return self . _active def add ( self , md_obj : MdObj ) -> None : \"\"\" Add a new content object. Args: md_obj (MdObj): The content to be added. \"\"\" if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj ) def md_obj ( self , page_info : PageInfo ) -> MdObj : \"\"\" Return the markdown object that represents output and code. Args: page_info (PageInfo): PageInfo object about the page where the content is to be added. Returns: MdObj: Markdown object representing the formatted output in the requested layout \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : code_final = None else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] return do_layout ( code = code_final , content = content , page_info = page_info , layout = self . layout )","title":"CodeContext"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext.active","text":"Indicates if the context-manager is active.","title":"active"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext.__init__","text":"Initialize the context manager. This should usually not be needed by end users. Parameters: Name Type Description Default layout Layouts The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. required relative_to Optional[Path] Path relative to where the code file will be named. None name_only bool For the code file, use name instead of path? False add_bottom bool Should content be added to bottom or top of page? True stack_level int Levels lower in the stack where the code is to be tracked. 2 Source code in mkreports/code_context.py def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): \"\"\" Initialize the context manager. This should usually not be needed by end users. Args: layout (Layouts): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. relative_to (Optional[Path]): Path relative to where the code file will be named. name_only (bool): For the code file, use name instead of path? add_bottom (bool): Should content be added to bottom or top of page? stack_level (int): Levels lower in the stack where the code is to be tracked. \"\"\" self . layout : Layouts = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only self . _active = False","title":"__init__()"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext.add","text":"Add a new content object. Parameters: Name Type Description Default md_obj MdObj The content to be added. required Source code in mkreports/code_context.py def add ( self , md_obj : MdObj ) -> None : \"\"\" Add a new content object. Args: md_obj (MdObj): The content to be added. \"\"\" if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj )","title":"add()"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext.md_obj","text":"Return the markdown object that represents output and code. Parameters: Name Type Description Default page_info PageInfo PageInfo object about the page where the content is to be added. required Returns: Type Description MdObj Markdown object representing the formatted output in the requested layout Source code in mkreports/code_context.py def md_obj ( self , page_info : PageInfo ) -> MdObj : \"\"\" Return the markdown object that represents output and code. Args: page_info (PageInfo): PageInfo object about the page where the content is to be added. Returns: MdObj: Markdown object representing the formatted output in the requested layout \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : code_final = None else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] return do_layout ( code = code_final , content = content , page_info = page_info , layout = self . layout )","title":"md_obj()"},{"location":"Reference/code_context/#mkreports.code_context.do_layout","text":"Do the layouting for a content and code block. Parameters: Name Type Description Default code Optional[MdObj] The MdObj for the code. If layout is 'nocode', can be None. required content MdObj The content to add. Can't be missing. required layout Layouts Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. required page_info PageInfo PageInfo object corresponding to the page to which it should be added. required Returns: Type Description MdObj A MdObj with the requested layout. Source code in mkreports/code_context.py def do_layout ( code : Optional [ MdObj ], content : MdObj , layout : Layouts , page_info : PageInfo ) -> MdObj : \"\"\" Do the layouting for a content and code block. Args: code (Optional[MdObj]): The MdObj for the code. If layout is 'nocode', can be None. content (MdObj): The content to add. Can't be missing. layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. page_info (PageInfo): PageInfo object corresponding to the page to which it should be added. Returns: A MdObj with the requested layout. \"\"\" if layout == \"nocode\" : return content else : assert code is not None if layout == \"top-c\" : return ( Admonition ( code , page_info = page_info , collapse = True , title = \"Code\" , kind = \"code\" , ) + content + HLine () ) elif layout == \"top-o\" : return code + content + HLine () elif layout == \"bottom-c\" : return ( content + Admonition ( code , page_info = page_info , collapse = True , title = \"Code\" , kind = \"code\" , ) + HLine () ) elif layout == \"bottom-o\" : return content + code + HLine () elif layout == \"tabbed\" : return Tab ( content , title = \"Content\" ) + Tab ( code , title = \"Code\" ) + HLine () else : raise Exception ( \"Unknown layout type.\" )","title":"do_layout()"},{"location":"Reference/docs/","text":"add_pkg_docs ( pkg_path , parent_name , report , omit_package_name = False ) Add docstrings of the object to the report Parameters: Name Type Description Default pkg_path Path Path of the package for which to add the docs. required parent_name Union[NavEntry, Path, str] Name under which it should be added in the Navigation. required report Report the report to which it should be added. required omit_package_name bool Should the package-name be omitted in the nav? False Source code in mkreports/docs.py def add_pkg_docs ( pkg_path : Path , parent_name : Union [ NavEntry , Path , str ], report : Report , omit_package_name : bool = False , ): \"\"\" Add docstrings of the object to the report Args: pkg_path (Path): Path of the package for which to add the docs. parent_name (Union[NavEntry, Path, str]): Name under which it should be added in the Navigation. report (Report): the report to which it should be added. omit_package_name (bool): Should the package-name be omitted in the nav? \"\"\" # we need the parent name as a nav_entry if isinstance ( parent_name , str ): parent_name = Path ( parent_name ) if isinstance ( parent_name , Path ): parent_name = path_to_nav_entry ( parent_name ) # now iterate through all python entries for path in sorted ( pkg_path . glob ( \"**/*.py\" )): module_path = path . relative_to ( pkg_path . parent ) . with_suffix ( \"\" ) if module_path . name . startswith ( \"_\" ): continue else : if omit_package_name : nav_module_path = Path ( * module_path . parts [ 1 :]) else : nav_module_path = module_path # now create the new nav_entry for this page module_nav_entry = NavEntry ( tuple ( parent_name [ 0 ]) + tuple ( nav_module_path . parts ), ( parent_name [ 1 ] / nav_module_path ) . with_suffix ( \".md\" ), ) # now create a new page and add the doc-entry page = report . page ( module_nav_entry , truncate = True ) page . add ( page . md . Docstring ( \".\" . join ( module_path . parts )))","title":"docs"},{"location":"Reference/docs/#mkreports.docs.add_pkg_docs","text":"Add docstrings of the object to the report Parameters: Name Type Description Default pkg_path Path Path of the package for which to add the docs. required parent_name Union[NavEntry, Path, str] Name under which it should be added in the Navigation. required report Report the report to which it should be added. required omit_package_name bool Should the package-name be omitted in the nav? False Source code in mkreports/docs.py def add_pkg_docs ( pkg_path : Path , parent_name : Union [ NavEntry , Path , str ], report : Report , omit_package_name : bool = False , ): \"\"\" Add docstrings of the object to the report Args: pkg_path (Path): Path of the package for which to add the docs. parent_name (Union[NavEntry, Path, str]): Name under which it should be added in the Navigation. report (Report): the report to which it should be added. omit_package_name (bool): Should the package-name be omitted in the nav? \"\"\" # we need the parent name as a nav_entry if isinstance ( parent_name , str ): parent_name = Path ( parent_name ) if isinstance ( parent_name , Path ): parent_name = path_to_nav_entry ( parent_name ) # now iterate through all python entries for path in sorted ( pkg_path . glob ( \"**/*.py\" )): module_path = path . relative_to ( pkg_path . parent ) . with_suffix ( \"\" ) if module_path . name . startswith ( \"_\" ): continue else : if omit_package_name : nav_module_path = Path ( * module_path . parts [ 1 :]) else : nav_module_path = module_path # now create the new nav_entry for this page module_nav_entry = NavEntry ( tuple ( parent_name [ 0 ]) + tuple ( nav_module_path . parts ), ( parent_name [ 1 ] / nav_module_path ) . with_suffix ( \".md\" ), ) # now create a new page and add the doc-entry page = report . page ( module_nav_entry , truncate = True ) page . add ( page . md . Docstring ( \".\" . join ( module_path . parts )))","title":"add_pkg_docs()"},{"location":"Reference/exceptions/","text":"All Exception classes that we are using in the package. CannotTrackError ( Exception ) Tracking is not possible. Source code in mkreports/exceptions.py class CannotTrackError ( Exception ): \"\"\"Tracking is not possible.\"\"\" pass ContextActiveError ( Exception ) The code-context is active and it should not be. Source code in mkreports/exceptions.py class ContextActiveError ( Exception ): \"\"\"The code-context is active and it should not be.\"\"\" pass IncorrectSuffixError ( Exception ) An incorrect suffix was given. Source code in mkreports/exceptions.py class IncorrectSuffixError ( Exception ): \"\"\"An incorrect suffix was given.\"\"\" pass PageNotExistsError ( Exception ) The page does not exist. Source code in mkreports/exceptions.py class PageNotExistsError ( Exception ): \"\"\"The page does not exist.\"\"\" pass ReportExistsError ( Exception ) Report already exists. Source code in mkreports/exceptions.py class ReportExistsError ( Exception ): \"\"\"Report already exists.\"\"\" pass ReportNotExistsError ( Exception ) The given path for a report does not exist. Source code in mkreports/exceptions.py class ReportNotExistsError ( Exception ): \"\"\"The given path for a report does not exist.\"\"\" pass ReportNotValidError ( Exception ) The given path does not represent a valid report. Source code in mkreports/exceptions.py class ReportNotValidError ( Exception ): \"\"\"The given path does not represent a valid report.\"\"\" pass TrackerActiveError ( Exception ) The tracker is active and it should not be. Source code in mkreports/exceptions.py class TrackerActiveError ( Exception ): \"\"\"The tracker is active and it should not be.\"\"\" pass TrackerEmptyError ( Exception ) The tracker is empty. Source code in mkreports/exceptions.py class TrackerEmptyError ( Exception ): \"\"\"The tracker is empty.\"\"\" pass TrackerIncompleteError ( Exception ) The tracker has not yet completed. Source code in mkreports/exceptions.py class TrackerIncompleteError ( Exception ): \"\"\"The tracker has not yet completed.\"\"\" pass TrackerNotActiveError ( Exception ) The tracker is not active and it should be active. Source code in mkreports/exceptions.py class TrackerNotActiveError ( Exception ): \"\"\"The tracker is not active and it should be active.\"\"\" pass","title":"exceptions"},{"location":"Reference/exceptions/#mkreports.exceptions.CannotTrackError","text":"Tracking is not possible. Source code in mkreports/exceptions.py class CannotTrackError ( Exception ): \"\"\"Tracking is not possible.\"\"\" pass","title":"CannotTrackError"},{"location":"Reference/exceptions/#mkreports.exceptions.ContextActiveError","text":"The code-context is active and it should not be. Source code in mkreports/exceptions.py class ContextActiveError ( Exception ): \"\"\"The code-context is active and it should not be.\"\"\" pass","title":"ContextActiveError"},{"location":"Reference/exceptions/#mkreports.exceptions.IncorrectSuffixError","text":"An incorrect suffix was given. Source code in mkreports/exceptions.py class IncorrectSuffixError ( Exception ): \"\"\"An incorrect suffix was given.\"\"\" pass","title":"IncorrectSuffixError"},{"location":"Reference/exceptions/#mkreports.exceptions.PageNotExistsError","text":"The page does not exist. Source code in mkreports/exceptions.py class PageNotExistsError ( Exception ): \"\"\"The page does not exist.\"\"\" pass","title":"PageNotExistsError"},{"location":"Reference/exceptions/#mkreports.exceptions.ReportExistsError","text":"Report already exists. Source code in mkreports/exceptions.py class ReportExistsError ( Exception ): \"\"\"Report already exists.\"\"\" pass","title":"ReportExistsError"},{"location":"Reference/exceptions/#mkreports.exceptions.ReportNotExistsError","text":"The given path for a report does not exist. Source code in mkreports/exceptions.py class ReportNotExistsError ( Exception ): \"\"\"The given path for a report does not exist.\"\"\" pass","title":"ReportNotExistsError"},{"location":"Reference/exceptions/#mkreports.exceptions.ReportNotValidError","text":"The given path does not represent a valid report. Source code in mkreports/exceptions.py class ReportNotValidError ( Exception ): \"\"\"The given path does not represent a valid report.\"\"\" pass","title":"ReportNotValidError"},{"location":"Reference/exceptions/#mkreports.exceptions.TrackerActiveError","text":"The tracker is active and it should not be. Source code in mkreports/exceptions.py class TrackerActiveError ( Exception ): \"\"\"The tracker is active and it should not be.\"\"\" pass","title":"TrackerActiveError"},{"location":"Reference/exceptions/#mkreports.exceptions.TrackerEmptyError","text":"The tracker is empty. Source code in mkreports/exceptions.py class TrackerEmptyError ( Exception ): \"\"\"The tracker is empty.\"\"\" pass","title":"TrackerEmptyError"},{"location":"Reference/exceptions/#mkreports.exceptions.TrackerIncompleteError","text":"The tracker has not yet completed. Source code in mkreports/exceptions.py class TrackerIncompleteError ( Exception ): \"\"\"The tracker has not yet completed.\"\"\" pass","title":"TrackerIncompleteError"},{"location":"Reference/exceptions/#mkreports.exceptions.TrackerNotActiveError","text":"The tracker is not active and it should be active. Source code in mkreports/exceptions.py class TrackerNotActiveError ( Exception ): \"\"\"The tracker is not active and it should be active.\"\"\" pass","title":"TrackerNotActiveError"},{"location":"Reference/ipython/","text":"ConsoleWriter ( Magics ) Class that connects IPython with mkreports using magics. Source code in mkreports/ipython.py @magics_class class ConsoleWriter ( Magics ): \"\"\" Class that connects IPython with mkreports using magics. \"\"\" handlers : List [ Handler ] console : Page def __init__ ( self , ip ): \"\"\"Initialization. Not for end-users.\"\"\" super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] self . _set_default_handlers () # identify an mkreport if \"MKREPORTS_DIR\" in os . environ : self . report = Report . create ( os . environ [ \"MKREPORTS_DIR\" ], report_name = \"Mkreports console\" , exist_ok = True , ) self . _open_console () else : raise Exception ( \"No 'MKREPORTS_DIR' in environment\" ) def _set_default_handlers ( self ): self . handlers = [] # handler for tables with suppress ( ImportError ): import pandas as pd self . handlers . append ( Handler ( name = \"datatable\" , class_type = pd . DataFrame , func = lambda x : self . console . md . DataTable ( x ), ) ) # handler for matplotlib with suppress ( ImportError ): from matplotlib.figure import Figure as MplFigure self . handlers . append ( Handler ( name = \"matplotlib\" , class_type = MplFigure , func = lambda x : self . console . md . Image ( x ), ) ) with suppress ( ImportError ): from plotnine.ggplot import ggplot self . handlers . append ( Handler ( name = \"plotnine\" , class_type = ggplot , func = lambda x : self . console . md . Image ( x ), ) ) with suppress ( ImportError ): from seaborn import FacetGrid as SnsFacetGrid from seaborn import JointGrid as SnsJointGrid from seaborn import PairGrid as SnsPairGrid self . handlers . append ( Handler ( name = \"seaborn\" , class_type = ( SnsFacetGrid , SnsJointGrid , SnsPairGrid ), func = lambda x : self . console . md . Image ( x ), ) ) self . handlers . append ( Handler ( name = \"mdobj\" , class_type = md . MdObj , func = lambda x : x ) ) def _get_handler ( self , obj : Any ) -> Optional [ Handler ]: for handler in self . handlers : if isinstance ( obj , handler . class_type ): return handler else : return None def _open_console ( self ) -> None : self . console = self . report . page ( Path ( \"console/active.md\" ), add_bottom = False ) # make sure the table of contents does not get shown self . console . HideToc () @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. Args: line (str): ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . _open_console () def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . _get_handler ( result . result ) if handler is not None : content = handler . func ( result . result ) code = md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ) code_content = do_layout ( code = code , content = content , layout = self . console . code_layout , page_info = self . console . page_info , ) # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + code_content ) self . console . add ( post ) self . stored_code = [] __init__ ( self , ip ) special Initialization. Not for end-users. Source code in mkreports/ipython.py def __init__ ( self , ip ): \"\"\"Initialization. Not for end-users.\"\"\" super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] self . _set_default_handlers () # identify an mkreport if \"MKREPORTS_DIR\" in os . environ : self . report = Report . create ( os . environ [ \"MKREPORTS_DIR\" ], report_name = \"Mkreports console\" , exist_ok = True , ) self . _open_console () else : raise Exception ( \"No 'MKREPORTS_DIR' in environment\" ) archive_console ( self , line ) Function to archive the console. This is also a line magic, however the line itself will be ignored. Parameters: Name Type Description Default line str ignored. required Source code in mkreports/ipython.py @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. Args: line (str): ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . _open_console () post_run_cell ( self , result ) Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. Source code in mkreports/ipython.py def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . _get_handler ( result . result ) if handler is not None : content = handler . func ( result . result ) code = md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ) code_content = do_layout ( code = code , content = content , layout = self . console . code_layout , page_info = self . console . page_info , ) # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + code_content ) self . console . add ( post ) self . stored_code = [] Handler dataclass A handler for output. Parameters: Name Type Description Default name str Name of the handler. required class_type Union[type, Tuple[type, ...]] Classes covered by the handler. required func Callable the function to use to handle the output. required Source code in mkreports/ipython.py @dataclass class Handler : \"\"\" A handler for output. Args: name (str): Name of the handler. class_type (Union[type, Tuple[type, ...]]): Classes covered by the handler. func (Callable): the function to use to handle the output. \"\"\" name : str class_type : Union [ type , Tuple [ type , ... ]] func : Callable load_ipython_extension ( ip ) Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. Source code in mkreports/ipython.py def load_ipython_extension ( ip ): \"\"\" Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. \"\"\" cw = ConsoleWriter ( ip ) cw . shell . push ({ \"md\" : cw . console . md , \"cons\" : cw . console }) ip . events . register ( \"post_run_cell\" , cw . post_run_cell ) ip . register_magics ( cw )","title":"ipython"},{"location":"Reference/ipython/#mkreports.ipython.ConsoleWriter","text":"Class that connects IPython with mkreports using magics. Source code in mkreports/ipython.py @magics_class class ConsoleWriter ( Magics ): \"\"\" Class that connects IPython with mkreports using magics. \"\"\" handlers : List [ Handler ] console : Page def __init__ ( self , ip ): \"\"\"Initialization. Not for end-users.\"\"\" super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] self . _set_default_handlers () # identify an mkreport if \"MKREPORTS_DIR\" in os . environ : self . report = Report . create ( os . environ [ \"MKREPORTS_DIR\" ], report_name = \"Mkreports console\" , exist_ok = True , ) self . _open_console () else : raise Exception ( \"No 'MKREPORTS_DIR' in environment\" ) def _set_default_handlers ( self ): self . handlers = [] # handler for tables with suppress ( ImportError ): import pandas as pd self . handlers . append ( Handler ( name = \"datatable\" , class_type = pd . DataFrame , func = lambda x : self . console . md . DataTable ( x ), ) ) # handler for matplotlib with suppress ( ImportError ): from matplotlib.figure import Figure as MplFigure self . handlers . append ( Handler ( name = \"matplotlib\" , class_type = MplFigure , func = lambda x : self . console . md . Image ( x ), ) ) with suppress ( ImportError ): from plotnine.ggplot import ggplot self . handlers . append ( Handler ( name = \"plotnine\" , class_type = ggplot , func = lambda x : self . console . md . Image ( x ), ) ) with suppress ( ImportError ): from seaborn import FacetGrid as SnsFacetGrid from seaborn import JointGrid as SnsJointGrid from seaborn import PairGrid as SnsPairGrid self . handlers . append ( Handler ( name = \"seaborn\" , class_type = ( SnsFacetGrid , SnsJointGrid , SnsPairGrid ), func = lambda x : self . console . md . Image ( x ), ) ) self . handlers . append ( Handler ( name = \"mdobj\" , class_type = md . MdObj , func = lambda x : x ) ) def _get_handler ( self , obj : Any ) -> Optional [ Handler ]: for handler in self . handlers : if isinstance ( obj , handler . class_type ): return handler else : return None def _open_console ( self ) -> None : self . console = self . report . page ( Path ( \"console/active.md\" ), add_bottom = False ) # make sure the table of contents does not get shown self . console . HideToc () @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. Args: line (str): ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . _open_console () def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . _get_handler ( result . result ) if handler is not None : content = handler . func ( result . result ) code = md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ) code_content = do_layout ( code = code , content = content , layout = self . console . code_layout , page_info = self . console . page_info , ) # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + code_content ) self . console . add ( post ) self . stored_code = []","title":"ConsoleWriter"},{"location":"Reference/ipython/#mkreports.ipython.ConsoleWriter.__init__","text":"Initialization. Not for end-users. Source code in mkreports/ipython.py def __init__ ( self , ip ): \"\"\"Initialization. Not for end-users.\"\"\" super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] self . _set_default_handlers () # identify an mkreport if \"MKREPORTS_DIR\" in os . environ : self . report = Report . create ( os . environ [ \"MKREPORTS_DIR\" ], report_name = \"Mkreports console\" , exist_ok = True , ) self . _open_console () else : raise Exception ( \"No 'MKREPORTS_DIR' in environment\" )","title":"__init__()"},{"location":"Reference/ipython/#mkreports.ipython.ConsoleWriter.archive_console","text":"Function to archive the console. This is also a line magic, however the line itself will be ignored. Parameters: Name Type Description Default line str ignored. required Source code in mkreports/ipython.py @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. Args: line (str): ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( self . console . path , new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . _open_console ()","title":"archive_console()"},{"location":"Reference/ipython/#mkreports.ipython.ConsoleWriter.post_run_cell","text":"Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. Source code in mkreports/ipython.py def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . _get_handler ( result . result ) if handler is not None : content = handler . func ( result . result ) code = md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ) code_content = do_layout ( code = code , content = content , layout = self . console . code_layout , page_info = self . console . page_info , ) # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + code_content ) self . console . add ( post ) self . stored_code = []","title":"post_run_cell()"},{"location":"Reference/ipython/#mkreports.ipython.Handler","text":"A handler for output. Parameters: Name Type Description Default name str Name of the handler. required class_type Union[type, Tuple[type, ...]] Classes covered by the handler. required func Callable the function to use to handle the output. required Source code in mkreports/ipython.py @dataclass class Handler : \"\"\" A handler for output. Args: name (str): Name of the handler. class_type (Union[type, Tuple[type, ...]]): Classes covered by the handler. func (Callable): the function to use to handle the output. \"\"\" name : str class_type : Union [ type , Tuple [ type , ... ]] func : Callable","title":"Handler"},{"location":"Reference/ipython/#mkreports.ipython.load_ipython_extension","text":"Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. Source code in mkreports/ipython.py def load_ipython_extension ( ip ): \"\"\" Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. \"\"\" cw = ConsoleWriter ( ip ) cw . shell . push ({ \"md\" : cw . console . md , \"cons\" : cw . console }) ip . events . register ( \"post_run_cell\" , cw . post_run_cell ) ip . register_magics ( cw )","title":"load_ipython_extension()"},{"location":"Reference/parser/","text":"A simple class to provide access to full extent of statements with starting and ending lines. closest_after ( tree , lineno ) Return the closest item strictly before lineno. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional[Interval] An interval representing closest statement after the line if there is a statement after. Source code in mkreports/parser.py def closest_after ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval representing closest statement after the line if there is a statement after. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line # rest by difference to current line after_list = [ x for x in tree_list if ( x . begin > lineno )] after_list . sort ( key = lambda x : x . begin - lineno ) if len ( after_list ) > 0 : return after_list [ 0 ] else : return None closest_before ( tree , lineno ) Return the closest item strictly before lineno. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional[Interval] An interval representing closest statement before the line if there is a statement before. Source code in mkreports/parser.py def closest_before ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval representing closest statement before the line if there is a statement before. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line before_list = [ x for x in tree_list if ( x . begin < lineno )] before_list . sort ( key = lambda x : lineno - x . begin ) if len ( before_list ) > 0 : return before_list [ 0 ] else : return None envelope ( tree , pos ) Interval that covers the given interval (i.e. is larger). Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required pos Interval Interval to cover. required Returns: Type Description Optional[Interval] The next largest interval covering the current one, if there is one, otherwise None. Source code in mkreports/parser.py def envelope ( tree : IntervalTree , pos : Interval ) -> Optional [ Interval ]: \"\"\" Interval that covers the given interval (i.e. is larger). Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. pos (Interval): Interval to cover. Returns: Optional[Interval]: The next largest interval covering the current one, if there is one, otherwise None. \"\"\" tree_list = list ( tree . envelop ( pos . begin - 1 , pos . end )) if len ( tree_list ) == 0 : return None else : tree_list . sort ( key = lambda x : x . end - x . begin ) return tree_list [ 0 ] get_neighbors ( tree , lineno ) For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Parameters: Name Type Description Default tree IntervalTree required lineno int required Returns: Type Description (Optional[Interval], Optional[Interval], Optional[Interval]) Interval of statement before the line, covering the current line and the next statement. Source code in mkreports/parser.py def get_neighbors ( tree : IntervalTree , lineno : int ) -> Tuple [ Optional [ Interval ], Optional [ Interval ], Optional [ Interval ]]: \"\"\" For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Args: tree (IntervalTree): lineno (int): Returns: (Optional[Interval], Optional[Interval], Optional[Interval]): Interval of statement before the line, covering the current line and the next statement. \"\"\" return ( closest_before ( tree , lineno ), smallest_overlap ( tree , lineno ), closest_after ( tree , lineno ), ) get_stmt_ranges ( pyfile ) Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Parameters: Name Type Description Default pyfile Path Path to the python file to analyze. required Returns: Type Description IntervallTree An object representing the hierarchical intervals of the statements in the file. Source code in mkreports/parser.py def get_stmt_ranges ( pyfile : Path ) -> IntervalTree : \"\"\" Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Args: pyfile (Path): Path to the python file to analyze. Returns: IntervallTree: An object representing the hierarchical intervals of the statements in the file. \"\"\" # first we parse the python file into an AST with pyfile . open ( \"r\" ) as f : file_ast = ast . parse ( f . read ()) inttree = IntervalTree () # now we want to walk along the tree and get the line extent of # all nodes that are statements; as data payload we attach # the parsed nodes for node in ast . walk ( file_ast ): if isinstance ( node , ast . stmt ): if node . lineno is not None and node . end_lineno is not None : inttree . add ( Interval ( begin = node . lineno , end = node . end_lineno + 1 , data = node ) ) return inttree smallest_overlap ( tree , lineno ) Find the closest match that overlaps and is shortests. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional[Interval] An interval if there is a statement at the line. Source code in mkreports/parser.py def smallest_overlap ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Find the closest match that overlaps and is shortests. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval if there is a statement at the line. \"\"\" overlap_set = tree . at ( lineno ) if len ( overlap_set ) > 0 : # we take the shortest overlap_list = list ( overlap_set ) overlap_list . sort ( key = lambda x : x . end - x . begin ) return overlap_list [ 0 ] else : return None","title":"parser"},{"location":"Reference/parser/#mkreports.parser.closest_after","text":"Return the closest item strictly before lineno. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional[Interval] An interval representing closest statement after the line if there is a statement after. Source code in mkreports/parser.py def closest_after ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval representing closest statement after the line if there is a statement after. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line # rest by difference to current line after_list = [ x for x in tree_list if ( x . begin > lineno )] after_list . sort ( key = lambda x : x . begin - lineno ) if len ( after_list ) > 0 : return after_list [ 0 ] else : return None","title":"closest_after()"},{"location":"Reference/parser/#mkreports.parser.closest_before","text":"Return the closest item strictly before lineno. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional[Interval] An interval representing closest statement before the line if there is a statement before. Source code in mkreports/parser.py def closest_before ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval representing closest statement before the line if there is a statement before. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line before_list = [ x for x in tree_list if ( x . begin < lineno )] before_list . sort ( key = lambda x : lineno - x . begin ) if len ( before_list ) > 0 : return before_list [ 0 ] else : return None","title":"closest_before()"},{"location":"Reference/parser/#mkreports.parser.envelope","text":"Interval that covers the given interval (i.e. is larger). Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required pos Interval Interval to cover. required Returns: Type Description Optional[Interval] The next largest interval covering the current one, if there is one, otherwise None. Source code in mkreports/parser.py def envelope ( tree : IntervalTree , pos : Interval ) -> Optional [ Interval ]: \"\"\" Interval that covers the given interval (i.e. is larger). Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. pos (Interval): Interval to cover. Returns: Optional[Interval]: The next largest interval covering the current one, if there is one, otherwise None. \"\"\" tree_list = list ( tree . envelop ( pos . begin - 1 , pos . end )) if len ( tree_list ) == 0 : return None else : tree_list . sort ( key = lambda x : x . end - x . begin ) return tree_list [ 0 ]","title":"envelope()"},{"location":"Reference/parser/#mkreports.parser.get_neighbors","text":"For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Parameters: Name Type Description Default tree IntervalTree required lineno int required Returns: Type Description (Optional[Interval], Optional[Interval], Optional[Interval]) Interval of statement before the line, covering the current line and the next statement. Source code in mkreports/parser.py def get_neighbors ( tree : IntervalTree , lineno : int ) -> Tuple [ Optional [ Interval ], Optional [ Interval ], Optional [ Interval ]]: \"\"\" For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Args: tree (IntervalTree): lineno (int): Returns: (Optional[Interval], Optional[Interval], Optional[Interval]): Interval of statement before the line, covering the current line and the next statement. \"\"\" return ( closest_before ( tree , lineno ), smallest_overlap ( tree , lineno ), closest_after ( tree , lineno ), )","title":"get_neighbors()"},{"location":"Reference/parser/#mkreports.parser.get_stmt_ranges","text":"Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Parameters: Name Type Description Default pyfile Path Path to the python file to analyze. required Returns: Type Description IntervallTree An object representing the hierarchical intervals of the statements in the file. Source code in mkreports/parser.py def get_stmt_ranges ( pyfile : Path ) -> IntervalTree : \"\"\" Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Args: pyfile (Path): Path to the python file to analyze. Returns: IntervallTree: An object representing the hierarchical intervals of the statements in the file. \"\"\" # first we parse the python file into an AST with pyfile . open ( \"r\" ) as f : file_ast = ast . parse ( f . read ()) inttree = IntervalTree () # now we want to walk along the tree and get the line extent of # all nodes that are statements; as data payload we attach # the parsed nodes for node in ast . walk ( file_ast ): if isinstance ( node , ast . stmt ): if node . lineno is not None and node . end_lineno is not None : inttree . add ( Interval ( begin = node . lineno , end = node . end_lineno + 1 , data = node ) ) return inttree","title":"get_stmt_ranges()"},{"location":"Reference/parser/#mkreports.parser.smallest_overlap","text":"Find the closest match that overlaps and is shortests. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional[Interval] An interval if there is a statement at the line. Source code in mkreports/parser.py def smallest_overlap ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Find the closest match that overlaps and is shortests. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval if there is a statement at the line. \"\"\" overlap_set = tree . at ( lineno ) if len ( overlap_set ) > 0 : # we take the shortest overlap_list = list ( overlap_set ) overlap_list . sort ( key = lambda x : x . end - x . begin ) return overlap_list [ 0 ] else : return None","title":"smallest_overlap()"},{"location":"Reference/report/","text":"Base class for the whole report. This corresponds to a mkdocs project. The class is mainly responsible for creating a mkdocs project if it doesn't exist already and ensuring that the neccessary settings are all included. Page Represents a single page of report. Source code in mkreports/report.py class Page : \"\"\"Represents a single page of report.\"\"\" def __init__ ( self , path : Path , report : Report , code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , ) -> None : \"\"\" Initialize a page. Usually this is not used and instead a page is created using the *page* method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Args: path (Path): Path to the page (absolute or relative to cwd). report (Report): The report object to which the page belongs. code_layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. code_name_only (bool): For code files, should only the name be used instead of the path. add_bottom (bool): Should new entries be added at the bottom? At the top used for IPython. \"\"\" self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( page_info = self . page_info ) self . code_context_stack : List [ CodeContext ] = [] def __enter__ ( self ) -> \"Page\" : if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to enter a new context self . code_context_stack . append ( CodeContext ( layout = self . code_layout , name_only = self . code_name_only , add_bottom = self . add_bottom , relative_to = self . report . project_root , ) ) else : # use the existing one that is not active yet pass # the last one on the stack is the one we activate self . code_context_stack [ - 1 ] . __enter__ () return self def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : \"\"\" Sets the next context to be used. Only counts for the next tracking context. Args: layout (Optional[Layouts]): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. name_only (Optional[bool]): In the code block, should only the name of the file be used. add_bottom (Optional[bool]): Is new output added to the bottom or top. Returns: Page: The page object, but with the new *CodeContext* object set. \"\"\" new_code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , relative_to = self . report . project_root , ) if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to add new one self . code_context_stack . append ( new_code_context ) else : # need to replace existing one self . code_context_stack [ - 1 ] = new_code_context return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : if len ( self . code_context_stack ) == 0 : raise Exception ( \"__exit__ called before __enter__\" ) active_code_context = self . code_context_stack . pop () active_code_context . __exit__ ( exc_type , exc_val , traceback ) # self.add accounts for remaining active code_context self . add ( active_code_context . md_obj ( page_info = self . page_info )) def __getattr__ ( self , name ): md_class = self . md . __getattr__ ( name ) def md_and_add ( * args , ** kwargs ): kwargs_add = {} kwargs_md = kwargs # now apply to md md_obj = md_class ( * args , ** kwargs_md ) return self . add ( md_obj , ** kwargs_add ) return md_and_add def __copy__ ( self ): cls = self . __class__ result = cls . __new__ ( cls ) result . __dict__ . update ( self . __dict__ ) return result @property def page_info ( self ): \"\"\" Returns: PageInfo: An object with info about the page used in markdown objects. \"\"\" return PageInfo ( store_path = self . store_path , report_path = self . report . path , javascript_path = self . report . javascript_path , project_root = self . report . project_root , idstore = self . _idstore , page_path = self . path , ) @property def notrack ( self ) -> ContextManager [ \"Page\" ]: \"\"\" Context-manager that does not do anything. This can be useful if a context-manager is used for visual grouping of code - e.g. when using the context manager on headings. This context manager can be used even if another is already active. Returns: ContextManager[\"Page\"]: Returns a null context manager that wraps the page. \"\"\" return nullcontext ( self ) @property def path ( self ) -> Path : \"\"\" Returns: Path: Absolute path to the page. \"\"\" return self . _path @property def store_path ( self ) -> Path : \"\"\" Returns: Path: Location of the path for object storage for the page. \"\"\" return self . path . parent / ( self . _path . stem + \"_store\" ) def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : \"\"\" Add a MdObj to the page. Args: item (Union[MdObj, Text]): Object to add to the page Returns: Page: The page itself. \"\"\" # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # search from the top for active code_context active_code_context = None for i in reversed ( range ( len ( self . code_context_stack ))): if self . code_context_stack [ i ] . active : active_code_context = self . code_context_stack [ i ] break # if a context-manager is active, pass along the object into there if active_code_context is not None : active_code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self def _add_to_page ( self , item : MdObj , ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" # call the markdown and the backmatter md_text = item . body + item . back req = item . settings if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in mkdocs\" ) mkdocs_settings = load_yaml ( self . report . mkdocs_file ) mkdocs_settings = merge_settings ( mkdocs_settings , req . mkdocs ) save_yaml ( mkdocs_settings , self . report . mkdocs_file ) metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , req . page ) if self . add_bottom : content = content + md_text . format_text ( content , \"\" ) else : content = md_text . format_text ( \"\" , content ) + content write_page ( self . path , metadata , content ) @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule. \"\"\" return self . _md md : MdProxy property readonly A proxy for the 'md' submodule. notrack : ContextManager [ Page ] property readonly Context-manager that does not do anything. This can be useful if a context-manager is used for visual grouping of code - e.g. when using the context manager on headings. This context manager can be used even if another is already active. Returns: Type Description ContextManager[\"Page\"] Returns a null context manager that wraps the page. page_info property readonly Returns: Type Description PageInfo An object with info about the page used in markdown objects. path : Path property readonly Returns: Type Description Path Absolute path to the page. store_path : Path property readonly Returns: Type Description Path Location of the path for object storage for the page. __init__ ( self , path , report , code_layout = 'tabbed' , code_name_only = False , add_bottom = True ) special Initialize a page. Usually this is not used and instead a page is created using the page method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Parameters: Name Type Description Default path Path Path to the page (absolute or relative to cwd). required report Report The report object to which the page belongs. required code_layout Layouts Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. 'tabbed' code_name_only bool For code files, should only the name be used instead of the path. False add_bottom bool Should new entries be added at the bottom? At the top used for IPython. True Source code in mkreports/report.py def __init__ ( self , path : Path , report : Report , code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , ) -> None : \"\"\" Initialize a page. Usually this is not used and instead a page is created using the *page* method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Args: path (Path): Path to the page (absolute or relative to cwd). report (Report): The report object to which the page belongs. code_layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. code_name_only (bool): For code files, should only the name be used instead of the path. add_bottom (bool): Should new entries be added at the bottom? At the top used for IPython. \"\"\" self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( page_info = self . page_info ) self . code_context_stack : List [ CodeContext ] = [] add ( self , item ) Add a MdObj to the page. Parameters: Name Type Description Default item Union[MdObj, Text] Object to add to the page required Returns: Type Description Page The page itself. Source code in mkreports/report.py def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : \"\"\" Add a MdObj to the page. Args: item (Union[MdObj, Text]): Object to add to the page Returns: Page: The page itself. \"\"\" # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # search from the top for active code_context active_code_context = None for i in reversed ( range ( len ( self . code_context_stack ))): if self . code_context_stack [ i ] . active : active_code_context = self . code_context_stack [ i ] break # if a context-manager is active, pass along the object into there if active_code_context is not None : active_code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self clear ( self ) Clear the page markdown file and the generated assets directory. Source code in mkreports/report.py def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () ctx ( self , layout = None , name_only = None , add_bottom = None ) Sets the next context to be used. Only counts for the next tracking context. Parameters: Name Type Description Default layout Optional[Layouts] The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. None name_only Optional[bool] In the code block, should only the name of the file be used. None add_bottom Optional[bool] Is new output added to the bottom or top. None Returns: Type Description Page The page object, but with the new CodeContext object set. Source code in mkreports/report.py def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : \"\"\" Sets the next context to be used. Only counts for the next tracking context. Args: layout (Optional[Layouts]): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. name_only (Optional[bool]): In the code block, should only the name of the file be used. add_bottom (Optional[bool]): Is new output added to the bottom or top. Returns: Page: The page object, but with the new *CodeContext* object set. \"\"\" new_code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , relative_to = self . report . project_root , ) if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to add new one self . code_context_stack . append ( new_code_context ) else : # need to replace existing one self . code_context_stack [ - 1 ] = new_code_context return self Report Class representing a report. Source code in mkreports/report.py class Report : \"\"\"Class representing a report.\"\"\" def __init__ ( self , path : Optional [ Union [ str , Path ]] = None , project_root : Optional [ Union [ str , Path ]] = None , ) -> None : \"\"\" Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the **create** class-method. Args: path (Optional[Union[str, Path]]): Path to the top-level directory of the report. project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. \"\"\" # need to ensure it is of type Path if path is None : try : path = os . environ [ \"MKREPORTS_DIR\" ] except Exception : raise ValueError ( \"If no report path is given, the 'MKREPORTS_DIR' environment variable has to be set.\" ) self . _path = Path ( path ) . absolute () # first check if the path exists and is not empty and return error if that is not ok if not self . path . exists (): raise ReportNotExistsError ( f \" { self . path } does not exist.\" ) if not self . mkdocs_file . exists () or not self . mkdocs_file . is_file (): raise ReportNotValidError ( f \" { self . mkdocs_file } does not exist\" ) if not self . docs_dir . exists () or not self . docs_dir . is_dir (): raise ReportNotValidError ( f \" { self . docs_dir } does not exist\" ) if not self . index_file . exists () or not self . index_file . is_file (): raise ReportNotValidError ( f \" { self . index_file } does not exist\" ) if project_root is None : root = repo_root () if root is None : self . project_root = Path ( \"/\" ) else : self . project_root = root else : self . project_root = Path ( project_root ) @property def path ( self ) -> Path : \"\"\" Returns: Path: Path object that is the top-level of the report. \"\"\" return self . _path @property def mkdocs_file ( self ) -> Path : \"\"\" Returns: Path: Location of the mkdocs file. \"\"\" return self . path / \"mkdocs.yml\" @property def docs_dir ( self ) -> Path : \"\"\" Returns: Path: Docs-folder in the report. \"\"\" return self . path / \"docs\" @property def index_file ( self ) -> Path : \"\"\" Returns: Path: Location of the index file. \"\"\" return self . docs_dir / \"index.md\" @property def javascript_path ( self ) -> Path : \"\"\" Returns: Path: Location of the javascript folder. \"\"\" return self . docs_dir / \"javascript\" @classmethod def create ( cls , path : Union [ str , Path ], report_name : str , settings : Optional [ Mapping [ str , str ]] = default_settings , exist_ok : bool = False , ) -> \"Report\" : \"\"\" Create a new report. Args: path (Union[str, Path]): Top-level folder of the report. report_name (str): Name of the report (mkdocs site-name) settings (Optional[Mapping[str, str]]): Settings of the report. exist_ok (bool): Is it ok if it already exists? Returns: Report: An instance of the class representing the project. \"\"\" path = Path ( path ) # create the directory try : ( path / \"docs\" ) . mkdir ( exist_ok = exist_ok , parents = True ) except FileExistsError : raise ReportExistsError ( f \" { path / 'docs' } already exists.\" ) # index.md created, but done nothing if it exists # if exist_ok=False, the previousalready failed otherwise ( path / \"docs\" / \"index.md\" ) . touch () # only do it if mkdocs_yml does not exist yet mkdocs_file = path / \"mkdocs.yml\" if not mkdocs_file . exists (): # the settings are our serialized yaml # ensure settings is regular dict settings = dict ( settings . items ()) if settings is not None else {} settings [ \"site_name\" ] = report_name with ( path / \"mkdocs.yml\" ) . open ( \"w\" ) as f : yaml . dump ( settings , f , Dumper = yaml . Dumper , default_flow_style = False ) # also create the overrides doc overrides_dir = path / \"overrides\" overrides_dir . mkdir ( exist_ok = True , parents = True ) with ( overrides_dir / \"main.html\" ) . open ( \"w\" ) as f : f . write ( main_html_override ) return cls ( path ) def _add_nav_entry ( self , nav_entry ) -> None : # check that the nav-entry is relative; if absolute, # make it relative to the docs_dir if isinstance ( nav_entry [ 1 ], str ): nav_entry = NavEntry ( nav_entry [ 0 ], Path ( nav_entry [ 1 ])) if nav_entry [ 1 ] . is_absolute (): nav_entry = NavEntry ( nav_entry [ 0 ], nav_entry [ 1 ] . relative_to ( self . docs_dir )) mkdocs_settings = load_yaml ( self . mkdocs_file ) mkdocs_settings = add_nav_entry ( mkdocs_settings , nav_entry ) save_yaml ( mkdocs_settings , self . mkdocs_file ) def page ( self , page_name : Union [ NavEntry , Path , str ], truncate : bool = False , add_bottom : bool = True , ) -> \"Page\" : \"\"\" Create a page in the report. Args: page_name (Union[NavEntry, Path, str]): Name of the page and path. Using a **NavEntry**, a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. truncate (bool): Should the page be truncated if it exists? Also deletes the *store_path*. add_bottom (bool): Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. Returns: Page: An object representing a new page. \"\"\" # if the page_name is just a string, we turn it into a dictionary # based on the hierarchical names if isinstance ( page_name , ( str , Path )): path = Path ( page_name ) if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) nav_entry = path_to_nav_entry ( path ) else : nav_entry = page_name path = nav_entry [ 1 ] if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) if path . suffix != \".md\" : raise ValueError ( f \" { path } needs to have extension '.md'\" ) # if the file already exists, just return a 'Page', # else create a new nav-entry and the file and return a 'Page' if ( self . docs_dir / path ) . exists (): if truncate : # delete the existing site ( self . docs_dir / path ) . unlink () ( self . docs_dir / path ) . touch () # we do not need to add en entry into the nav else : # create the file by touching it and create a nav-entry ( self . docs_dir / path ) . parent . mkdir ( exist_ok = True , parents = True ) ( self . docs_dir / path ) . touch () # update the report settings self . _add_nav_entry ( nav_entry ) page = Page ( self . docs_dir / path , report = self , add_bottom = add_bottom , ) if truncate : if page . store_path . exists (): shutil . rmtree ( page . store_path ) return page docs_dir : Path property readonly Returns: Type Description Path Docs-folder in the report. index_file : Path property readonly Returns: Type Description Path Location of the index file. javascript_path : Path property readonly Returns: Type Description Path Location of the javascript folder. mkdocs_file : Path property readonly Returns: Type Description Path Location of the mkdocs file. path : Path property readonly Returns: Type Description Path Path object that is the top-level of the report. __init__ ( self , path = None , project_root = None ) special Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the create class-method. Parameters: Name Type Description Default path Optional[Union[str, Path]] Path to the top-level directory of the report. None project_root Optional[Union[str, Path]] Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. None Source code in mkreports/report.py def __init__ ( self , path : Optional [ Union [ str , Path ]] = None , project_root : Optional [ Union [ str , Path ]] = None , ) -> None : \"\"\" Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the **create** class-method. Args: path (Optional[Union[str, Path]]): Path to the top-level directory of the report. project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. \"\"\" # need to ensure it is of type Path if path is None : try : path = os . environ [ \"MKREPORTS_DIR\" ] except Exception : raise ValueError ( \"If no report path is given, the 'MKREPORTS_DIR' environment variable has to be set.\" ) self . _path = Path ( path ) . absolute () # first check if the path exists and is not empty and return error if that is not ok if not self . path . exists (): raise ReportNotExistsError ( f \" { self . path } does not exist.\" ) if not self . mkdocs_file . exists () or not self . mkdocs_file . is_file (): raise ReportNotValidError ( f \" { self . mkdocs_file } does not exist\" ) if not self . docs_dir . exists () or not self . docs_dir . is_dir (): raise ReportNotValidError ( f \" { self . docs_dir } does not exist\" ) if not self . index_file . exists () or not self . index_file . is_file (): raise ReportNotValidError ( f \" { self . index_file } does not exist\" ) if project_root is None : root = repo_root () if root is None : self . project_root = Path ( \"/\" ) else : self . project_root = root else : self . project_root = Path ( project_root ) create ( path , report_name , settings = immutabledict ({ 'theme' : { 'name' : 'material' , 'custom_dir' : 'overrides' }, 'nav' : [{ 'Home' : 'index.md' }], 'markdown_extensions' : [ 'meta' , 'admonition' , 'pymdownx.extra' , 'pymdownx.details' , 'pymdownx.superfences' ]}), exist_ok = False ) classmethod Create a new report. Parameters: Name Type Description Default path Union[str, Path] Top-level folder of the report. required report_name str Name of the report (mkdocs site-name) required settings Optional[Mapping[str, str]] Settings of the report. immutabledict({'theme': {'name': 'material', 'custom_dir': 'overrides'}, 'nav': [{'Home': 'index.md'}], 'markdown_extensions': ['meta', 'admonition', 'pymdownx.extra', 'pymdownx.details', 'pymdownx.superfences']}) exist_ok bool Is it ok if it already exists? False Returns: Type Description Report An instance of the class representing the project. Source code in mkreports/report.py @classmethod def create ( cls , path : Union [ str , Path ], report_name : str , settings : Optional [ Mapping [ str , str ]] = default_settings , exist_ok : bool = False , ) -> \"Report\" : \"\"\" Create a new report. Args: path (Union[str, Path]): Top-level folder of the report. report_name (str): Name of the report (mkdocs site-name) settings (Optional[Mapping[str, str]]): Settings of the report. exist_ok (bool): Is it ok if it already exists? Returns: Report: An instance of the class representing the project. \"\"\" path = Path ( path ) # create the directory try : ( path / \"docs\" ) . mkdir ( exist_ok = exist_ok , parents = True ) except FileExistsError : raise ReportExistsError ( f \" { path / 'docs' } already exists.\" ) # index.md created, but done nothing if it exists # if exist_ok=False, the previousalready failed otherwise ( path / \"docs\" / \"index.md\" ) . touch () # only do it if mkdocs_yml does not exist yet mkdocs_file = path / \"mkdocs.yml\" if not mkdocs_file . exists (): # the settings are our serialized yaml # ensure settings is regular dict settings = dict ( settings . items ()) if settings is not None else {} settings [ \"site_name\" ] = report_name with ( path / \"mkdocs.yml\" ) . open ( \"w\" ) as f : yaml . dump ( settings , f , Dumper = yaml . Dumper , default_flow_style = False ) # also create the overrides doc overrides_dir = path / \"overrides\" overrides_dir . mkdir ( exist_ok = True , parents = True ) with ( overrides_dir / \"main.html\" ) . open ( \"w\" ) as f : f . write ( main_html_override ) return cls ( path ) page ( self , page_name , truncate = False , add_bottom = True ) Create a page in the report. Parameters: Name Type Description Default page_name Union[NavEntry, Path, str] Name of the page and path. Using a NavEntry , a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. required truncate bool Should the page be truncated if it exists? Also deletes the store_path . False add_bottom bool Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. True Returns: Type Description Page An object representing a new page. Source code in mkreports/report.py def page ( self , page_name : Union [ NavEntry , Path , str ], truncate : bool = False , add_bottom : bool = True , ) -> \"Page\" : \"\"\" Create a page in the report. Args: page_name (Union[NavEntry, Path, str]): Name of the page and path. Using a **NavEntry**, a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. truncate (bool): Should the page be truncated if it exists? Also deletes the *store_path*. add_bottom (bool): Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. Returns: Page: An object representing a new page. \"\"\" # if the page_name is just a string, we turn it into a dictionary # based on the hierarchical names if isinstance ( page_name , ( str , Path )): path = Path ( page_name ) if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) nav_entry = path_to_nav_entry ( path ) else : nav_entry = page_name path = nav_entry [ 1 ] if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) if path . suffix != \".md\" : raise ValueError ( f \" { path } needs to have extension '.md'\" ) # if the file already exists, just return a 'Page', # else create a new nav-entry and the file and return a 'Page' if ( self . docs_dir / path ) . exists (): if truncate : # delete the existing site ( self . docs_dir / path ) . unlink () ( self . docs_dir / path ) . touch () # we do not need to add en entry into the nav else : # create the file by touching it and create a nav-entry ( self . docs_dir / path ) . parent . mkdir ( exist_ok = True , parents = True ) ( self . docs_dir / path ) . touch () # update the report settings self . _add_nav_entry ( nav_entry ) page = Page ( self . docs_dir / path , report = self , add_bottom = add_bottom , ) if truncate : if page . store_path . exists (): shutil . rmtree ( page . store_path ) return page","title":"report"},{"location":"Reference/report/#mkreports.report.Page","text":"Represents a single page of report. Source code in mkreports/report.py class Page : \"\"\"Represents a single page of report.\"\"\" def __init__ ( self , path : Path , report : Report , code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , ) -> None : \"\"\" Initialize a page. Usually this is not used and instead a page is created using the *page* method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Args: path (Path): Path to the page (absolute or relative to cwd). report (Report): The report object to which the page belongs. code_layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. code_name_only (bool): For code files, should only the name be used instead of the path. add_bottom (bool): Should new entries be added at the bottom? At the top used for IPython. \"\"\" self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( page_info = self . page_info ) self . code_context_stack : List [ CodeContext ] = [] def __enter__ ( self ) -> \"Page\" : if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to enter a new context self . code_context_stack . append ( CodeContext ( layout = self . code_layout , name_only = self . code_name_only , add_bottom = self . add_bottom , relative_to = self . report . project_root , ) ) else : # use the existing one that is not active yet pass # the last one on the stack is the one we activate self . code_context_stack [ - 1 ] . __enter__ () return self def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : \"\"\" Sets the next context to be used. Only counts for the next tracking context. Args: layout (Optional[Layouts]): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. name_only (Optional[bool]): In the code block, should only the name of the file be used. add_bottom (Optional[bool]): Is new output added to the bottom or top. Returns: Page: The page object, but with the new *CodeContext* object set. \"\"\" new_code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , relative_to = self . report . project_root , ) if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to add new one self . code_context_stack . append ( new_code_context ) else : # need to replace existing one self . code_context_stack [ - 1 ] = new_code_context return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : if len ( self . code_context_stack ) == 0 : raise Exception ( \"__exit__ called before __enter__\" ) active_code_context = self . code_context_stack . pop () active_code_context . __exit__ ( exc_type , exc_val , traceback ) # self.add accounts for remaining active code_context self . add ( active_code_context . md_obj ( page_info = self . page_info )) def __getattr__ ( self , name ): md_class = self . md . __getattr__ ( name ) def md_and_add ( * args , ** kwargs ): kwargs_add = {} kwargs_md = kwargs # now apply to md md_obj = md_class ( * args , ** kwargs_md ) return self . add ( md_obj , ** kwargs_add ) return md_and_add def __copy__ ( self ): cls = self . __class__ result = cls . __new__ ( cls ) result . __dict__ . update ( self . __dict__ ) return result @property def page_info ( self ): \"\"\" Returns: PageInfo: An object with info about the page used in markdown objects. \"\"\" return PageInfo ( store_path = self . store_path , report_path = self . report . path , javascript_path = self . report . javascript_path , project_root = self . report . project_root , idstore = self . _idstore , page_path = self . path , ) @property def notrack ( self ) -> ContextManager [ \"Page\" ]: \"\"\" Context-manager that does not do anything. This can be useful if a context-manager is used for visual grouping of code - e.g. when using the context manager on headings. This context manager can be used even if another is already active. Returns: ContextManager[\"Page\"]: Returns a null context manager that wraps the page. \"\"\" return nullcontext ( self ) @property def path ( self ) -> Path : \"\"\" Returns: Path: Absolute path to the page. \"\"\" return self . _path @property def store_path ( self ) -> Path : \"\"\" Returns: Path: Location of the path for object storage for the page. \"\"\" return self . path . parent / ( self . _path . stem + \"_store\" ) def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : \"\"\" Add a MdObj to the page. Args: item (Union[MdObj, Text]): Object to add to the page Returns: Page: The page itself. \"\"\" # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # search from the top for active code_context active_code_context = None for i in reversed ( range ( len ( self . code_context_stack ))): if self . code_context_stack [ i ] . active : active_code_context = self . code_context_stack [ i ] break # if a context-manager is active, pass along the object into there if active_code_context is not None : active_code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self def _add_to_page ( self , item : MdObj , ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" # call the markdown and the backmatter md_text = item . body + item . back req = item . settings if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in mkdocs\" ) mkdocs_settings = load_yaml ( self . report . mkdocs_file ) mkdocs_settings = merge_settings ( mkdocs_settings , req . mkdocs ) save_yaml ( mkdocs_settings , self . report . mkdocs_file ) metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , req . page ) if self . add_bottom : content = content + md_text . format_text ( content , \"\" ) else : content = md_text . format_text ( \"\" , content ) + content write_page ( self . path , metadata , content ) @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule. \"\"\" return self . _md","title":"Page"},{"location":"Reference/report/#mkreports.report.Page.md","text":"A proxy for the 'md' submodule.","title":"md"},{"location":"Reference/report/#mkreports.report.Page.notrack","text":"Context-manager that does not do anything. This can be useful if a context-manager is used for visual grouping of code - e.g. when using the context manager on headings. This context manager can be used even if another is already active. Returns: Type Description ContextManager[\"Page\"] Returns a null context manager that wraps the page.","title":"notrack"},{"location":"Reference/report/#mkreports.report.Page.page_info","text":"Returns: Type Description PageInfo An object with info about the page used in markdown objects.","title":"page_info"},{"location":"Reference/report/#mkreports.report.Page.path","text":"Returns: Type Description Path Absolute path to the page.","title":"path"},{"location":"Reference/report/#mkreports.report.Page.store_path","text":"Returns: Type Description Path Location of the path for object storage for the page.","title":"store_path"},{"location":"Reference/report/#mkreports.report.Page.__init__","text":"Initialize a page. Usually this is not used and instead a page is created using the page method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Parameters: Name Type Description Default path Path Path to the page (absolute or relative to cwd). required report Report The report object to which the page belongs. required code_layout Layouts Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. 'tabbed' code_name_only bool For code files, should only the name be used instead of the path. False add_bottom bool Should new entries be added at the bottom? At the top used for IPython. True Source code in mkreports/report.py def __init__ ( self , path : Path , report : Report , code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , ) -> None : \"\"\" Initialize a page. Usually this is not used and instead a page is created using the *page* method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Args: path (Path): Path to the page (absolute or relative to cwd). report (Report): The report object to which the page belongs. code_layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. code_name_only (bool): For code files, should only the name be used instead of the path. add_bottom (bool): Should new entries be added at the bottom? At the top used for IPython. \"\"\" self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( page_info = self . page_info ) self . code_context_stack : List [ CodeContext ] = []","title":"__init__()"},{"location":"Reference/report/#mkreports.report.Page.add","text":"Add a MdObj to the page. Parameters: Name Type Description Default item Union[MdObj, Text] Object to add to the page required Returns: Type Description Page The page itself. Source code in mkreports/report.py def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : \"\"\" Add a MdObj to the page. Args: item (Union[MdObj, Text]): Object to add to the page Returns: Page: The page itself. \"\"\" # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # search from the top for active code_context active_code_context = None for i in reversed ( range ( len ( self . code_context_stack ))): if self . code_context_stack [ i ] . active : active_code_context = self . code_context_stack [ i ] break # if a context-manager is active, pass along the object into there if active_code_context is not None : active_code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self","title":"add()"},{"location":"Reference/report/#mkreports.report.Page.clear","text":"Clear the page markdown file and the generated assets directory. Source code in mkreports/report.py def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink ()","title":"clear()"},{"location":"Reference/report/#mkreports.report.Page.ctx","text":"Sets the next context to be used. Only counts for the next tracking context. Parameters: Name Type Description Default layout Optional[Layouts] The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. None name_only Optional[bool] In the code block, should only the name of the file be used. None add_bottom Optional[bool] Is new output added to the bottom or top. None Returns: Type Description Page The page object, but with the new CodeContext object set. Source code in mkreports/report.py def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : \"\"\" Sets the next context to be used. Only counts for the next tracking context. Args: layout (Optional[Layouts]): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. name_only (Optional[bool]): In the code block, should only the name of the file be used. add_bottom (Optional[bool]): Is new output added to the bottom or top. Returns: Page: The page object, but with the new *CodeContext* object set. \"\"\" new_code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , relative_to = self . report . project_root , ) if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to add new one self . code_context_stack . append ( new_code_context ) else : # need to replace existing one self . code_context_stack [ - 1 ] = new_code_context return self","title":"ctx()"},{"location":"Reference/report/#mkreports.report.Report","text":"Class representing a report. Source code in mkreports/report.py class Report : \"\"\"Class representing a report.\"\"\" def __init__ ( self , path : Optional [ Union [ str , Path ]] = None , project_root : Optional [ Union [ str , Path ]] = None , ) -> None : \"\"\" Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the **create** class-method. Args: path (Optional[Union[str, Path]]): Path to the top-level directory of the report. project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. \"\"\" # need to ensure it is of type Path if path is None : try : path = os . environ [ \"MKREPORTS_DIR\" ] except Exception : raise ValueError ( \"If no report path is given, the 'MKREPORTS_DIR' environment variable has to be set.\" ) self . _path = Path ( path ) . absolute () # first check if the path exists and is not empty and return error if that is not ok if not self . path . exists (): raise ReportNotExistsError ( f \" { self . path } does not exist.\" ) if not self . mkdocs_file . exists () or not self . mkdocs_file . is_file (): raise ReportNotValidError ( f \" { self . mkdocs_file } does not exist\" ) if not self . docs_dir . exists () or not self . docs_dir . is_dir (): raise ReportNotValidError ( f \" { self . docs_dir } does not exist\" ) if not self . index_file . exists () or not self . index_file . is_file (): raise ReportNotValidError ( f \" { self . index_file } does not exist\" ) if project_root is None : root = repo_root () if root is None : self . project_root = Path ( \"/\" ) else : self . project_root = root else : self . project_root = Path ( project_root ) @property def path ( self ) -> Path : \"\"\" Returns: Path: Path object that is the top-level of the report. \"\"\" return self . _path @property def mkdocs_file ( self ) -> Path : \"\"\" Returns: Path: Location of the mkdocs file. \"\"\" return self . path / \"mkdocs.yml\" @property def docs_dir ( self ) -> Path : \"\"\" Returns: Path: Docs-folder in the report. \"\"\" return self . path / \"docs\" @property def index_file ( self ) -> Path : \"\"\" Returns: Path: Location of the index file. \"\"\" return self . docs_dir / \"index.md\" @property def javascript_path ( self ) -> Path : \"\"\" Returns: Path: Location of the javascript folder. \"\"\" return self . docs_dir / \"javascript\" @classmethod def create ( cls , path : Union [ str , Path ], report_name : str , settings : Optional [ Mapping [ str , str ]] = default_settings , exist_ok : bool = False , ) -> \"Report\" : \"\"\" Create a new report. Args: path (Union[str, Path]): Top-level folder of the report. report_name (str): Name of the report (mkdocs site-name) settings (Optional[Mapping[str, str]]): Settings of the report. exist_ok (bool): Is it ok if it already exists? Returns: Report: An instance of the class representing the project. \"\"\" path = Path ( path ) # create the directory try : ( path / \"docs\" ) . mkdir ( exist_ok = exist_ok , parents = True ) except FileExistsError : raise ReportExistsError ( f \" { path / 'docs' } already exists.\" ) # index.md created, but done nothing if it exists # if exist_ok=False, the previousalready failed otherwise ( path / \"docs\" / \"index.md\" ) . touch () # only do it if mkdocs_yml does not exist yet mkdocs_file = path / \"mkdocs.yml\" if not mkdocs_file . exists (): # the settings are our serialized yaml # ensure settings is regular dict settings = dict ( settings . items ()) if settings is not None else {} settings [ \"site_name\" ] = report_name with ( path / \"mkdocs.yml\" ) . open ( \"w\" ) as f : yaml . dump ( settings , f , Dumper = yaml . Dumper , default_flow_style = False ) # also create the overrides doc overrides_dir = path / \"overrides\" overrides_dir . mkdir ( exist_ok = True , parents = True ) with ( overrides_dir / \"main.html\" ) . open ( \"w\" ) as f : f . write ( main_html_override ) return cls ( path ) def _add_nav_entry ( self , nav_entry ) -> None : # check that the nav-entry is relative; if absolute, # make it relative to the docs_dir if isinstance ( nav_entry [ 1 ], str ): nav_entry = NavEntry ( nav_entry [ 0 ], Path ( nav_entry [ 1 ])) if nav_entry [ 1 ] . is_absolute (): nav_entry = NavEntry ( nav_entry [ 0 ], nav_entry [ 1 ] . relative_to ( self . docs_dir )) mkdocs_settings = load_yaml ( self . mkdocs_file ) mkdocs_settings = add_nav_entry ( mkdocs_settings , nav_entry ) save_yaml ( mkdocs_settings , self . mkdocs_file ) def page ( self , page_name : Union [ NavEntry , Path , str ], truncate : bool = False , add_bottom : bool = True , ) -> \"Page\" : \"\"\" Create a page in the report. Args: page_name (Union[NavEntry, Path, str]): Name of the page and path. Using a **NavEntry**, a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. truncate (bool): Should the page be truncated if it exists? Also deletes the *store_path*. add_bottom (bool): Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. Returns: Page: An object representing a new page. \"\"\" # if the page_name is just a string, we turn it into a dictionary # based on the hierarchical names if isinstance ( page_name , ( str , Path )): path = Path ( page_name ) if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) nav_entry = path_to_nav_entry ( path ) else : nav_entry = page_name path = nav_entry [ 1 ] if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) if path . suffix != \".md\" : raise ValueError ( f \" { path } needs to have extension '.md'\" ) # if the file already exists, just return a 'Page', # else create a new nav-entry and the file and return a 'Page' if ( self . docs_dir / path ) . exists (): if truncate : # delete the existing site ( self . docs_dir / path ) . unlink () ( self . docs_dir / path ) . touch () # we do not need to add en entry into the nav else : # create the file by touching it and create a nav-entry ( self . docs_dir / path ) . parent . mkdir ( exist_ok = True , parents = True ) ( self . docs_dir / path ) . touch () # update the report settings self . _add_nav_entry ( nav_entry ) page = Page ( self . docs_dir / path , report = self , add_bottom = add_bottom , ) if truncate : if page . store_path . exists (): shutil . rmtree ( page . store_path ) return page","title":"Report"},{"location":"Reference/report/#mkreports.report.Report.docs_dir","text":"Returns: Type Description Path Docs-folder in the report.","title":"docs_dir"},{"location":"Reference/report/#mkreports.report.Report.index_file","text":"Returns: Type Description Path Location of the index file.","title":"index_file"},{"location":"Reference/report/#mkreports.report.Report.javascript_path","text":"Returns: Type Description Path Location of the javascript folder.","title":"javascript_path"},{"location":"Reference/report/#mkreports.report.Report.mkdocs_file","text":"Returns: Type Description Path Location of the mkdocs file.","title":"mkdocs_file"},{"location":"Reference/report/#mkreports.report.Report.path","text":"Returns: Type Description Path Path object that is the top-level of the report.","title":"path"},{"location":"Reference/report/#mkreports.report.Report.__init__","text":"Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the create class-method. Parameters: Name Type Description Default path Optional[Union[str, Path]] Path to the top-level directory of the report. None project_root Optional[Union[str, Path]] Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. None Source code in mkreports/report.py def __init__ ( self , path : Optional [ Union [ str , Path ]] = None , project_root : Optional [ Union [ str , Path ]] = None , ) -> None : \"\"\" Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the **create** class-method. Args: path (Optional[Union[str, Path]]): Path to the top-level directory of the report. project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. \"\"\" # need to ensure it is of type Path if path is None : try : path = os . environ [ \"MKREPORTS_DIR\" ] except Exception : raise ValueError ( \"If no report path is given, the 'MKREPORTS_DIR' environment variable has to be set.\" ) self . _path = Path ( path ) . absolute () # first check if the path exists and is not empty and return error if that is not ok if not self . path . exists (): raise ReportNotExistsError ( f \" { self . path } does not exist.\" ) if not self . mkdocs_file . exists () or not self . mkdocs_file . is_file (): raise ReportNotValidError ( f \" { self . mkdocs_file } does not exist\" ) if not self . docs_dir . exists () or not self . docs_dir . is_dir (): raise ReportNotValidError ( f \" { self . docs_dir } does not exist\" ) if not self . index_file . exists () or not self . index_file . is_file (): raise ReportNotValidError ( f \" { self . index_file } does not exist\" ) if project_root is None : root = repo_root () if root is None : self . project_root = Path ( \"/\" ) else : self . project_root = root else : self . project_root = Path ( project_root )","title":"__init__()"},{"location":"Reference/report/#mkreports.report.Report.create","text":"Create a new report. Parameters: Name Type Description Default path Union[str, Path] Top-level folder of the report. required report_name str Name of the report (mkdocs site-name) required settings Optional[Mapping[str, str]] Settings of the report. immutabledict({'theme': {'name': 'material', 'custom_dir': 'overrides'}, 'nav': [{'Home': 'index.md'}], 'markdown_extensions': ['meta', 'admonition', 'pymdownx.extra', 'pymdownx.details', 'pymdownx.superfences']}) exist_ok bool Is it ok if it already exists? False Returns: Type Description Report An instance of the class representing the project. Source code in mkreports/report.py @classmethod def create ( cls , path : Union [ str , Path ], report_name : str , settings : Optional [ Mapping [ str , str ]] = default_settings , exist_ok : bool = False , ) -> \"Report\" : \"\"\" Create a new report. Args: path (Union[str, Path]): Top-level folder of the report. report_name (str): Name of the report (mkdocs site-name) settings (Optional[Mapping[str, str]]): Settings of the report. exist_ok (bool): Is it ok if it already exists? Returns: Report: An instance of the class representing the project. \"\"\" path = Path ( path ) # create the directory try : ( path / \"docs\" ) . mkdir ( exist_ok = exist_ok , parents = True ) except FileExistsError : raise ReportExistsError ( f \" { path / 'docs' } already exists.\" ) # index.md created, but done nothing if it exists # if exist_ok=False, the previousalready failed otherwise ( path / \"docs\" / \"index.md\" ) . touch () # only do it if mkdocs_yml does not exist yet mkdocs_file = path / \"mkdocs.yml\" if not mkdocs_file . exists (): # the settings are our serialized yaml # ensure settings is regular dict settings = dict ( settings . items ()) if settings is not None else {} settings [ \"site_name\" ] = report_name with ( path / \"mkdocs.yml\" ) . open ( \"w\" ) as f : yaml . dump ( settings , f , Dumper = yaml . Dumper , default_flow_style = False ) # also create the overrides doc overrides_dir = path / \"overrides\" overrides_dir . mkdir ( exist_ok = True , parents = True ) with ( overrides_dir / \"main.html\" ) . open ( \"w\" ) as f : f . write ( main_html_override ) return cls ( path )","title":"create()"},{"location":"Reference/report/#mkreports.report.Report.page","text":"Create a page in the report. Parameters: Name Type Description Default page_name Union[NavEntry, Path, str] Name of the page and path. Using a NavEntry , a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. required truncate bool Should the page be truncated if it exists? Also deletes the store_path . False add_bottom bool Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. True Returns: Type Description Page An object representing a new page. Source code in mkreports/report.py def page ( self , page_name : Union [ NavEntry , Path , str ], truncate : bool = False , add_bottom : bool = True , ) -> \"Page\" : \"\"\" Create a page in the report. Args: page_name (Union[NavEntry, Path, str]): Name of the page and path. Using a **NavEntry**, a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. truncate (bool): Should the page be truncated if it exists? Also deletes the *store_path*. add_bottom (bool): Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. Returns: Page: An object representing a new page. \"\"\" # if the page_name is just a string, we turn it into a dictionary # based on the hierarchical names if isinstance ( page_name , ( str , Path )): path = Path ( page_name ) if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) nav_entry = path_to_nav_entry ( path ) else : nav_entry = page_name path = nav_entry [ 1 ] if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) if path . suffix != \".md\" : raise ValueError ( f \" { path } needs to have extension '.md'\" ) # if the file already exists, just return a 'Page', # else create a new nav-entry and the file and return a 'Page' if ( self . docs_dir / path ) . exists (): if truncate : # delete the existing site ( self . docs_dir / path ) . unlink () ( self . docs_dir / path ) . touch () # we do not need to add en entry into the nav else : # create the file by touching it and create a nav-entry ( self . docs_dir / path ) . parent . mkdir ( exist_ok = True , parents = True ) ( self . docs_dir / path ) . touch () # update the report settings self . _add_nav_entry ( nav_entry ) page = Page ( self . docs_dir / path , report = self , add_bottom = add_bottom , ) if truncate : if page . store_path . exists (): shutil . rmtree ( page . store_path ) return page","title":"page()"},{"location":"Reference/settings/","text":"NavEntry ( tuple ) An entry in the navigation tab. Parameters: Name Type Description Default hierarchy Sequence[str] List of navigation entries. required file Path Path to the page, relative to report docs folder. required Source code in mkreports/settings.py class NavEntry ( NamedTuple ): \"\"\" An entry in the navigation tab. Args: hierarchy (Sequence[str]): List of navigation entries. file (Path): Path to the page, relative to report docs folder. \"\"\" hierarchy : Sequence [ str ] file : Path __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in mkreports/settings.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , hierarchy , file ) special staticmethod Create new instance of NavEntry(hierarchy, file) __repr__ ( self ) special Return a nicely formatted representation string Source code in mkreports/settings.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self add_nav_entry ( mkdocs_settings , nav_entry ) Add an additional entry to the Nav in mkdocs.yml Parameters: Name Type Description Default mkdocs_settings The mkdocs settings to update. required nav_entry NavEntry The NavEntry to add required Returns: Type Description Any The updated mkdocs_settings Source code in mkreports/settings.py def add_nav_entry ( mkdocs_settings , nav_entry : NavEntry ) -> Any : \"\"\" Add an additional entry to the Nav in mkdocs.yml Args: mkdocs_settings (): The mkdocs settings to update. nav_entry (NavEntry): The NavEntry to add Returns: The updated mkdocs_settings \"\"\" mkdocs_settings = deepcopy ( mkdocs_settings ) nav = mkdocs_to_nav ( mkdocs_settings [ \"nav\" ]) + [ nav_entry ] # we need to deduplicate nav = list ( unique_everseen ( nav )) mkdocs_nav = nav_to_mkdocs ( nav ) mkdocs_settings [ \"nav\" ] = mkdocs_nav return mkdocs_settings load_yaml ( file ) Load a yaml file, return empty dict if not exists. Parameters: Name Type Description Default file Path File to load required Returns: Type Description Any The value in the file, empty dict otherwise. Source code in mkreports/settings.py def load_yaml ( file : Path ) -> Any : \"\"\" Load a yaml file, return empty dict if not exists. Args: file (Path): File to load Returns: The value in the file, empty dict otherwise. \"\"\" if file . exists (): with file . open ( \"r\" ) as f : res = yaml . load ( f , Loader = yaml . Loader ) else : res = {} return res mkdocs_to_nav ( mkdocs_nav ) Convert an mkdovs nav to a list of NavEntry. Parameters: Name Type Description Default mkdocs_nav List[Union[str, Mapping[str, Union[str, MkdocsNav]]]] A python representation of the nav-entry in the mkdocs.yml file. required Source code in mkreports/settings.py def mkdocs_to_nav ( mkdocs_nav : MkdocsNav ) -> Nav : \"\"\" Convert an mkdovs nav to a list of NavEntry. Args: mkdocs_nav: A python representation of the nav-entry in the mkdocs.yml file. \"\"\" res = [] for entry in mkdocs_nav : if isinstance ( entry , str ): res . append (([], Path ( entry ))) elif isinstance ( entry , Mapping ): key , val = _check_length_one ( entry ) if isinstance ( val , str ): res . append (([ key ], Path ( val ))) elif isinstance ( val , List ): res = res + [(( key ,) + tuple ( h ), p ) for ( h , p ) in mkdocs_to_nav ( val )] else : raise Exception ( \"Not expected type\" ) else : raise Exception ( \"Not expected type\" ) return res nav_to_mkdocs ( nav ) Convert a list of nav-entries into mkdocs format. Parameters: Name Type Description Default nav Nav The list of NavEntry to convert to mkdocs.yml format required Returns: Type Description List[Union[str, Mapping[str, Union[str, MkdocsNav]]]] Python object of the mkdocs.yml nav entry. Source code in mkreports/settings.py def nav_to_mkdocs ( nav : Nav ) -> MkdocsNav : \"\"\" Convert a list of nav-entries into mkdocs format. Args: nav (Nav): The list of NavEntry to convert to mkdocs.yml format Returns: Python object of the mkdocs.yml nav entry. \"\"\" split_nokey , split_keys = split_nav ( nav ) res : MkdocsNav = [ str ( p ) for p in split_nokey ] for key , val in split_keys . items (): mkdocs_for_key = nav_to_mkdocs ( val ) # if it is a list of length 1 with a string, treat it special if len ( mkdocs_for_key ) == 1 and isinstance ( mkdocs_for_key [ 0 ], str ): res . append ({ key : mkdocs_for_key [ 0 ]}) else : res . append ({ key : mkdocs_for_key }) return res path_to_nav_entry ( path ) Turn a file path into a NavEntry. The path is split, each part of the path used as an element of the hierarchy. Snake-case are split into words with first letters capitalized. Parameters: Name Type Description Default path Path The path relative to the report docs folder to turn into a nav-entry. required Returns: Type Description NavEntry The NavEntry object representing the path and the hierarchy of navigation entries. Source code in mkreports/settings.py def path_to_nav_entry ( path : Path ) -> NavEntry : \"\"\" Turn a file path into a NavEntry. The path is split, each part of the path used as an element of the hierarchy. Snake-case are split into words with first letters capitalized. Args: path (Path): The path relative to the report docs folder to turn into a nav-entry. Returns: NavEntry: The NavEntry object representing the path and the hierarchy of navigation entries. \"\"\" return NavEntry ( tuple ( [ snake_to_text ( x ) for x in path . parent . parts ] + [ snake_to_text ( path . stem )] ), path , ) save_yaml ( obj , file ) Save object to yaml file. Parameters: Name Type Description Default obj Any The object to save. required file Path Filename to save it into. required Source code in mkreports/settings.py def save_yaml ( obj : Any , file : Path ) -> None : \"\"\" Save object to yaml file. Args: obj (Any): The object to save. file (Path): Filename to save it into. \"\"\" with file . open ( \"w\" ) as f : yaml . dump ( obj , f , default_flow_style = False ) split_nav ( x ) Split the navigation entry into top level list of items and dict of Navs. Given a nav-entry, each top-level item that is not a hierarchy itself is added to the return list. Every hierarchy will have its top level removed and entered into a dict, with the top-level hierarchy name as the key and the sub-nav as the value. Parameters: Name Type Description Default x Nav The list of NavEntry to process required Returns: Type Description Tuple[List[str], Dict[str, Nav]] Structure as explained above. Source code in mkreports/settings.py def split_nav ( x : Nav ) -> Tuple [ List [ str ], Dict [ str , Nav ]]: \"\"\" Split the navigation entry into top level list of items and dict of Navs. Given a nav-entry, each top-level item that is not a hierarchy itself is added to the return list. Every hierarchy will have its top level removed and entered into a dict, with the top-level hierarchy name as the key and the sub-nav as the value. Args: x (Nav): The list of NavEntry to process Returns: Tuple[List[str], Dict[str, Nav]]: Structure as explained above. \"\"\" res_nav = defaultdict ( list ) res_list = [] for ( h , p ) in x : if len ( h ) == 0 : res_list . append ( p ) else : res_nav [ h [ 0 ]] . append (( h [ 1 :], p )) return ( res_list , res_nav )","title":"settings"},{"location":"Reference/settings/#mkreports.settings.NavEntry","text":"An entry in the navigation tab. Parameters: Name Type Description Default hierarchy Sequence[str] List of navigation entries. required file Path Path to the page, relative to report docs folder. required Source code in mkreports/settings.py class NavEntry ( NamedTuple ): \"\"\" An entry in the navigation tab. Args: hierarchy (Sequence[str]): List of navigation entries. file (Path): Path to the page, relative to report docs folder. \"\"\" hierarchy : Sequence [ str ] file : Path","title":"NavEntry"},{"location":"Reference/settings/#mkreports.settings.NavEntry.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in mkreports/settings.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"Reference/settings/#mkreports.settings.NavEntry.__new__","text":"Create new instance of NavEntry(hierarchy, file)","title":"__new__()"},{"location":"Reference/settings/#mkreports.settings.NavEntry.__repr__","text":"Return a nicely formatted representation string Source code in mkreports/settings.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"Reference/settings/#mkreports.settings.add_nav_entry","text":"Add an additional entry to the Nav in mkdocs.yml Parameters: Name Type Description Default mkdocs_settings The mkdocs settings to update. required nav_entry NavEntry The NavEntry to add required Returns: Type Description Any The updated mkdocs_settings Source code in mkreports/settings.py def add_nav_entry ( mkdocs_settings , nav_entry : NavEntry ) -> Any : \"\"\" Add an additional entry to the Nav in mkdocs.yml Args: mkdocs_settings (): The mkdocs settings to update. nav_entry (NavEntry): The NavEntry to add Returns: The updated mkdocs_settings \"\"\" mkdocs_settings = deepcopy ( mkdocs_settings ) nav = mkdocs_to_nav ( mkdocs_settings [ \"nav\" ]) + [ nav_entry ] # we need to deduplicate nav = list ( unique_everseen ( nav )) mkdocs_nav = nav_to_mkdocs ( nav ) mkdocs_settings [ \"nav\" ] = mkdocs_nav return mkdocs_settings","title":"add_nav_entry()"},{"location":"Reference/settings/#mkreports.settings.load_yaml","text":"Load a yaml file, return empty dict if not exists. Parameters: Name Type Description Default file Path File to load required Returns: Type Description Any The value in the file, empty dict otherwise. Source code in mkreports/settings.py def load_yaml ( file : Path ) -> Any : \"\"\" Load a yaml file, return empty dict if not exists. Args: file (Path): File to load Returns: The value in the file, empty dict otherwise. \"\"\" if file . exists (): with file . open ( \"r\" ) as f : res = yaml . load ( f , Loader = yaml . Loader ) else : res = {} return res","title":"load_yaml()"},{"location":"Reference/settings/#mkreports.settings.mkdocs_to_nav","text":"Convert an mkdovs nav to a list of NavEntry. Parameters: Name Type Description Default mkdocs_nav List[Union[str, Mapping[str, Union[str, MkdocsNav]]]] A python representation of the nav-entry in the mkdocs.yml file. required Source code in mkreports/settings.py def mkdocs_to_nav ( mkdocs_nav : MkdocsNav ) -> Nav : \"\"\" Convert an mkdovs nav to a list of NavEntry. Args: mkdocs_nav: A python representation of the nav-entry in the mkdocs.yml file. \"\"\" res = [] for entry in mkdocs_nav : if isinstance ( entry , str ): res . append (([], Path ( entry ))) elif isinstance ( entry , Mapping ): key , val = _check_length_one ( entry ) if isinstance ( val , str ): res . append (([ key ], Path ( val ))) elif isinstance ( val , List ): res = res + [(( key ,) + tuple ( h ), p ) for ( h , p ) in mkdocs_to_nav ( val )] else : raise Exception ( \"Not expected type\" ) else : raise Exception ( \"Not expected type\" ) return res","title":"mkdocs_to_nav()"},{"location":"Reference/settings/#mkreports.settings.nav_to_mkdocs","text":"Convert a list of nav-entries into mkdocs format. Parameters: Name Type Description Default nav Nav The list of NavEntry to convert to mkdocs.yml format required Returns: Type Description List[Union[str, Mapping[str, Union[str, MkdocsNav]]]] Python object of the mkdocs.yml nav entry. Source code in mkreports/settings.py def nav_to_mkdocs ( nav : Nav ) -> MkdocsNav : \"\"\" Convert a list of nav-entries into mkdocs format. Args: nav (Nav): The list of NavEntry to convert to mkdocs.yml format Returns: Python object of the mkdocs.yml nav entry. \"\"\" split_nokey , split_keys = split_nav ( nav ) res : MkdocsNav = [ str ( p ) for p in split_nokey ] for key , val in split_keys . items (): mkdocs_for_key = nav_to_mkdocs ( val ) # if it is a list of length 1 with a string, treat it special if len ( mkdocs_for_key ) == 1 and isinstance ( mkdocs_for_key [ 0 ], str ): res . append ({ key : mkdocs_for_key [ 0 ]}) else : res . append ({ key : mkdocs_for_key }) return res","title":"nav_to_mkdocs()"},{"location":"Reference/settings/#mkreports.settings.path_to_nav_entry","text":"Turn a file path into a NavEntry. The path is split, each part of the path used as an element of the hierarchy. Snake-case are split into words with first letters capitalized. Parameters: Name Type Description Default path Path The path relative to the report docs folder to turn into a nav-entry. required Returns: Type Description NavEntry The NavEntry object representing the path and the hierarchy of navigation entries. Source code in mkreports/settings.py def path_to_nav_entry ( path : Path ) -> NavEntry : \"\"\" Turn a file path into a NavEntry. The path is split, each part of the path used as an element of the hierarchy. Snake-case are split into words with first letters capitalized. Args: path (Path): The path relative to the report docs folder to turn into a nav-entry. Returns: NavEntry: The NavEntry object representing the path and the hierarchy of navigation entries. \"\"\" return NavEntry ( tuple ( [ snake_to_text ( x ) for x in path . parent . parts ] + [ snake_to_text ( path . stem )] ), path , )","title":"path_to_nav_entry()"},{"location":"Reference/settings/#mkreports.settings.save_yaml","text":"Save object to yaml file. Parameters: Name Type Description Default obj Any The object to save. required file Path Filename to save it into. required Source code in mkreports/settings.py def save_yaml ( obj : Any , file : Path ) -> None : \"\"\" Save object to yaml file. Args: obj (Any): The object to save. file (Path): Filename to save it into. \"\"\" with file . open ( \"w\" ) as f : yaml . dump ( obj , f , default_flow_style = False )","title":"save_yaml()"},{"location":"Reference/settings/#mkreports.settings.split_nav","text":"Split the navigation entry into top level list of items and dict of Navs. Given a nav-entry, each top-level item that is not a hierarchy itself is added to the return list. Every hierarchy will have its top level removed and entered into a dict, with the top-level hierarchy name as the key and the sub-nav as the value. Parameters: Name Type Description Default x Nav The list of NavEntry to process required Returns: Type Description Tuple[List[str], Dict[str, Nav]] Structure as explained above. Source code in mkreports/settings.py def split_nav ( x : Nav ) -> Tuple [ List [ str ], Dict [ str , Nav ]]: \"\"\" Split the navigation entry into top level list of items and dict of Navs. Given a nav-entry, each top-level item that is not a hierarchy itself is added to the return list. Every hierarchy will have its top level removed and entered into a dict, with the top-level hierarchy name as the key and the sub-nav as the value. Args: x (Nav): The list of NavEntry to process Returns: Tuple[List[str], Dict[str, Nav]]: Structure as explained above. \"\"\" res_nav = defaultdict ( list ) res_list = [] for ( h , p ) in x : if len ( h ) == 0 : res_list . append ( p ) else : res_nav [ h [ 0 ]] . append (( h [ 1 :], p )) return ( res_list , res_nav )","title":"split_nav()"},{"location":"Reference/tracker/","text":"CodeBlock dataclass Structure representing information about a block of code. Parameters: Name Type Description Default filename str The name of the file with the code. required co_name str Name of the code block required line_start int Number of the line where the code block starts. required line_end int Number of the line where the code block ends. required Source code in mkreports/tracker.py @dataclass class CodeBlock : \"\"\" Structure representing information about a block of code. Args: filename (str): The name of the file with the code. co_name (str): Name of the code block line_start (int): Number of the line where the code block starts. line_end (int): Number of the line where the code block ends. \"\"\" filename : str co_name : str line_start : int line_end : int def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : \"\"\" Return a MdObj representing the code in the block. Args: relative_to (Optional[Path]): The path relative to which the title should be. name_only (bool): Should only the name of the code-file be used. Returns: Code: Code object with the code represented by the code block. \"\"\" code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , ) md_code ( self , relative_to = None , name_only = False ) Return a MdObj representing the code in the block. Parameters: Name Type Description Default relative_to Optional[Path] The path relative to which the title should be. None name_only bool Should only the name of the code-file be used. False Returns: Type Description Code Code object with the code represented by the code block. Source code in mkreports/tracker.py def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : \"\"\" Return a MdObj representing the code in the block. Args: relative_to (Optional[Path]): The path relative to which the title should be. name_only (bool): Should only the name of the code-file be used. Returns: Code: Code object with the code represented by the code block. \"\"\" code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , ) SimpleTracker ( BaseTracker ) Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. Source code in mkreports/tracker.py class SimpleTracker ( BaseTracker ): \"\"\" Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. \"\"\" def __init__ ( self ): \"\"\"Initialize the tracker.\"\"\" self . _active = False self . line_start = None self . line_end = None self . co_name = None def start ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Start the tracker. Args: frame_info (inspect.FrameInfo): A FrameInfo object of where the tracking starts. \"\"\" if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True def stop ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Stop the tracker. Args: frame_info (inspect.FrameInfo): FraneInfo where the tracking ends. \"\"\" if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False def code ( self ) -> List [ CodeBlock ]: \"\"\" Return the tracked code. Returns: List[CodeBlock]: List of code blocks. Here, the list is only of length 1. \"\"\" if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ] @property def active ( self ) -> bool : \"\"\" Returns: bool: Is the tracker currently active? \"\"\" return self . _active active : bool property readonly Returns: Type Description bool Is the tracker currently active? __init__ ( self ) special Initialize the tracker. Source code in mkreports/tracker.py def __init__ ( self ): \"\"\"Initialize the tracker.\"\"\" self . _active = False self . line_start = None self . line_end = None self . co_name = None code ( self ) Return the tracked code. Returns: Type Description List[CodeBlock] List of code blocks. Here, the list is only of length 1. Source code in mkreports/tracker.py def code ( self ) -> List [ CodeBlock ]: \"\"\" Return the tracked code. Returns: List[CodeBlock]: List of code blocks. Here, the list is only of length 1. \"\"\" if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ] start ( self , frame_info ) Start the tracker. Parameters: Name Type Description Default frame_info inspect.FrameInfo A FrameInfo object of where the tracking starts. required Source code in mkreports/tracker.py def start ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Start the tracker. Args: frame_info (inspect.FrameInfo): A FrameInfo object of where the tracking starts. \"\"\" if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True stop ( self , frame_info ) Stop the tracker. Parameters: Name Type Description Default frame_info inspect.FrameInfo FraneInfo where the tracking ends. required Source code in mkreports/tracker.py def stop ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Stop the tracker. Args: frame_info (inspect.FrameInfo): FraneInfo where the tracking ends. \"\"\" if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False read_file ( path , from_line = None , to_line = None ) Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Parameters: Name Type Description Default path Path Path to the code file. required from_line Optional[int] Starting line. None to_line Optional[int] Ending line. None Returns: Type Description Str String representing the code. Source code in mkreports/tracker.py def read_file ( path : Path , from_line : Optional [ int ] = None , to_line : Optional [ int ] = None ) -> str : \"\"\" Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Args: path (Path): Path to the code file. from_line (Optional[int]): Starting line. to_line (Optional[int]): Ending line. Returns: Str: String representing the code. \"\"\" with path . open ( \"r\" ) as f : lines = f . readlines () # the from_line to_line are line-numbers, not indices. to_line is included return \"\" . join ( lines [ slice ( from_line - 1 if from_line is not None else None , to_line , 1 )] )","title":"tracker"},{"location":"Reference/tracker/#mkreports.tracker.CodeBlock","text":"Structure representing information about a block of code. Parameters: Name Type Description Default filename str The name of the file with the code. required co_name str Name of the code block required line_start int Number of the line where the code block starts. required line_end int Number of the line where the code block ends. required Source code in mkreports/tracker.py @dataclass class CodeBlock : \"\"\" Structure representing information about a block of code. Args: filename (str): The name of the file with the code. co_name (str): Name of the code block line_start (int): Number of the line where the code block starts. line_end (int): Number of the line where the code block ends. \"\"\" filename : str co_name : str line_start : int line_end : int def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : \"\"\" Return a MdObj representing the code in the block. Args: relative_to (Optional[Path]): The path relative to which the title should be. name_only (bool): Should only the name of the code-file be used. Returns: Code: Code object with the code represented by the code block. \"\"\" code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , )","title":"CodeBlock"},{"location":"Reference/tracker/#mkreports.tracker.CodeBlock.md_code","text":"Return a MdObj representing the code in the block. Parameters: Name Type Description Default relative_to Optional[Path] The path relative to which the title should be. None name_only bool Should only the name of the code-file be used. False Returns: Type Description Code Code object with the code represented by the code block. Source code in mkreports/tracker.py def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : \"\"\" Return a MdObj representing the code in the block. Args: relative_to (Optional[Path]): The path relative to which the title should be. name_only (bool): Should only the name of the code-file be used. Returns: Code: Code object with the code represented by the code block. \"\"\" code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , )","title":"md_code()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker","text":"Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. Source code in mkreports/tracker.py class SimpleTracker ( BaseTracker ): \"\"\" Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. \"\"\" def __init__ ( self ): \"\"\"Initialize the tracker.\"\"\" self . _active = False self . line_start = None self . line_end = None self . co_name = None def start ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Start the tracker. Args: frame_info (inspect.FrameInfo): A FrameInfo object of where the tracking starts. \"\"\" if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True def stop ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Stop the tracker. Args: frame_info (inspect.FrameInfo): FraneInfo where the tracking ends. \"\"\" if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False def code ( self ) -> List [ CodeBlock ]: \"\"\" Return the tracked code. Returns: List[CodeBlock]: List of code blocks. Here, the list is only of length 1. \"\"\" if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ] @property def active ( self ) -> bool : \"\"\" Returns: bool: Is the tracker currently active? \"\"\" return self . _active","title":"SimpleTracker"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.active","text":"Returns: Type Description bool Is the tracker currently active?","title":"active"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.__init__","text":"Initialize the tracker. Source code in mkreports/tracker.py def __init__ ( self ): \"\"\"Initialize the tracker.\"\"\" self . _active = False self . line_start = None self . line_end = None self . co_name = None","title":"__init__()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.code","text":"Return the tracked code. Returns: Type Description List[CodeBlock] List of code blocks. Here, the list is only of length 1. Source code in mkreports/tracker.py def code ( self ) -> List [ CodeBlock ]: \"\"\" Return the tracked code. Returns: List[CodeBlock]: List of code blocks. Here, the list is only of length 1. \"\"\" if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ]","title":"code()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.start","text":"Start the tracker. Parameters: Name Type Description Default frame_info inspect.FrameInfo A FrameInfo object of where the tracking starts. required Source code in mkreports/tracker.py def start ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Start the tracker. Args: frame_info (inspect.FrameInfo): A FrameInfo object of where the tracking starts. \"\"\" if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True","title":"start()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.stop","text":"Stop the tracker. Parameters: Name Type Description Default frame_info inspect.FrameInfo FraneInfo where the tracking ends. required Source code in mkreports/tracker.py def stop ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Stop the tracker. Args: frame_info (inspect.FrameInfo): FraneInfo where the tracking ends. \"\"\" if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False","title":"stop()"},{"location":"Reference/tracker/#mkreports.tracker.read_file","text":"Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Parameters: Name Type Description Default path Path Path to the code file. required from_line Optional[int] Starting line. None to_line Optional[int] Ending line. None Returns: Type Description Str String representing the code. Source code in mkreports/tracker.py def read_file ( path : Path , from_line : Optional [ int ] = None , to_line : Optional [ int ] = None ) -> str : \"\"\" Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Args: path (Path): Path to the code file. from_line (Optional[int]): Starting line. to_line (Optional[int]): Ending line. Returns: Str: String representing the code. \"\"\" with path . open ( \"r\" ) as f : lines = f . readlines () # the from_line to_line are line-numbers, not indices. to_line is included return \"\" . join ( lines [ slice ( from_line - 1 if from_line is not None else None , to_line , 1 )] )","title":"read_file()"},{"location":"Reference/utils/","text":"find_comment_ids ( text ) Identify ids in a file. We encode IDs used in a file in markdown comments to make them easier to find. This function retrieves them. Parameters: Name Type Description Default text str The string to search for the IDs. required Returns: Type Description Set[str] A set with all identified IDs. Source code in mkreports/utils.py def find_comment_ids ( text : str ) -> Set [ str ]: \"\"\" Identify ids in a file. We encode IDs used in a file in markdown comments to make them easier to find. This function retrieves them. Args: text (str): The string to search for the IDs. Returns: Set[str]: A set with all identified IDs. \"\"\" text_split = text . split ( \" \\n \" ) # compile the parser comment_parser = parse . compile ( \"[comment]: # (id: {type} - {value} )\" ) found_ids = [] # get all occurences of an id, identify id-type and id-value for line in text_split : res = comment_parser . parse ( line ) if res is not None : assert isinstance ( res , parse . Result ) found_ids . append ( f \" { res [ 'type' ] } - { res [ 'value' ] } \" ) return set ( found_ids ) func_ref ( x ) Encode a function reference. Parameters: Name Type Description Default x str reference to a function. required Returns: Type Description str The encoded string. Source code in mkreports/utils.py def func_ref ( x : str ) -> str : \"\"\" Encode a function reference. Args: x (str): reference to a function. Returns: The encoded string. \"\"\" return f \"____ { x } ____\" relative_repo_root ( path ) Path relative to repo root or just the name. Parameters: Name Type Description Default path Union[Path, str] Path to analyze required Returns: Type Description str Path relative to the repo root, just the name otherwise. Source code in mkreports/utils.py def relative_repo_root ( path : Union [ Path , str ]) -> str : \"\"\" Path relative to repo root or just the name. Args: path (Union[Path, str]): Path to analyze Returns: str: Path relative to the repo root, just the name otherwise. \"\"\" try : repo = Repo ( \".\" , search_parent_directories = True ) root_dir = repo . working_tree_dir if root_dir is not None : return str ( Path ( path ) . relative_to ( root_dir )) except Exception : pass return Path ( path ) . name repo_root ( path = PosixPath ( '.' )) Find the root of the current repository. Parameters: Name Type Description Default path Path A path in the repository. PosixPath('.') Returns: Type Description Optional[Path] The root of the repo if it is a repo, None otherwise. Source code in mkreports/utils.py def repo_root ( path : Path = Path ( \".\" )) -> Optional [ Path ]: \"\"\" Find the root of the current repository. Args: path (Path): A path in the repository. Returns: Optional[Path]: The root of the repo if it is a repo, None otherwise. \"\"\" try : repo = Repo ( path , search_parent_directories = True ) return repo . working_tree_dir except Exception : pass return None serialize_json ( obj ) Serialize an object to JSON, removing quotes for special strings. Source code in mkreports/utils.py def serialize_json ( obj : Any ) -> str : \"\"\"Serialize an object to JSON, removing quotes for special strings.\"\"\" return json . dumps ( obj ) . replace ( '\"____' , \"\" ) . replace ( '____\"' , \"\" ) snake_to_text ( x ) Convert snake case to regular text, with each word capitalized. Source code in mkreports/utils.py def snake_to_text ( x : str ) -> str : \"\"\"Convert snake case to regular text, with each word capitalized.\"\"\" return \" \" . join ([ w . capitalize () for w in x . split ( \"_\" )])","title":"utils"},{"location":"Reference/utils/#mkreports.utils.find_comment_ids","text":"Identify ids in a file. We encode IDs used in a file in markdown comments to make them easier to find. This function retrieves them. Parameters: Name Type Description Default text str The string to search for the IDs. required Returns: Type Description Set[str] A set with all identified IDs. Source code in mkreports/utils.py def find_comment_ids ( text : str ) -> Set [ str ]: \"\"\" Identify ids in a file. We encode IDs used in a file in markdown comments to make them easier to find. This function retrieves them. Args: text (str): The string to search for the IDs. Returns: Set[str]: A set with all identified IDs. \"\"\" text_split = text . split ( \" \\n \" ) # compile the parser comment_parser = parse . compile ( \"[comment]: # (id: {type} - {value} )\" ) found_ids = [] # get all occurences of an id, identify id-type and id-value for line in text_split : res = comment_parser . parse ( line ) if res is not None : assert isinstance ( res , parse . Result ) found_ids . append ( f \" { res [ 'type' ] } - { res [ 'value' ] } \" ) return set ( found_ids )","title":"find_comment_ids()"},{"location":"Reference/utils/#mkreports.utils.func_ref","text":"Encode a function reference. Parameters: Name Type Description Default x str reference to a function. required Returns: Type Description str The encoded string. Source code in mkreports/utils.py def func_ref ( x : str ) -> str : \"\"\" Encode a function reference. Args: x (str): reference to a function. Returns: The encoded string. \"\"\" return f \"____ { x } ____\"","title":"func_ref()"},{"location":"Reference/utils/#mkreports.utils.relative_repo_root","text":"Path relative to repo root or just the name. Parameters: Name Type Description Default path Union[Path, str] Path to analyze required Returns: Type Description str Path relative to the repo root, just the name otherwise. Source code in mkreports/utils.py def relative_repo_root ( path : Union [ Path , str ]) -> str : \"\"\" Path relative to repo root or just the name. Args: path (Union[Path, str]): Path to analyze Returns: str: Path relative to the repo root, just the name otherwise. \"\"\" try : repo = Repo ( \".\" , search_parent_directories = True ) root_dir = repo . working_tree_dir if root_dir is not None : return str ( Path ( path ) . relative_to ( root_dir )) except Exception : pass return Path ( path ) . name","title":"relative_repo_root()"},{"location":"Reference/utils/#mkreports.utils.repo_root","text":"Find the root of the current repository. Parameters: Name Type Description Default path Path A path in the repository. PosixPath('.') Returns: Type Description Optional[Path] The root of the repo if it is a repo, None otherwise. Source code in mkreports/utils.py def repo_root ( path : Path = Path ( \".\" )) -> Optional [ Path ]: \"\"\" Find the root of the current repository. Args: path (Path): A path in the repository. Returns: Optional[Path]: The root of the repo if it is a repo, None otherwise. \"\"\" try : repo = Repo ( path , search_parent_directories = True ) return repo . working_tree_dir except Exception : pass return None","title":"repo_root()"},{"location":"Reference/utils/#mkreports.utils.serialize_json","text":"Serialize an object to JSON, removing quotes for special strings. Source code in mkreports/utils.py def serialize_json ( obj : Any ) -> str : \"\"\"Serialize an object to JSON, removing quotes for special strings.\"\"\" return json . dumps ( obj ) . replace ( '\"____' , \"\" ) . replace ( '____\"' , \"\" )","title":"serialize_json()"},{"location":"Reference/utils/#mkreports.utils.snake_to_text","text":"Convert snake case to regular text, with each word capitalized. Source code in mkreports/utils.py def snake_to_text ( x : str ) -> str : \"\"\"Convert snake case to regular text, with each word capitalized.\"\"\" return \" \" . join ([ w . capitalize () for w in x . split ( \"_\" )])","title":"snake_to_text()"},{"location":"Reference/md/base/","text":"Anchor ( MdObj ) Create an anchor object. Parameters: Name Type Description Default name str Name of the anchor. None Source code in mkreports/md/base.py @register_md ( \"Anchor\" ) class Anchor ( MdObj ): \"\"\" Create an anchor object. Args: name (str): Name of the anchor. \"\"\" def __init__ ( self , name : Optional [ str ] = None , prefix : str = \"anchor\" , page_info : Optional [ PageInfo ] = None , ): if name is None : assert page_info is not None assert page_info . idstore is not None # need to create it using the IDStore name = page_info . idstore . next_id ( prefix ) self . _back = SpacedText ( comment_ids ( name ), ( 2 , 2 )) else : self . _back = None self . name = name self . _body = SpacedText ( f \"[]() {{ :name=' { name } ' }} \" , ( 0 , 0 )) self . _settings = None Link ( MdObj ) dataclass Create a link to another page. Parameters: Name Type Description Default text str The text of the link '' url Optional[str] URL to link to. '' Source code in mkreports/md/base.py @register_md ( \"Link\" ) @dataclass () class Link ( MdObj ): \"\"\" Create a link to another page. Args: text (str): The text of the link url (Optional[str]): URL to link to. \"\"\" text : str = \"\" url : str = \"\" def __post_init__ ( self ): link = self . url self . _body = SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 )) self . _back = None self . _settings = None MdObj ( ABC ) A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. It enables adding of objects, which composes them sequentially. Added them adds the body and back separately as well as merges the settings. The body is being nested inside other objects as needed. The 'back' will always be added without indentation and after adding the body (this is useful for e.g. script-tags, but also markdown references). The settings will be added at the top of the page or the entire report, depending on what was requested. End-users should never have to call this class. Source code in mkreports/md/base.py class MdObj ( ABC ): \"\"\" A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. It enables adding of objects, which composes them sequentially. Added them adds the body and back separately as well as merges the settings. The body is being nested inside other objects as needed. The 'back' will always be added without indentation and after adding the body (this is useful for e.g. script-tags, but also markdown references). The settings will be added at the top of the page or the entire report, depending on what was requested. End-users should never have to call this class. \"\"\" _body : Optional [ SpacedText ] _back : Optional [ SpacedText ] _settings : Optional [ Settings ] def __add__ ( self , other ) -> \"MdSeq\" : first = self if isinstance ( self , MdSeq ) else MdSeq ([ self ]) second = other if isinstance ( other , MdSeq ) else MdSeq ([ other ]) return first + second def __radd__ ( self , other ) -> \"MdSeq\" : first = other if isinstance ( self , MdSeq ) else MdSeq ([ other ]) second = self if isinstance ( other , MdSeq ) else MdSeq ([ self ]) return first + second @property def body ( self ) -> SpacedText : \"\"\" Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: SpacedText: A string representing the body with info on how many newlines are expected before and after. \"\"\" return self . _body if self . _body is not None else SpacedText ( \"\" ) @property def back ( self ) -> SpacedText : \"\"\" Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: SpacedText: A string representing the backmatter with info on how many newlines are expected before and after. \"\"\" return self . _back if self . _back is not None else SpacedText ( \"\" ) @property def settings ( self ) -> Settings : \"\"\" Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Settings: A settings object. \"\"\" return self . _settings if self . _settings is not None else Settings () back : SpacedText property readonly Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: Type Description SpacedText A string representing the backmatter with info on how many newlines are expected before and after. body : SpacedText property readonly Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: Type Description SpacedText A string representing the body with info on how many newlines are expected before and after. settings : Settings property readonly Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Type Description Settings A settings object. MdSeq ( MdObj , Sequence ) Class to caputre a list of other MdObjs. Source code in mkreports/md/base.py @register_md ( \"MdSeq\" ) class MdSeq ( MdObj , Sequence ): \"\"\" Class to caputre a list of other MdObjs. \"\"\" items : Tuple [ MdObj , ... ] def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Args: items (Union[str, Iterable[Union[MdObj, str]]]): A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) def __getitem__ ( self , index : int ) -> MdObj : return self . items [ index ] def __len__ ( self ) -> int : return len ( self . items ) def __add__ ( self , other ) -> \"MdSeq\" : second_items = other . items if type ( other ) == MdSeq else ( other ,) return MdSeq ( self . items + second_items ) def __radd__ ( self , other ) -> \"MdSeq\" : second_items = other if type ( other ) == MdSeq else ( other ,) return MdSeq ( second_items + self . items ) @property def body ( self ) -> SpacedText : \"\"\" Body of the object in markdown - concatenating all individual items. Returns: SpacedText: The body as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . body for elem in self . items ] ) @property def back ( self ) -> SpacedText : \"\"\" Back of the object in markdown - concatenating all individual items. Returns: SpacedText: The back as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . back for elem in self . items ] ) @property def settings ( self ) -> Settings : \"\"\" Setting to be added to page or report. Returns: Settings: A settings object. \"\"\" if len ( self . items ) == 0 : return Settings () else : return functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in self . items ] ) back : SpacedText property readonly Back of the object in markdown - concatenating all individual items. Returns: Type Description SpacedText The back as a SpacedText object. body : SpacedText property readonly Body of the object in markdown - concatenating all individual items. Returns: Type Description SpacedText The body as a SpacedText object. settings : Settings property readonly Setting to be added to page or report. Returns: Type Description Settings A settings object. __init__ ( self , items = ()) special Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Parameters: Name Type Description Default items Union[str, Iterable[Union[MdObj, str]]] A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. () Source code in mkreports/md/base.py def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Args: items (Union[str, Iterable[Union[MdObj, str]]]): A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) Paragraph ( MdObj ) dataclass Wraps an object in a paragraph. Similar to 'Raw', but ensures 2 newlines before and after the text and supports adding an anchor to the paragraph. Source code in mkreports/md/base.py @register_md ( \"P\" ) @register_md ( \"Paragraph\" ) @dataclass class Paragraph ( MdObj ): \"\"\" Wraps an object in a paragraph. Similar to 'Raw', but ensures 2 newlines before and after the text and supports adding an anchor to the paragraph. \"\"\" obj : MdObj anchor : Optional [ Union [ Anchor , str ]] def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): \"\"\" Initialize the paragraph. Args: obj (Union[str, MdObj]): Markdown object or string. String will be wrapped in 'Raw'. anchor (Optional[Union[Anchor, str]]): Anchor to add to the paragraph. \"\"\" self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = SpacedText ( self . obj . body . text , ( 0 , 1 )) + self . anchor . body else : res_body = self . obj . body self . _body = SpacedText ( res_body , ( 2 , 2 )) self . _back = None if not isinstance ( self . anchor , Anchor ) else self . anchor . back self . _settings = None __init__ ( self , obj , anchor = None ) special Initialize the paragraph. Parameters: Name Type Description Default obj Union[str, MdObj] Markdown object or string. String will be wrapped in 'Raw'. required anchor Optional[Union[Anchor, str]] Anchor to add to the paragraph. None Source code in mkreports/md/base.py def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): \"\"\" Initialize the paragraph. Args: obj (Union[str, MdObj]): Markdown object or string. String will be wrapped in 'Raw'. anchor (Optional[Union[Anchor, str]]): Anchor to add to the paragraph. \"\"\" self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = SpacedText ( self . obj . body . text , ( 0 , 1 )) + self . anchor . body else : res_body = self . obj . body self . _body = SpacedText ( res_body , ( 2 , 2 )) self . _back = None if not isinstance ( self . anchor , Anchor ) else self . anchor . back self . _settings = None Raw ( MdObj ) dataclass Class to encapsulate raw markdown. Source code in mkreports/md/base.py @register_md ( \"Raw\" ) @dataclass () class Raw ( MdObj ): \"\"\" Class to encapsulate raw markdown. \"\"\" raw : Text page_settings : Dict [ str , Any ] mkdocs_settings : Dict [ str , Any ] def __init__ ( self , raw : Text = \"\" , dedent = True , back : Text = \"\" , page_settings = None , mkdocs_settings = None , ): \"\"\" Create the 'Raw' object. Args: raw (Text): The text to take as is to markdown. dedent (): Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. back (): The back to be added. As it has be be left-aligned, will always be dedented. page_settings (): Settings to be added for the page. mkdocs_settings (): Settings for the entire report. \"\"\" super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) if isinstance ( back , str ): back = textwrap . dedent ( back ) self . _body = SpacedText ( raw ) self . _back = SpacedText ( back ) self . _settings = Settings ( page = page_settings if page_settings is not None else {}, mkdocs = mkdocs_settings if mkdocs_settings is not None else {}, ) __init__ ( self , raw = '' , dedent = True , back = '' , page_settings = None , mkdocs_settings = None ) special Create the 'Raw' object. Parameters: Name Type Description Default raw Text The text to take as is to markdown. '' dedent Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. True back The back to be added. As it has be be left-aligned, will always be dedented. '' page_settings Settings to be added for the page. None mkdocs_settings Settings for the entire report. None Source code in mkreports/md/base.py def __init__ ( self , raw : Text = \"\" , dedent = True , back : Text = \"\" , page_settings = None , mkdocs_settings = None , ): \"\"\" Create the 'Raw' object. Args: raw (Text): The text to take as is to markdown. dedent (): Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. back (): The back to be added. As it has be be left-aligned, will always be dedented. page_settings (): Settings to be added for the page. mkdocs_settings (): Settings for the entire report. \"\"\" super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) if isinstance ( back , str ): back = textwrap . dedent ( back ) self . _body = SpacedText ( raw ) self . _back = SpacedText ( back ) self . _settings = Settings ( page = page_settings if page_settings is not None else {}, mkdocs = mkdocs_settings if mkdocs_settings is not None else {}, ) ReportLink ( Link ) Source code in mkreports/md/base.py @register_md ( \"ReportLink\" ) class ReportLink ( Link ): def __init__ ( self , text : str = \"\" , to_page_path : Optional [ Path ] = None , anchor : Optional [ Union [ str , Anchor ]] = None , page_info : Optional [ PageInfo ] = None , ): \"\"\" Create a link to another page in this report. Args: text (str): The text of the link page_info (Optional[PageInfo]): PageInfo object cotaining info of the page to_page_path (Optional[Path]): internal page to link to anchor (Optional[Union[str, Anchor]]): anchor to use \"\"\" assert page_info is not None assert ( page_path := page_info . page_path ) is not None if to_page_path is None : if anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \"# { anchor_id } \" else : # both are not none, do relative if anchor is None : link = f \" { relpath ( to_page_path , start = page_path . parent ) } \" else : anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \" { relpath ( to_page_path , start = page_path . parent ) } # { anchor_id } \" super () . __init__ ( text = text , url = link ) __init__ ( self , text = '' , to_page_path = None , anchor = None , page_info = None ) special Create a link to another page in this report. Parameters: Name Type Description Default text str The text of the link '' page_info Optional[PageInfo] PageInfo object cotaining info of the page None to_page_path Optional[Path] internal page to link to None anchor Optional[Union[str, Anchor]] anchor to use None Source code in mkreports/md/base.py def __init__ ( self , text : str = \"\" , to_page_path : Optional [ Path ] = None , anchor : Optional [ Union [ str , Anchor ]] = None , page_info : Optional [ PageInfo ] = None , ): \"\"\" Create a link to another page in this report. Args: text (str): The text of the link page_info (Optional[PageInfo]): PageInfo object cotaining info of the page to_page_path (Optional[Path]): internal page to link to anchor (Optional[Union[str, Anchor]]): anchor to use \"\"\" assert page_info is not None assert ( page_path := page_info . page_path ) is not None if to_page_path is None : if anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \"# { anchor_id } \" else : # both are not none, do relative if anchor is None : link = f \" { relpath ( to_page_path , start = page_path . parent ) } \" else : anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \" { relpath ( to_page_path , start = page_path . parent ) } # { anchor_id } \" super () . __init__ ( text = text , url = link ) comment ( x ) Create a comment for markdown. Parameters: Name Type Description Default x str The string to put into the comment. required Returns: Type Description SpacedText The comment line to be added as backmatter. Source code in mkreports/md/base.py def comment ( x : str ) -> SpacedText : \"\"\" Create a comment for markdown. Args: x (str): The string to put into the comment. Returns: SpacedText: The comment line to be added as backmatter. \"\"\" return SpacedText ( f \"[comment]: # ( { x } )\" , ( 2 , 1 )) comment_ids ( id ) Put an id into a comment. Parameters: Name Type Description Default id str The ID to insert. required Returns: Type Description SpacedText The comment-id to be added as backmatter. Source code in mkreports/md/base.py def comment_ids ( id : str ) -> SpacedText : \"\"\" Put an id into a comment. Args: id (str): The ID to insert. Returns: SpacedText: The comment-id to be added as backmatter. \"\"\" return comment ( f \"id: { id } \" )","title":"base"},{"location":"Reference/md/base/#mkreports.md.base.Anchor","text":"Create an anchor object. Parameters: Name Type Description Default name str Name of the anchor. None Source code in mkreports/md/base.py @register_md ( \"Anchor\" ) class Anchor ( MdObj ): \"\"\" Create an anchor object. Args: name (str): Name of the anchor. \"\"\" def __init__ ( self , name : Optional [ str ] = None , prefix : str = \"anchor\" , page_info : Optional [ PageInfo ] = None , ): if name is None : assert page_info is not None assert page_info . idstore is not None # need to create it using the IDStore name = page_info . idstore . next_id ( prefix ) self . _back = SpacedText ( comment_ids ( name ), ( 2 , 2 )) else : self . _back = None self . name = name self . _body = SpacedText ( f \"[]() {{ :name=' { name } ' }} \" , ( 0 , 0 )) self . _settings = None","title":"Anchor"},{"location":"Reference/md/base/#mkreports.md.base.Link","text":"Create a link to another page. Parameters: Name Type Description Default text str The text of the link '' url Optional[str] URL to link to. '' Source code in mkreports/md/base.py @register_md ( \"Link\" ) @dataclass () class Link ( MdObj ): \"\"\" Create a link to another page. Args: text (str): The text of the link url (Optional[str]): URL to link to. \"\"\" text : str = \"\" url : str = \"\" def __post_init__ ( self ): link = self . url self . _body = SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 )) self . _back = None self . _settings = None","title":"Link"},{"location":"Reference/md/base/#mkreports.md.base.MdObj","text":"A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. It enables adding of objects, which composes them sequentially. Added them adds the body and back separately as well as merges the settings. The body is being nested inside other objects as needed. The 'back' will always be added without indentation and after adding the body (this is useful for e.g. script-tags, but also markdown references). The settings will be added at the top of the page or the entire report, depending on what was requested. End-users should never have to call this class. Source code in mkreports/md/base.py class MdObj ( ABC ): \"\"\" A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. It enables adding of objects, which composes them sequentially. Added them adds the body and back separately as well as merges the settings. The body is being nested inside other objects as needed. The 'back' will always be added without indentation and after adding the body (this is useful for e.g. script-tags, but also markdown references). The settings will be added at the top of the page or the entire report, depending on what was requested. End-users should never have to call this class. \"\"\" _body : Optional [ SpacedText ] _back : Optional [ SpacedText ] _settings : Optional [ Settings ] def __add__ ( self , other ) -> \"MdSeq\" : first = self if isinstance ( self , MdSeq ) else MdSeq ([ self ]) second = other if isinstance ( other , MdSeq ) else MdSeq ([ other ]) return first + second def __radd__ ( self , other ) -> \"MdSeq\" : first = other if isinstance ( self , MdSeq ) else MdSeq ([ other ]) second = self if isinstance ( other , MdSeq ) else MdSeq ([ self ]) return first + second @property def body ( self ) -> SpacedText : \"\"\" Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: SpacedText: A string representing the body with info on how many newlines are expected before and after. \"\"\" return self . _body if self . _body is not None else SpacedText ( \"\" ) @property def back ( self ) -> SpacedText : \"\"\" Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: SpacedText: A string representing the backmatter with info on how many newlines are expected before and after. \"\"\" return self . _back if self . _back is not None else SpacedText ( \"\" ) @property def settings ( self ) -> Settings : \"\"\" Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Settings: A settings object. \"\"\" return self . _settings if self . _settings is not None else Settings ()","title":"MdObj"},{"location":"Reference/md/base/#mkreports.md.base.MdObj.back","text":"Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: Type Description SpacedText A string representing the backmatter with info on how many newlines are expected before and after.","title":"back"},{"location":"Reference/md/base/#mkreports.md.base.MdObj.body","text":"Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: Type Description SpacedText A string representing the body with info on how many newlines are expected before and after.","title":"body"},{"location":"Reference/md/base/#mkreports.md.base.MdObj.settings","text":"Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Type Description Settings A settings object.","title":"settings"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq","text":"Class to caputre a list of other MdObjs. Source code in mkreports/md/base.py @register_md ( \"MdSeq\" ) class MdSeq ( MdObj , Sequence ): \"\"\" Class to caputre a list of other MdObjs. \"\"\" items : Tuple [ MdObj , ... ] def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Args: items (Union[str, Iterable[Union[MdObj, str]]]): A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) def __getitem__ ( self , index : int ) -> MdObj : return self . items [ index ] def __len__ ( self ) -> int : return len ( self . items ) def __add__ ( self , other ) -> \"MdSeq\" : second_items = other . items if type ( other ) == MdSeq else ( other ,) return MdSeq ( self . items + second_items ) def __radd__ ( self , other ) -> \"MdSeq\" : second_items = other if type ( other ) == MdSeq else ( other ,) return MdSeq ( second_items + self . items ) @property def body ( self ) -> SpacedText : \"\"\" Body of the object in markdown - concatenating all individual items. Returns: SpacedText: The body as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . body for elem in self . items ] ) @property def back ( self ) -> SpacedText : \"\"\" Back of the object in markdown - concatenating all individual items. Returns: SpacedText: The back as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . back for elem in self . items ] ) @property def settings ( self ) -> Settings : \"\"\" Setting to be added to page or report. Returns: Settings: A settings object. \"\"\" if len ( self . items ) == 0 : return Settings () else : return functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in self . items ] )","title":"MdSeq"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq.back","text":"Back of the object in markdown - concatenating all individual items. Returns: Type Description SpacedText The back as a SpacedText object.","title":"back"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq.body","text":"Body of the object in markdown - concatenating all individual items. Returns: Type Description SpacedText The body as a SpacedText object.","title":"body"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq.settings","text":"Setting to be added to page or report. Returns: Type Description Settings A settings object.","title":"settings"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq.__init__","text":"Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Parameters: Name Type Description Default items Union[str, Iterable[Union[MdObj, str]]] A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. () Source code in mkreports/md/base.py def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Args: items (Union[str, Iterable[Union[MdObj, str]]]): A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ])","title":"__init__()"},{"location":"Reference/md/base/#mkreports.md.base.Paragraph","text":"Wraps an object in a paragraph. Similar to 'Raw', but ensures 2 newlines before and after the text and supports adding an anchor to the paragraph. Source code in mkreports/md/base.py @register_md ( \"P\" ) @register_md ( \"Paragraph\" ) @dataclass class Paragraph ( MdObj ): \"\"\" Wraps an object in a paragraph. Similar to 'Raw', but ensures 2 newlines before and after the text and supports adding an anchor to the paragraph. \"\"\" obj : MdObj anchor : Optional [ Union [ Anchor , str ]] def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): \"\"\" Initialize the paragraph. Args: obj (Union[str, MdObj]): Markdown object or string. String will be wrapped in 'Raw'. anchor (Optional[Union[Anchor, str]]): Anchor to add to the paragraph. \"\"\" self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = SpacedText ( self . obj . body . text , ( 0 , 1 )) + self . anchor . body else : res_body = self . obj . body self . _body = SpacedText ( res_body , ( 2 , 2 )) self . _back = None if not isinstance ( self . anchor , Anchor ) else self . anchor . back self . _settings = None","title":"Paragraph"},{"location":"Reference/md/base/#mkreports.md.base.Paragraph.__init__","text":"Initialize the paragraph. Parameters: Name Type Description Default obj Union[str, MdObj] Markdown object or string. String will be wrapped in 'Raw'. required anchor Optional[Union[Anchor, str]] Anchor to add to the paragraph. None Source code in mkreports/md/base.py def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): \"\"\" Initialize the paragraph. Args: obj (Union[str, MdObj]): Markdown object or string. String will be wrapped in 'Raw'. anchor (Optional[Union[Anchor, str]]): Anchor to add to the paragraph. \"\"\" self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = SpacedText ( self . obj . body . text , ( 0 , 1 )) + self . anchor . body else : res_body = self . obj . body self . _body = SpacedText ( res_body , ( 2 , 2 )) self . _back = None if not isinstance ( self . anchor , Anchor ) else self . anchor . back self . _settings = None","title":"__init__()"},{"location":"Reference/md/base/#mkreports.md.base.Raw","text":"Class to encapsulate raw markdown. Source code in mkreports/md/base.py @register_md ( \"Raw\" ) @dataclass () class Raw ( MdObj ): \"\"\" Class to encapsulate raw markdown. \"\"\" raw : Text page_settings : Dict [ str , Any ] mkdocs_settings : Dict [ str , Any ] def __init__ ( self , raw : Text = \"\" , dedent = True , back : Text = \"\" , page_settings = None , mkdocs_settings = None , ): \"\"\" Create the 'Raw' object. Args: raw (Text): The text to take as is to markdown. dedent (): Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. back (): The back to be added. As it has be be left-aligned, will always be dedented. page_settings (): Settings to be added for the page. mkdocs_settings (): Settings for the entire report. \"\"\" super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) if isinstance ( back , str ): back = textwrap . dedent ( back ) self . _body = SpacedText ( raw ) self . _back = SpacedText ( back ) self . _settings = Settings ( page = page_settings if page_settings is not None else {}, mkdocs = mkdocs_settings if mkdocs_settings is not None else {}, )","title":"Raw"},{"location":"Reference/md/base/#mkreports.md.base.Raw.__init__","text":"Create the 'Raw' object. Parameters: Name Type Description Default raw Text The text to take as is to markdown. '' dedent Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. True back The back to be added. As it has be be left-aligned, will always be dedented. '' page_settings Settings to be added for the page. None mkdocs_settings Settings for the entire report. None Source code in mkreports/md/base.py def __init__ ( self , raw : Text = \"\" , dedent = True , back : Text = \"\" , page_settings = None , mkdocs_settings = None , ): \"\"\" Create the 'Raw' object. Args: raw (Text): The text to take as is to markdown. dedent (): Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. back (): The back to be added. As it has be be left-aligned, will always be dedented. page_settings (): Settings to be added for the page. mkdocs_settings (): Settings for the entire report. \"\"\" super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) if isinstance ( back , str ): back = textwrap . dedent ( back ) self . _body = SpacedText ( raw ) self . _back = SpacedText ( back ) self . _settings = Settings ( page = page_settings if page_settings is not None else {}, mkdocs = mkdocs_settings if mkdocs_settings is not None else {}, )","title":"__init__()"},{"location":"Reference/md/base/#mkreports.md.base.ReportLink","text":"Source code in mkreports/md/base.py @register_md ( \"ReportLink\" ) class ReportLink ( Link ): def __init__ ( self , text : str = \"\" , to_page_path : Optional [ Path ] = None , anchor : Optional [ Union [ str , Anchor ]] = None , page_info : Optional [ PageInfo ] = None , ): \"\"\" Create a link to another page in this report. Args: text (str): The text of the link page_info (Optional[PageInfo]): PageInfo object cotaining info of the page to_page_path (Optional[Path]): internal page to link to anchor (Optional[Union[str, Anchor]]): anchor to use \"\"\" assert page_info is not None assert ( page_path := page_info . page_path ) is not None if to_page_path is None : if anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \"# { anchor_id } \" else : # both are not none, do relative if anchor is None : link = f \" { relpath ( to_page_path , start = page_path . parent ) } \" else : anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \" { relpath ( to_page_path , start = page_path . parent ) } # { anchor_id } \" super () . __init__ ( text = text , url = link )","title":"ReportLink"},{"location":"Reference/md/base/#mkreports.md.base.ReportLink.__init__","text":"Create a link to another page in this report. Parameters: Name Type Description Default text str The text of the link '' page_info Optional[PageInfo] PageInfo object cotaining info of the page None to_page_path Optional[Path] internal page to link to None anchor Optional[Union[str, Anchor]] anchor to use None Source code in mkreports/md/base.py def __init__ ( self , text : str = \"\" , to_page_path : Optional [ Path ] = None , anchor : Optional [ Union [ str , Anchor ]] = None , page_info : Optional [ PageInfo ] = None , ): \"\"\" Create a link to another page in this report. Args: text (str): The text of the link page_info (Optional[PageInfo]): PageInfo object cotaining info of the page to_page_path (Optional[Path]): internal page to link to anchor (Optional[Union[str, Anchor]]): anchor to use \"\"\" assert page_info is not None assert ( page_path := page_info . page_path ) is not None if to_page_path is None : if anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \"# { anchor_id } \" else : # both are not none, do relative if anchor is None : link = f \" { relpath ( to_page_path , start = page_path . parent ) } \" else : anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \" { relpath ( to_page_path , start = page_path . parent ) } # { anchor_id } \" super () . __init__ ( text = text , url = link )","title":"__init__()"},{"location":"Reference/md/base/#mkreports.md.base.comment","text":"Create a comment for markdown. Parameters: Name Type Description Default x str The string to put into the comment. required Returns: Type Description SpacedText The comment line to be added as backmatter. Source code in mkreports/md/base.py def comment ( x : str ) -> SpacedText : \"\"\" Create a comment for markdown. Args: x (str): The string to put into the comment. Returns: SpacedText: The comment line to be added as backmatter. \"\"\" return SpacedText ( f \"[comment]: # ( { x } )\" , ( 2 , 1 ))","title":"comment()"},{"location":"Reference/md/base/#mkreports.md.base.comment_ids","text":"Put an id into a comment. Parameters: Name Type Description Default id str The ID to insert. required Returns: Type Description SpacedText The comment-id to be added as backmatter. Source code in mkreports/md/base.py def comment_ids ( id : str ) -> SpacedText : \"\"\" Put an id into a comment. Args: id (str): The ID to insert. Returns: SpacedText: The comment-id to be added as backmatter. \"\"\" return comment ( f \"id: { id } \" )","title":"comment_ids()"},{"location":"Reference/md/combo/","text":"CollapsedCodeFile ( MdObj ) A code-file in a collapsed admonition. Source code in mkreports/md/combo.py @register_md ( \"CollapsedCodeFile\" ) class CollapsedCodeFile ( MdObj ): \"\"\"A code-file in a collapsed admonition.\"\"\" def __init__ ( self , file : Union [ Path , str ], page_info : PageInfo , title : str = \"Code\" ) -> None : \"\"\" Initialize the object. Args: file (Path): The file path (absolute or reltive to cwd) of the code-file. page_info (PageInfo): PageInfo about the page where it is to be added. title (str): Title on the admonition that is visible. \"\"\" file = Path ( file ) self . obj = Admonition ( CodeFile ( file , title = None , page_info = page_info , ), collapse = True , title = title , kind = \"code\" , page_info = page_info , ) self . _body = self . obj . body self . _back = self . obj . back self . _settings = self . obj . settings __init__ ( self , file , page_info , title = 'Code' ) special Initialize the object. Parameters: Name Type Description Default file Path The file path (absolute or reltive to cwd) of the code-file. required page_info PageInfo PageInfo about the page where it is to be added. required title str Title on the admonition that is visible. 'Code' Source code in mkreports/md/combo.py def __init__ ( self , file : Union [ Path , str ], page_info : PageInfo , title : str = \"Code\" ) -> None : \"\"\" Initialize the object. Args: file (Path): The file path (absolute or reltive to cwd) of the code-file. page_info (PageInfo): PageInfo about the page where it is to be added. title (str): Title on the admonition that is visible. \"\"\" file = Path ( file ) self . obj = Admonition ( CodeFile ( file , title = None , page_info = page_info , ), collapse = True , title = title , kind = \"code\" , page_info = page_info , ) self . _body = self . obj . body self . _back = self . obj . back self . _settings = self . obj . settings HLine ( Raw ) MdObj making a horizontal line. Source code in mkreports/md/combo.py @register_md ( \"HLine\" ) class HLine ( Raw ): \"\"\"MdObj making a horizontal line.\"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( SpacedText ( \"---\" , ( 2 , 2 ))) __init__ ( self ) special Initialize the object. Source code in mkreports/md/combo.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( SpacedText ( \"---\" , ( 2 , 2 ))) HideNav ( Raw ) Hide the Nav-bar on the page. Once added to a page, this can't be reversed. When the nav-bar is hidden, it can be hard to navigate. Consider added 'NavTabs', that show a header of navigation tabs. Please note that 'HideNav' affects only the current page, while adding NavTabs affects the entire report. Source code in mkreports/md/combo.py @register_md ( \"HideNav\" ) class HideNav ( Raw ): \"\"\" Hide the Nav-bar on the page. Once added to a page, this can't be reversed. When the nav-bar is hidden, it can be hard to navigate. Consider added 'NavTabs', that show a header of navigation tabs. Please note that 'HideNav' affects only the current page, while adding NavTabs affects the entire report. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"navigation\" ])) __init__ ( self ) special Initialize the object. Source code in mkreports/md/combo.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"navigation\" ])) HideToc ( Raw ) Hide the ToC on the page. Once added to a page, this can't be reversed. Source code in mkreports/md/combo.py @register_md ( \"HideToc\" ) class HideToc ( Raw ): \"\"\" Hide the ToC on the page. Once added to a page, this can't be reversed. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"toc\" ])) __init__ ( self ) special Initialize the object. Source code in mkreports/md/combo.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"toc\" ])) NavTabs ( Raw ) Add a header with navigation tabs. This cannot be reversed once added. Affects the entire report. Source code in mkreports/md/combo.py @register_md ( \"NavTabs\" ) class NavTabs ( Raw ): \"\"\" Add a header with navigation tabs. This cannot be reversed once added. Affects the entire report. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( mkdocs_settings = { \"theme\" : { \"features\" : [ \"navigation.tabs\" ]}}) __init__ ( self ) special Initialize the object. Source code in mkreports/md/combo.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( mkdocs_settings = { \"theme\" : { \"features\" : [ \"navigation.tabs\" ]}})","title":"combo"},{"location":"Reference/md/combo/#mkreports.md.combo.CollapsedCodeFile","text":"A code-file in a collapsed admonition. Source code in mkreports/md/combo.py @register_md ( \"CollapsedCodeFile\" ) class CollapsedCodeFile ( MdObj ): \"\"\"A code-file in a collapsed admonition.\"\"\" def __init__ ( self , file : Union [ Path , str ], page_info : PageInfo , title : str = \"Code\" ) -> None : \"\"\" Initialize the object. Args: file (Path): The file path (absolute or reltive to cwd) of the code-file. page_info (PageInfo): PageInfo about the page where it is to be added. title (str): Title on the admonition that is visible. \"\"\" file = Path ( file ) self . obj = Admonition ( CodeFile ( file , title = None , page_info = page_info , ), collapse = True , title = title , kind = \"code\" , page_info = page_info , ) self . _body = self . obj . body self . _back = self . obj . back self . _settings = self . obj . settings","title":"CollapsedCodeFile"},{"location":"Reference/md/combo/#mkreports.md.combo.CollapsedCodeFile.__init__","text":"Initialize the object. Parameters: Name Type Description Default file Path The file path (absolute or reltive to cwd) of the code-file. required page_info PageInfo PageInfo about the page where it is to be added. required title str Title on the admonition that is visible. 'Code' Source code in mkreports/md/combo.py def __init__ ( self , file : Union [ Path , str ], page_info : PageInfo , title : str = \"Code\" ) -> None : \"\"\" Initialize the object. Args: file (Path): The file path (absolute or reltive to cwd) of the code-file. page_info (PageInfo): PageInfo about the page where it is to be added. title (str): Title on the admonition that is visible. \"\"\" file = Path ( file ) self . obj = Admonition ( CodeFile ( file , title = None , page_info = page_info , ), collapse = True , title = title , kind = \"code\" , page_info = page_info , ) self . _body = self . obj . body self . _back = self . obj . back self . _settings = self . obj . settings","title":"__init__()"},{"location":"Reference/md/combo/#mkreports.md.combo.HLine","text":"MdObj making a horizontal line. Source code in mkreports/md/combo.py @register_md ( \"HLine\" ) class HLine ( Raw ): \"\"\"MdObj making a horizontal line.\"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( SpacedText ( \"---\" , ( 2 , 2 )))","title":"HLine"},{"location":"Reference/md/combo/#mkreports.md.combo.HLine.__init__","text":"Initialize the object. Source code in mkreports/md/combo.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( SpacedText ( \"---\" , ( 2 , 2 )))","title":"__init__()"},{"location":"Reference/md/combo/#mkreports.md.combo.HideNav","text":"Hide the Nav-bar on the page. Once added to a page, this can't be reversed. When the nav-bar is hidden, it can be hard to navigate. Consider added 'NavTabs', that show a header of navigation tabs. Please note that 'HideNav' affects only the current page, while adding NavTabs affects the entire report. Source code in mkreports/md/combo.py @register_md ( \"HideNav\" ) class HideNav ( Raw ): \"\"\" Hide the Nav-bar on the page. Once added to a page, this can't be reversed. When the nav-bar is hidden, it can be hard to navigate. Consider added 'NavTabs', that show a header of navigation tabs. Please note that 'HideNav' affects only the current page, while adding NavTabs affects the entire report. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"navigation\" ]))","title":"HideNav"},{"location":"Reference/md/combo/#mkreports.md.combo.HideNav.__init__","text":"Initialize the object. Source code in mkreports/md/combo.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"navigation\" ]))","title":"__init__()"},{"location":"Reference/md/combo/#mkreports.md.combo.HideToc","text":"Hide the ToC on the page. Once added to a page, this can't be reversed. Source code in mkreports/md/combo.py @register_md ( \"HideToc\" ) class HideToc ( Raw ): \"\"\" Hide the ToC on the page. Once added to a page, this can't be reversed. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"toc\" ]))","title":"HideToc"},{"location":"Reference/md/combo/#mkreports.md.combo.HideToc.__init__","text":"Initialize the object. Source code in mkreports/md/combo.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"toc\" ]))","title":"__init__()"},{"location":"Reference/md/combo/#mkreports.md.combo.NavTabs","text":"Add a header with navigation tabs. This cannot be reversed once added. Affects the entire report. Source code in mkreports/md/combo.py @register_md ( \"NavTabs\" ) class NavTabs ( Raw ): \"\"\" Add a header with navigation tabs. This cannot be reversed once added. Affects the entire report. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( mkdocs_settings = { \"theme\" : { \"features\" : [ \"navigation.tabs\" ]}})","title":"NavTabs"},{"location":"Reference/md/combo/#mkreports.md.combo.NavTabs.__init__","text":"Initialize the object. Source code in mkreports/md/combo.py def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( mkdocs_settings = { \"theme\" : { \"features\" : [ \"navigation.tabs\" ]}})","title":"__init__()"},{"location":"Reference/md/containers/","text":"Admonition ( MdObj ) dataclass An admonition to be added to a page. Can also be collapsed. For more details see also the Materials-theme for mkdocs. Parameters: Name Type Description Default obj Union[MdObj, Text] object in the admonition. Markdown object, string or SpacedText. required title Optional[str] title shown in the admonition. If missing, defaults to 'kind'. None kind Literal[ 'note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote', 'code'] The type of admonition to be shown. See also the Materials-theme for mkdocs for more details. 'note' collapse bool Should the admonition be collapsed? False page_info Optional[PageInfo] Only needed when 'kind==\"code\"'. None Source code in mkreports/md/containers.py @register_md ( \"Admonition\" ) @dataclass class Admonition ( MdObj ): \"\"\" An admonition to be added to a page. Can also be collapsed. For more details see also the Materials-theme for mkdocs. Args: obj (Union[MdObj, Text]): object in the admonition. Markdown object, string or SpacedText. title (Optional[str]): title shown in the admonition. If missing, defaults to 'kind'. kind (Literal[ 'note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote', 'code']): The type of admonition to be shown. See also the Materials-theme for mkdocs for more details. collapse (bool): Should the admonition be collapsed? page_info (Optional[PageInfo]): Only needed when 'kind==\"code\"'. \"\"\" obj : Union [ Text , MdObj ] title : Optional [ str ] = None kind : Literal [ \"note\" , \"abstract\" , \"info\" , \"tip\" , \"success\" , \"question\" , \"warning\" , \"failure\" , \"danger\" , \"bug\" , \"example\" , \"quote\" , \"code\" , ] = \"note\" collapse : bool = False page_info : Optional [ PageInfo ] = None def __post_init__ ( self ): if self . kind == \"code\" : assert self . page_info is not None assert self . page_info . javascript_path is not None javascript_path = self . page_info . javascript_path # create a css file that creates a 'code' admonition self . css_path = javascript_path / \"code_admonition.css\" javascript_path . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"code_admonition.css\" , self . css_path , ) # if code-admonition, we need to load additional css if self . kind == \"code\" : assert self . page_info is not None assert self . page_info . page_path is not None rel_css_path = relpath_html ( self . css_path , self . page_info . page_path ) page_settings = dict ( css = [ rel_css_path ]) else : page_settings = {} cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] }, page = page_settings , ) if isinstance ( self . obj , MdObj ): admon_text = self . obj . body back = self . obj . back settings = self . obj . settings settings = cont_settings + settings else : admon_text , back , settings = str ( self . obj ), SpacedText (), cont_settings if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' self . _body = SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ) ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )) self . _back = back self . _settings = settings Code ( MdObj ) dataclass Shows a code-block. Parameters: Name Type Description Default code str The code to be shown as a string. required title Optional[str] Optional title for the code block. None first_line Optional[int] Number at the first line. None hl_lines Optional[Tuple[int, int]] Line-range for highlighting. Is counted relative to 'first_line'. None language Optional[str] Language for syntax highlighting. 'python' dedent bool Should the string be de-dented? True Source code in mkreports/md/containers.py @register_md ( \"Code\" ) @dataclass class Code ( MdObj ): \"\"\" Shows a code-block. Args: code (str): The code to be shown as a string. title (Optional[str]): Optional title for the code block. first_line (Optional[int]): Number at the first line. hl_lines (Optional[Tuple[int, int]]): Line-range for highlighting. Is counted relative to 'first_line'. language (Optional[str]): Language for syntax highlighting. dedent (bool): Should the string be de-dented? \"\"\" code : str title : Optional [ str ] = None first_line : Optional [ int ] = None hl_lines : Optional [ Tuple [ int , int ]] = None language : Optional [ str ] = \"python\" dedent : bool = True def __post_init__ ( self ): annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) self . _body = SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ) self . _back = None self . _settings = settings CodeFile ( File ) Code block with the content of a file. Source code in mkreports/md/containers.py @register_md ( \"CodeFile\" ) class CodeFile ( File ): \"\"\" Code block with the content of a file. \"\"\" def __init__ ( self , path : Union [ Path , str ], page_info : PageInfo , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Set up the code-block with file content. Args: path (Union[Path, str]): Abolute path or relative to current working dir for the code-file to be included. page_info (PageInfo): PageInfo on the page where the code is to be added. title (Optional[str]): Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. hl_lines (Optional[Tuple[int, int]]): Optional range of lines for highlighting. language (Optional[str]): Language for syntax highlighting. \"\"\" assert page_info . project_root is not None assert page_info . report_path is not None path = Path ( path ) super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) self . title = ( title if title is not None else str ( path . relative_to ( page_info . project_root )) ) self . hl_lines = hl_lines self . language = language annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) self . _body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( page_info . report_path ) } '\" , annots ), ( 2 , 2 ), ) self . _back = None self . _settings = settings __init__ ( self , path , page_info , title = None , hl_lines = None , language = 'python' ) special Set up the code-block with file content. Parameters: Name Type Description Default path Union[Path, str] Abolute path or relative to current working dir for the code-file to be included. required page_info PageInfo PageInfo on the page where the code is to be added. required title Optional[str] Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. None hl_lines Optional[Tuple[int, int]] Optional range of lines for highlighting. None language Optional[str] Language for syntax highlighting. 'python' Source code in mkreports/md/containers.py def __init__ ( self , path : Union [ Path , str ], page_info : PageInfo , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Set up the code-block with file content. Args: path (Union[Path, str]): Abolute path or relative to current working dir for the code-file to be included. page_info (PageInfo): PageInfo on the page where the code is to be added. title (Optional[str]): Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. hl_lines (Optional[Tuple[int, int]]): Optional range of lines for highlighting. language (Optional[str]): Language for syntax highlighting. \"\"\" assert page_info . project_root is not None assert page_info . report_path is not None path = Path ( path ) super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) self . title = ( title if title is not None else str ( path . relative_to ( page_info . project_root )) ) self . hl_lines = hl_lines self . language = language annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) self . _body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( page_info . report_path ) } '\" , annots ), ( 2 , 2 ), ) self . _back = None self . _settings = settings Tab ( MdObj ) dataclass Tab interface Parameters: Name Type Description Default obj Union[Text, MdObj] The object to be shown in the tab. An MdObj, string or SpacedText. required title Optional[str] Optional title for the tab. None Source code in mkreports/md/containers.py @register_md ( \"Tab\" ) @dataclass class Tab ( MdObj ): \"\"\" Tab interface Args: obj (Union[Text, MdObj]): The object to be shown in the tab. An MdObj, string or SpacedText. title (Optional[str]): Optional title for the tab. \"\"\" obj : Union [ Text , MdObj ] title : Optional [ str ] = None def __post_init__ ( self ): tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . obj , MdObj ): tab_text = self . obj . body back = self . obj . back settings = self . obj . settings settings = tab_settings + settings else : tab_text , back , settings = str ( self . obj ), SpacedText (), tab_settings if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" self . _body = SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 ) ) self . _back = back self . _settings = settings","title":"containers"},{"location":"Reference/md/containers/#mkreports.md.containers.Admonition","text":"An admonition to be added to a page. Can also be collapsed. For more details see also the Materials-theme for mkdocs. Parameters: Name Type Description Default obj Union[MdObj, Text] object in the admonition. Markdown object, string or SpacedText. required title Optional[str] title shown in the admonition. If missing, defaults to 'kind'. None kind Literal[ 'note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote', 'code'] The type of admonition to be shown. See also the Materials-theme for mkdocs for more details. 'note' collapse bool Should the admonition be collapsed? False page_info Optional[PageInfo] Only needed when 'kind==\"code\"'. None Source code in mkreports/md/containers.py @register_md ( \"Admonition\" ) @dataclass class Admonition ( MdObj ): \"\"\" An admonition to be added to a page. Can also be collapsed. For more details see also the Materials-theme for mkdocs. Args: obj (Union[MdObj, Text]): object in the admonition. Markdown object, string or SpacedText. title (Optional[str]): title shown in the admonition. If missing, defaults to 'kind'. kind (Literal[ 'note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote', 'code']): The type of admonition to be shown. See also the Materials-theme for mkdocs for more details. collapse (bool): Should the admonition be collapsed? page_info (Optional[PageInfo]): Only needed when 'kind==\"code\"'. \"\"\" obj : Union [ Text , MdObj ] title : Optional [ str ] = None kind : Literal [ \"note\" , \"abstract\" , \"info\" , \"tip\" , \"success\" , \"question\" , \"warning\" , \"failure\" , \"danger\" , \"bug\" , \"example\" , \"quote\" , \"code\" , ] = \"note\" collapse : bool = False page_info : Optional [ PageInfo ] = None def __post_init__ ( self ): if self . kind == \"code\" : assert self . page_info is not None assert self . page_info . javascript_path is not None javascript_path = self . page_info . javascript_path # create a css file that creates a 'code' admonition self . css_path = javascript_path / \"code_admonition.css\" javascript_path . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"code_admonition.css\" , self . css_path , ) # if code-admonition, we need to load additional css if self . kind == \"code\" : assert self . page_info is not None assert self . page_info . page_path is not None rel_css_path = relpath_html ( self . css_path , self . page_info . page_path ) page_settings = dict ( css = [ rel_css_path ]) else : page_settings = {} cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] }, page = page_settings , ) if isinstance ( self . obj , MdObj ): admon_text = self . obj . body back = self . obj . back settings = self . obj . settings settings = cont_settings + settings else : admon_text , back , settings = str ( self . obj ), SpacedText (), cont_settings if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' self . _body = SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ) ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )) self . _back = back self . _settings = settings","title":"Admonition"},{"location":"Reference/md/containers/#mkreports.md.containers.Code","text":"Shows a code-block. Parameters: Name Type Description Default code str The code to be shown as a string. required title Optional[str] Optional title for the code block. None first_line Optional[int] Number at the first line. None hl_lines Optional[Tuple[int, int]] Line-range for highlighting. Is counted relative to 'first_line'. None language Optional[str] Language for syntax highlighting. 'python' dedent bool Should the string be de-dented? True Source code in mkreports/md/containers.py @register_md ( \"Code\" ) @dataclass class Code ( MdObj ): \"\"\" Shows a code-block. Args: code (str): The code to be shown as a string. title (Optional[str]): Optional title for the code block. first_line (Optional[int]): Number at the first line. hl_lines (Optional[Tuple[int, int]]): Line-range for highlighting. Is counted relative to 'first_line'. language (Optional[str]): Language for syntax highlighting. dedent (bool): Should the string be de-dented? \"\"\" code : str title : Optional [ str ] = None first_line : Optional [ int ] = None hl_lines : Optional [ Tuple [ int , int ]] = None language : Optional [ str ] = \"python\" dedent : bool = True def __post_init__ ( self ): annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) self . _body = SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ) self . _back = None self . _settings = settings","title":"Code"},{"location":"Reference/md/containers/#mkreports.md.containers.CodeFile","text":"Code block with the content of a file. Source code in mkreports/md/containers.py @register_md ( \"CodeFile\" ) class CodeFile ( File ): \"\"\" Code block with the content of a file. \"\"\" def __init__ ( self , path : Union [ Path , str ], page_info : PageInfo , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Set up the code-block with file content. Args: path (Union[Path, str]): Abolute path or relative to current working dir for the code-file to be included. page_info (PageInfo): PageInfo on the page where the code is to be added. title (Optional[str]): Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. hl_lines (Optional[Tuple[int, int]]): Optional range of lines for highlighting. language (Optional[str]): Language for syntax highlighting. \"\"\" assert page_info . project_root is not None assert page_info . report_path is not None path = Path ( path ) super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) self . title = ( title if title is not None else str ( path . relative_to ( page_info . project_root )) ) self . hl_lines = hl_lines self . language = language annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) self . _body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( page_info . report_path ) } '\" , annots ), ( 2 , 2 ), ) self . _back = None self . _settings = settings","title":"CodeFile"},{"location":"Reference/md/containers/#mkreports.md.containers.CodeFile.__init__","text":"Set up the code-block with file content. Parameters: Name Type Description Default path Union[Path, str] Abolute path or relative to current working dir for the code-file to be included. required page_info PageInfo PageInfo on the page where the code is to be added. required title Optional[str] Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. None hl_lines Optional[Tuple[int, int]] Optional range of lines for highlighting. None language Optional[str] Language for syntax highlighting. 'python' Source code in mkreports/md/containers.py def __init__ ( self , path : Union [ Path , str ], page_info : PageInfo , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Set up the code-block with file content. Args: path (Union[Path, str]): Abolute path or relative to current working dir for the code-file to be included. page_info (PageInfo): PageInfo on the page where the code is to be added. title (Optional[str]): Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. hl_lines (Optional[Tuple[int, int]]): Optional range of lines for highlighting. language (Optional[str]): Language for syntax highlighting. \"\"\" assert page_info . project_root is not None assert page_info . report_path is not None path = Path ( path ) super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) self . title = ( title if title is not None else str ( path . relative_to ( page_info . project_root )) ) self . hl_lines = hl_lines self . language = language annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) self . _body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( page_info . report_path ) } '\" , annots ), ( 2 , 2 ), ) self . _back = None self . _settings = settings","title":"__init__()"},{"location":"Reference/md/containers/#mkreports.md.containers.Tab","text":"Tab interface Parameters: Name Type Description Default obj Union[Text, MdObj] The object to be shown in the tab. An MdObj, string or SpacedText. required title Optional[str] Optional title for the tab. None Source code in mkreports/md/containers.py @register_md ( \"Tab\" ) @dataclass class Tab ( MdObj ): \"\"\" Tab interface Args: obj (Union[Text, MdObj]): The object to be shown in the tab. An MdObj, string or SpacedText. title (Optional[str]): Optional title for the tab. \"\"\" obj : Union [ Text , MdObj ] title : Optional [ str ] = None def __post_init__ ( self ): tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . obj , MdObj ): tab_text = self . obj . body back = self . obj . back settings = self . obj . settings settings = tab_settings + settings else : tab_text , back , settings = str ( self . obj ), SpacedText (), tab_settings if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" self . _body = SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 ) ) self . _back = back self . _settings = settings","title":"Tab"},{"location":"Reference/md/docstring/","text":"Docstring ( MdObj ) Add a docstring to the page. Source code in mkreports/md/docstring.py @register_md ( \"Docstring\" ) class Docstring ( MdObj ): \"\"\"Add a docstring to the page.\"\"\" def __init__ ( self , obj_name : str ) -> None : \"\"\" Docstring for the page. Args: obj_name (str): Name of the object for which a docstring should be added. \"\"\" super () . __init__ () self . obj_name = obj_name cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) self . _body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) self . _back = None self . _settings = cont_settings __init__ ( self , obj_name ) special Docstring for the page. Parameters: Name Type Description Default obj_name str Name of the object for which a docstring should be added. required Source code in mkreports/md/docstring.py def __init__ ( self , obj_name : str ) -> None : \"\"\" Docstring for the page. Args: obj_name (str): Name of the object for which a docstring should be added. \"\"\" super () . __init__ () self . obj_name = obj_name cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) self . _body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) self . _back = None self . _settings = cont_settings","title":"docstring"},{"location":"Reference/md/docstring/#mkreports.md.docstring.Docstring","text":"Add a docstring to the page. Source code in mkreports/md/docstring.py @register_md ( \"Docstring\" ) class Docstring ( MdObj ): \"\"\"Add a docstring to the page.\"\"\" def __init__ ( self , obj_name : str ) -> None : \"\"\" Docstring for the page. Args: obj_name (str): Name of the object for which a docstring should be added. \"\"\" super () . __init__ () self . obj_name = obj_name cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) self . _body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) self . _back = None self . _settings = cont_settings","title":"Docstring"},{"location":"Reference/md/docstring/#mkreports.md.docstring.Docstring.__init__","text":"Docstring for the page. Parameters: Name Type Description Default obj_name str Name of the object for which a docstring should be added. required Source code in mkreports/md/docstring.py def __init__ ( self , obj_name : str ) -> None : \"\"\" Docstring for the page. Args: obj_name (str): Name of the object for which a docstring should be added. \"\"\" super () . __init__ () self . obj_name = obj_name cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) self . _body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) self . _back = None self . _settings = cont_settings","title":"__init__()"},{"location":"Reference/md/file/","text":"File ( MdObj ) A stored file. This is typically not needed by the end-user. Source code in mkreports/md/file.py @register_md ( \"File\" ) class File ( MdObj ): \"\"\" A stored file. This is typically not needed by the end-user. \"\"\" path : Path allow_copy : bool use_hash : bool _hash : Optional [ str ] = None def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , allow_copy : bool = True , use_hash : bool = False , ) -> None : \"\"\" Store a file in the page-store. Args: path (Union[str, Path]): Path to the file, relative to current directory or absolute. page_info (PageInfo): PageInfo for the page where the file should be stored. allow_copy (bool): Is the file allowed to be copied? Otherwise, original location is used. use_hash (bool): If copy is allowed, renames the file to include the file hash. \"\"\" super () . __init__ () # store path needs to be set assert page_info . store_path is not None # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = page_info . store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path # it returns nothing self . _body = None self . _back = None self . _settings = None @property def hash ( self ) -> str : \"\"\" Calculate the hash of the file. Returns: str: Md5-hash as a string. \"\"\" if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash hash : str property readonly Calculate the hash of the file. Returns: Type Description str Md5-hash as a string. __init__ ( self , path , page_info , allow_copy = True , use_hash = False ) special Store a file in the page-store. Parameters: Name Type Description Default path Union[str, Path] Path to the file, relative to current directory or absolute. required page_info PageInfo PageInfo for the page where the file should be stored. required allow_copy bool Is the file allowed to be copied? Otherwise, original location is used. True use_hash bool If copy is allowed, renames the file to include the file hash. False Source code in mkreports/md/file.py def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , allow_copy : bool = True , use_hash : bool = False , ) -> None : \"\"\" Store a file in the page-store. Args: path (Union[str, Path]): Path to the file, relative to current directory or absolute. page_info (PageInfo): PageInfo for the page where the file should be stored. allow_copy (bool): Is the file allowed to be copied? Otherwise, original location is used. use_hash (bool): If copy is allowed, renames the file to include the file hash. \"\"\" super () . __init__ () # store path needs to be set assert page_info . store_path is not None # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = page_info . store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path # it returns nothing self . _body = None self . _back = None self . _settings = None md5_hash_file ( path ) Get md5 hash of a file. Parameters: Name Type Description Default path Path Absolute path or relative to current directory of the file. required Returns: Type Description str The md5 hash of the file. Source code in mkreports/md/file.py def md5_hash_file ( path : Path ) -> str : \"\"\" Get md5 hash of a file. Args: path (Path): Absolute path or relative to current directory of the file. Returns: str: The md5 hash of the file. \"\"\" m = hashlib . md5 () with path . open ( \"rb\" ) as f : m . update ( f . read ()) return m . hexdigest () relpath_html ( target , page_path ) Relative path as to be used for html. This is a bit more complicated, as some markdown pages are encoded as a directory (with implicit index.html being called). The paths can be relative or absolute. If relative, should be relative to same directory. Parameters: Name Type Description Default target Path The target path required page_path Path Path of the current page. required Returns: Type Description str Relative path as a string. Source code in mkreports/md/file.py def relpath_html ( target : Path , page_path : Path ) -> str : \"\"\" Relative path as to be used for html. This is a bit more complicated, as some markdown pages are encoded as a directory (with implicit index.html being called). The paths can be relative or absolute. If relative, should be relative to same directory. Args: target (Path): The target path page_path (Path): Path of the current page. Returns: str: Relative path as a string. \"\"\" if page_path . stem == \"index\" : # here, for translating to html, this path is referred to as its parent return relpath ( target , page_path . parent ) else : # for translating to html, will be converted to path.parent / path.stem / index.html return relpath ( target , page_path ) true_stem ( path ) True stem of a path, without all suffixes, not just last. Source code in mkreports/md/file.py def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"file"},{"location":"Reference/md/file/#mkreports.md.file.File","text":"A stored file. This is typically not needed by the end-user. Source code in mkreports/md/file.py @register_md ( \"File\" ) class File ( MdObj ): \"\"\" A stored file. This is typically not needed by the end-user. \"\"\" path : Path allow_copy : bool use_hash : bool _hash : Optional [ str ] = None def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , allow_copy : bool = True , use_hash : bool = False , ) -> None : \"\"\" Store a file in the page-store. Args: path (Union[str, Path]): Path to the file, relative to current directory or absolute. page_info (PageInfo): PageInfo for the page where the file should be stored. allow_copy (bool): Is the file allowed to be copied? Otherwise, original location is used. use_hash (bool): If copy is allowed, renames the file to include the file hash. \"\"\" super () . __init__ () # store path needs to be set assert page_info . store_path is not None # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = page_info . store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path # it returns nothing self . _body = None self . _back = None self . _settings = None @property def hash ( self ) -> str : \"\"\" Calculate the hash of the file. Returns: str: Md5-hash as a string. \"\"\" if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash","title":"File"},{"location":"Reference/md/file/#mkreports.md.file.File.hash","text":"Calculate the hash of the file. Returns: Type Description str Md5-hash as a string.","title":"hash"},{"location":"Reference/md/file/#mkreports.md.file.File.__init__","text":"Store a file in the page-store. Parameters: Name Type Description Default path Union[str, Path] Path to the file, relative to current directory or absolute. required page_info PageInfo PageInfo for the page where the file should be stored. required allow_copy bool Is the file allowed to be copied? Otherwise, original location is used. True use_hash bool If copy is allowed, renames the file to include the file hash. False Source code in mkreports/md/file.py def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , allow_copy : bool = True , use_hash : bool = False , ) -> None : \"\"\" Store a file in the page-store. Args: path (Union[str, Path]): Path to the file, relative to current directory or absolute. page_info (PageInfo): PageInfo for the page where the file should be stored. allow_copy (bool): Is the file allowed to be copied? Otherwise, original location is used. use_hash (bool): If copy is allowed, renames the file to include the file hash. \"\"\" super () . __init__ () # store path needs to be set assert page_info . store_path is not None # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = page_info . store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path # it returns nothing self . _body = None self . _back = None self . _settings = None","title":"__init__()"},{"location":"Reference/md/file/#mkreports.md.file.md5_hash_file","text":"Get md5 hash of a file. Parameters: Name Type Description Default path Path Absolute path or relative to current directory of the file. required Returns: Type Description str The md5 hash of the file. Source code in mkreports/md/file.py def md5_hash_file ( path : Path ) -> str : \"\"\" Get md5 hash of a file. Args: path (Path): Absolute path or relative to current directory of the file. Returns: str: The md5 hash of the file. \"\"\" m = hashlib . md5 () with path . open ( \"rb\" ) as f : m . update ( f . read ()) return m . hexdigest ()","title":"md5_hash_file()"},{"location":"Reference/md/file/#mkreports.md.file.relpath_html","text":"Relative path as to be used for html. This is a bit more complicated, as some markdown pages are encoded as a directory (with implicit index.html being called). The paths can be relative or absolute. If relative, should be relative to same directory. Parameters: Name Type Description Default target Path The target path required page_path Path Path of the current page. required Returns: Type Description str Relative path as a string. Source code in mkreports/md/file.py def relpath_html ( target : Path , page_path : Path ) -> str : \"\"\" Relative path as to be used for html. This is a bit more complicated, as some markdown pages are encoded as a directory (with implicit index.html being called). The paths can be relative or absolute. If relative, should be relative to same directory. Args: target (Path): The target path page_path (Path): Path of the current page. Returns: str: Relative path as a string. \"\"\" if page_path . stem == \"index\" : # here, for translating to html, this path is referred to as its parent return relpath ( target , page_path . parent ) else : # for translating to html, will be converted to path.parent / path.stem / index.html return relpath ( target , page_path )","title":"relpath_html()"},{"location":"Reference/md/file/#mkreports.md.file.true_stem","text":"True stem of a path, without all suffixes, not just last. Source code in mkreports/md/file.py def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"true_stem()"},{"location":"Reference/md/header/","text":"Heading ( MdObj ) dataclass Create a heading. Pre-defined heading levels exists as exported objects 'H1' to 'H7'. Parameters: Name Type Description Default title str The heading title. required level int Level of the heading. required style Literal[\"atx\", \"setext\"] Style of the heading in markdown. 'atx' anchor Optional[Union[Anchor, str]] Anchor to be added to heading. None Source code in mkreports/md/header.py @register_md ( \"Heading\" ) @dataclass class Heading ( MdObj ): \"\"\" Create a heading. Pre-defined heading levels exists as exported objects 'H1' to 'H7'. Args: title (str): The heading title. level (int): Level of the heading. style (Literal[\"atx\", \"setext\"]): Style of the heading in markdown. anchor (Optional[Union[Anchor, str]]): Anchor to be added to heading. \"\"\" title : str level : int style : Literal [ \"atx\" , \"setext\" ] = \"atx\" anchor : Optional [ Union [ Anchor , str ]] = None def __post_init__ ( self ): if isinstance ( self . anchor , Anchor ): self . _back = self . anchor . back else : self . _back = None if isinstance ( self . anchor , str ): self . anchor = Anchor ( self . anchor ) heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . body . text self . _body = SpacedText ( heading , ( 2 , 2 ), ) self . _settings = None","title":"header"},{"location":"Reference/md/header/#mkreports.md.header.Heading","text":"Create a heading. Pre-defined heading levels exists as exported objects 'H1' to 'H7'. Parameters: Name Type Description Default title str The heading title. required level int Level of the heading. required style Literal[\"atx\", \"setext\"] Style of the heading in markdown. 'atx' anchor Optional[Union[Anchor, str]] Anchor to be added to heading. None Source code in mkreports/md/header.py @register_md ( \"Heading\" ) @dataclass class Heading ( MdObj ): \"\"\" Create a heading. Pre-defined heading levels exists as exported objects 'H1' to 'H7'. Args: title (str): The heading title. level (int): Level of the heading. style (Literal[\"atx\", \"setext\"]): Style of the heading in markdown. anchor (Optional[Union[Anchor, str]]): Anchor to be added to heading. \"\"\" title : str level : int style : Literal [ \"atx\" , \"setext\" ] = \"atx\" anchor : Optional [ Union [ Anchor , str ]] = None def __post_init__ ( self ): if isinstance ( self . anchor , Anchor ): self . _back = self . anchor . back else : self . _back = None if isinstance ( self . anchor , str ): self . anchor = Anchor ( self . anchor ) heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . body . text self . _body = SpacedText ( heading , ( 2 , 2 ), ) self . _settings = None","title":"Heading"},{"location":"Reference/md/idstore/","text":"IDStore Store for ids. Used to create unique IDs on a page. Source code in mkreports/md/idstore.py class IDStore : \"\"\" Store for ids. Used to create unique IDs on a page. \"\"\" _counts : Dict [ str , int ] _used : set [ str ] def __init__ ( self , start_with : int = 0 , used_ids : set [ str ] = set ()) -> None : \"\"\" Initialize the IDStore. Args: start_with (int): First value of the counter. used_ids (set[str]): Set of IDs that have to be avoided as they are otherwise used. \"\"\" self . _count = defaultdict ( lambda : start_with - 1 ) self . _used = copy ( used_ids ) self . _start_with = start_with def _increment ( self , prefix : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" self . _count [ prefix ] += 1 return self . _count [ prefix ] def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. Args: prefix (str): Prefix to be used for the ID. Returns: str: ID as a string. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id __init__ ( self , start_with = 0 , used_ids = set ()) special Initialize the IDStore. Parameters: Name Type Description Default start_with int First value of the counter. 0 used_ids set[str] Set of IDs that have to be avoided as they are otherwise used. set() Source code in mkreports/md/idstore.py def __init__ ( self , start_with : int = 0 , used_ids : set [ str ] = set ()) -> None : \"\"\" Initialize the IDStore. Args: start_with (int): First value of the counter. used_ids (set[str]): Set of IDs that have to be avoided as they are otherwise used. \"\"\" self . _count = defaultdict ( lambda : start_with - 1 ) self . _used = copy ( used_ids ) self . _start_with = start_with next_id ( self , prefix ) Returns an id with a counted number at the end. Parameters: Name Type Description Default prefix str Prefix to be used for the ID. required Returns: Type Description str ID as a string. Source code in mkreports/md/idstore.py def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. Args: prefix (str): Prefix to be used for the ID. Returns: str: ID as a string. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id","title":"idstore"},{"location":"Reference/md/idstore/#mkreports.md.idstore.IDStore","text":"Store for ids. Used to create unique IDs on a page. Source code in mkreports/md/idstore.py class IDStore : \"\"\" Store for ids. Used to create unique IDs on a page. \"\"\" _counts : Dict [ str , int ] _used : set [ str ] def __init__ ( self , start_with : int = 0 , used_ids : set [ str ] = set ()) -> None : \"\"\" Initialize the IDStore. Args: start_with (int): First value of the counter. used_ids (set[str]): Set of IDs that have to be avoided as they are otherwise used. \"\"\" self . _count = defaultdict ( lambda : start_with - 1 ) self . _used = copy ( used_ids ) self . _start_with = start_with def _increment ( self , prefix : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" self . _count [ prefix ] += 1 return self . _count [ prefix ] def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. Args: prefix (str): Prefix to be used for the ID. Returns: str: ID as a string. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id","title":"IDStore"},{"location":"Reference/md/idstore/#mkreports.md.idstore.IDStore.__init__","text":"Initialize the IDStore. Parameters: Name Type Description Default start_with int First value of the counter. 0 used_ids set[str] Set of IDs that have to be avoided as they are otherwise used. set() Source code in mkreports/md/idstore.py def __init__ ( self , start_with : int = 0 , used_ids : set [ str ] = set ()) -> None : \"\"\" Initialize the IDStore. Args: start_with (int): First value of the counter. used_ids (set[str]): Set of IDs that have to be avoided as they are otherwise used. \"\"\" self . _count = defaultdict ( lambda : start_with - 1 ) self . _used = copy ( used_ids ) self . _start_with = start_with","title":"__init__()"},{"location":"Reference/md/idstore/#mkreports.md.idstore.IDStore.next_id","text":"Returns an id with a counted number at the end. Parameters: Name Type Description Default prefix str Prefix to be used for the ID. required Returns: Type Description str ID as a string. Source code in mkreports/md/idstore.py def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. Args: prefix (str): Prefix to be used for the ID. Returns: str: ID as a string. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id","title":"next_id()"},{"location":"Reference/md/image/","text":"Altair ( File ) Include an Altair image. Source code in mkreports/md/image.py @register_md ( \"Altair\" ) class Altair ( File ): \"\"\" Include an Altair image. \"\"\" def __init__ ( self , altair , page_info : PageInfo , ** kwargs , ): \"\"\" Create object to include an Altair image. Args: altair: An altair image. page_info (PageInfo): PageInfo to the page where it is to be included. \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"altair.csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True , ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = page_info . idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ) self . _settings = settings __init__ ( self , altair , page_info , ** kwargs ) special Create object to include an Altair image. Parameters: Name Type Description Default altair An altair image. required page_info PageInfo PageInfo to the page where it is to be included. required Source code in mkreports/md/image.py def __init__ ( self , altair , page_info : PageInfo , ** kwargs , ): \"\"\" Create object to include an Altair image. Args: altair: An altair image. page_info (PageInfo): PageInfo to the page where it is to be included. \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"altair.csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True , ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = page_info . idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ) self . _settings = settings Image ( ImageFile ) Source code in mkreports/md/image.py @register_md ( \"Image\" ) class Image ( ImageFile ): def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. \"\"\" if type ( image ) in image_save_funcs : # ok, we know how to save this: put it in temp dir first with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"image.\" + img_type ) image_save_funcs [ type ( image )]( image = image , path = path , width = width , height = height , dpi = dpi , units = units , ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = True , ) else : raise ValueError ( \"Unsupported image type\" ) __init__ ( self , image , page_info , width = None , height = None , units = 'in' , dpi = None , link_type = 'inline' , text = '' , tooltip = '' , img_type = 'png' ) special An image object for inclusion on a page. Parameters: Name Type Description Default image The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. required page_info PageInfo PageInfo for the page where the image should be included. required width Optional[float] width of the image None height Optional[float] height of the image None units Literal[\"in\", \"cm\", \"mm\"] units of the width and height 'in' dpi Optional[float] dpi of the image output. None link_type Literal[\"inline\", \"ref\"] Link-type to be used. 'inline' text str The alternative text if the image is not available. '' tooltip str The tooltip to use when hovering over the image. '' img_type Literal[\"jpg\", \"png\"] Type of the image to create during saving. 'png' Source code in mkreports/md/image.py def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. \"\"\" if type ( image ) in image_save_funcs : # ok, we know how to save this: put it in temp dir first with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"image.\" + img_type ) image_save_funcs [ type ( image )]( image = image , path = path , width = width , height = height , dpi = dpi , units = units , ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = True , ) else : raise ValueError ( \"Unsupported image type\" ) ImageFile ( File ) An image file. Source code in mkreports/md/image.py @register_md ( \"ImageFile\" ) class ImageFile ( File ): \"\"\"An image file.\"\"\" text : str tooltip : str link_type : str def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : \"\"\" Args: path (Union[str, Path]): Path to the image file. page_info (PageInfo): PageInfo object about the page. Added by page-wrapper link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Text shown if the image can't be displayed. tooltip (str): The tooltip shown when hovering over the image. allow_copy (bool): Should the image-file be copied to the store (Default: True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( path = path , page_info = page_info , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type # page_info needs to be set assert page_info . page_path is not None if self . link_type == \"inline\" : self . _body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_info . page_path . parent )), tooltip = self . tooltip , ) ) self . _back = None self . _settings = None elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" ) __init__ ( self , path , page_info , link_type = 'inline' , text = '' , tooltip = '' , allow_copy = True , use_hash = True ) special Parameters: Name Type Description Default path Union[str, Path] Path to the image file. required page_info PageInfo PageInfo object about the page. Added by page-wrapper required link_type Literal[\"inline\", \"ref\"] Link-type to use. 'inline' text str Text shown if the image can't be displayed. '' tooltip str The tooltip shown when hovering over the image. '' allow_copy bool Should the image-file be copied to the store (Default: True) True use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : \"\"\" Args: path (Union[str, Path]): Path to the image file. page_info (PageInfo): PageInfo object about the page. Added by page-wrapper link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Text shown if the image can't be displayed. tooltip (str): The tooltip shown when hovering over the image. allow_copy (bool): Should the image-file be copied to the store (Default: True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( path = path , page_info = page_info , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type # page_info needs to be set assert page_info . page_path is not None if self . link_type == \"inline\" : self . _body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_info . page_path . parent )), tooltip = self . tooltip , ) ) self . _back = None self . _settings = None elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" ) PIL ( ImageFile ) A PIL image for inclusion. Source code in mkreports/md/image.py @register_md ( \"PIL\" ) class PIL ( ImageFile ): \"\"\"A PIL image for inclusion.\"\"\" def __init__ ( self , image , page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , ) -> None : \"\"\" Create MdObj for PIL image. Args: image (PIL.Image.Image): an Image object from PIL page_info (PageInfo): PageInfo for the page where the image is to be included. link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Alternative text for the image. tooltip (str): Tooltip when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): File-type to use when saving the image. \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"pil_image.\" + img_type ) image . save ( path ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = True , ) __init__ ( self , image , page_info , link_type = 'inline' , text = '' , tooltip = '' , img_type = 'png' ) special Create MdObj for PIL image. Parameters: Name Type Description Default image PIL.Image.Image an Image object from PIL required page_info PageInfo PageInfo for the page where the image is to be included. required link_type Literal[\"inline\", \"ref\"] Link-type to use. 'inline' text str Alternative text for the image. '' tooltip str Tooltip when hovering over the image. '' img_type Literal[\"jpg\", \"png\"] File-type to use when saving the image. 'png' Source code in mkreports/md/image.py def __init__ ( self , image , page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , ) -> None : \"\"\" Create MdObj for PIL image. Args: image (PIL.Image.Image): an Image object from PIL page_info (PageInfo): PageInfo for the page where the image is to be included. link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Alternative text for the image. tooltip (str): Tooltip when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): File-type to use when saving the image. \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"pil_image.\" + img_type ) image . save ( path ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = True , ) Plotly ( File ) Plotly image as MdObj. Source code in mkreports/md/image.py @register_md ( \"Plotly\" ) class Plotly ( File ): \"\"\" Plotly image as MdObj. \"\"\" def __init__ ( self , plotly , page_info : PageInfo , ** kwargs , ): \"\"\" Initialize the Plotly MdObj. Args: plotly (): The plotly graph to plot. page_info (PageInfo): PageInfo to the page where it is to be included. \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"plotly.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = page_info . idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ) self . _settings = settings __init__ ( self , plotly , page_info , ** kwargs ) special Initialize the Plotly MdObj. Parameters: Name Type Description Default plotly The plotly graph to plot. required page_info PageInfo PageInfo to the page where it is to be included. required Source code in mkreports/md/image.py def __init__ ( self , plotly , page_info : PageInfo , ** kwargs , ): \"\"\" Initialize the Plotly MdObj. Args: plotly (): The plotly graph to plot. page_info (PageInfo): PageInfo to the page where it is to be included. \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"plotly.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = page_info . idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ) self . _settings = settings","title":"image"},{"location":"Reference/md/image/#mkreports.md.image.Altair","text":"Include an Altair image. Source code in mkreports/md/image.py @register_md ( \"Altair\" ) class Altair ( File ): \"\"\" Include an Altair image. \"\"\" def __init__ ( self , altair , page_info : PageInfo , ** kwargs , ): \"\"\" Create object to include an Altair image. Args: altair: An altair image. page_info (PageInfo): PageInfo to the page where it is to be included. \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"altair.csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True , ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = page_info . idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ) self . _settings = settings","title":"Altair"},{"location":"Reference/md/image/#mkreports.md.image.Altair.__init__","text":"Create object to include an Altair image. Parameters: Name Type Description Default altair An altair image. required page_info PageInfo PageInfo to the page where it is to be included. required Source code in mkreports/md/image.py def __init__ ( self , altair , page_info : PageInfo , ** kwargs , ): \"\"\" Create object to include an Altair image. Args: altair: An altair image. page_info (PageInfo): PageInfo to the page where it is to be included. \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"altair.csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True , ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = page_info . idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ) self . _settings = settings","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.Image","text":"Source code in mkreports/md/image.py @register_md ( \"Image\" ) class Image ( ImageFile ): def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. \"\"\" if type ( image ) in image_save_funcs : # ok, we know how to save this: put it in temp dir first with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"image.\" + img_type ) image_save_funcs [ type ( image )]( image = image , path = path , width = width , height = height , dpi = dpi , units = units , ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = True , ) else : raise ValueError ( \"Unsupported image type\" )","title":"Image"},{"location":"Reference/md/image/#mkreports.md.image.Image.__init__","text":"An image object for inclusion on a page. Parameters: Name Type Description Default image The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. required page_info PageInfo PageInfo for the page where the image should be included. required width Optional[float] width of the image None height Optional[float] height of the image None units Literal[\"in\", \"cm\", \"mm\"] units of the width and height 'in' dpi Optional[float] dpi of the image output. None link_type Literal[\"inline\", \"ref\"] Link-type to be used. 'inline' text str The alternative text if the image is not available. '' tooltip str The tooltip to use when hovering over the image. '' img_type Literal[\"jpg\", \"png\"] Type of the image to create during saving. 'png' Source code in mkreports/md/image.py def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. \"\"\" if type ( image ) in image_save_funcs : # ok, we know how to save this: put it in temp dir first with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"image.\" + img_type ) image_save_funcs [ type ( image )]( image = image , path = path , width = width , height = height , dpi = dpi , units = units , ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = True , ) else : raise ValueError ( \"Unsupported image type\" )","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.ImageFile","text":"An image file. Source code in mkreports/md/image.py @register_md ( \"ImageFile\" ) class ImageFile ( File ): \"\"\"An image file.\"\"\" text : str tooltip : str link_type : str def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : \"\"\" Args: path (Union[str, Path]): Path to the image file. page_info (PageInfo): PageInfo object about the page. Added by page-wrapper link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Text shown if the image can't be displayed. tooltip (str): The tooltip shown when hovering over the image. allow_copy (bool): Should the image-file be copied to the store (Default: True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( path = path , page_info = page_info , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type # page_info needs to be set assert page_info . page_path is not None if self . link_type == \"inline\" : self . _body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_info . page_path . parent )), tooltip = self . tooltip , ) ) self . _back = None self . _settings = None elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" )","title":"ImageFile"},{"location":"Reference/md/image/#mkreports.md.image.ImageFile.__init__","text":"Parameters: Name Type Description Default path Union[str, Path] Path to the image file. required page_info PageInfo PageInfo object about the page. Added by page-wrapper required link_type Literal[\"inline\", \"ref\"] Link-type to use. 'inline' text str Text shown if the image can't be displayed. '' tooltip str The tooltip shown when hovering over the image. '' allow_copy bool Should the image-file be copied to the store (Default: True) True use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : \"\"\" Args: path (Union[str, Path]): Path to the image file. page_info (PageInfo): PageInfo object about the page. Added by page-wrapper link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Text shown if the image can't be displayed. tooltip (str): The tooltip shown when hovering over the image. allow_copy (bool): Should the image-file be copied to the store (Default: True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( path = path , page_info = page_info , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type # page_info needs to be set assert page_info . page_path is not None if self . link_type == \"inline\" : self . _body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_info . page_path . parent )), tooltip = self . tooltip , ) ) self . _back = None self . _settings = None elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" )","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.PIL","text":"A PIL image for inclusion. Source code in mkreports/md/image.py @register_md ( \"PIL\" ) class PIL ( ImageFile ): \"\"\"A PIL image for inclusion.\"\"\" def __init__ ( self , image , page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , ) -> None : \"\"\" Create MdObj for PIL image. Args: image (PIL.Image.Image): an Image object from PIL page_info (PageInfo): PageInfo for the page where the image is to be included. link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Alternative text for the image. tooltip (str): Tooltip when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): File-type to use when saving the image. \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"pil_image.\" + img_type ) image . save ( path ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = True , )","title":"PIL"},{"location":"Reference/md/image/#mkreports.md.image.PIL.__init__","text":"Create MdObj for PIL image. Parameters: Name Type Description Default image PIL.Image.Image an Image object from PIL required page_info PageInfo PageInfo for the page where the image is to be included. required link_type Literal[\"inline\", \"ref\"] Link-type to use. 'inline' text str Alternative text for the image. '' tooltip str Tooltip when hovering over the image. '' img_type Literal[\"jpg\", \"png\"] File-type to use when saving the image. 'png' Source code in mkreports/md/image.py def __init__ ( self , image , page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , ) -> None : \"\"\" Create MdObj for PIL image. Args: image (PIL.Image.Image): an Image object from PIL page_info (PageInfo): PageInfo for the page where the image is to be included. link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Alternative text for the image. tooltip (str): Tooltip when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): File-type to use when saving the image. \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"pil_image.\" + img_type ) image . save ( path ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = True , )","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.Plotly","text":"Plotly image as MdObj. Source code in mkreports/md/image.py @register_md ( \"Plotly\" ) class Plotly ( File ): \"\"\" Plotly image as MdObj. \"\"\" def __init__ ( self , plotly , page_info : PageInfo , ** kwargs , ): \"\"\" Initialize the Plotly MdObj. Args: plotly (): The plotly graph to plot. page_info (PageInfo): PageInfo to the page where it is to be included. \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"plotly.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = page_info . idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ) self . _settings = settings","title":"Plotly"},{"location":"Reference/md/image/#mkreports.md.image.Plotly.__init__","text":"Initialize the Plotly MdObj. Parameters: Name Type Description Default plotly The plotly graph to plot. required page_info PageInfo PageInfo to the page where it is to be included. required Source code in mkreports/md/image.py def __init__ ( self , plotly , page_info : PageInfo , ** kwargs , ): \"\"\" Initialize the Plotly MdObj. Args: plotly (): The plotly graph to plot. page_info (PageInfo): PageInfo to the page where it is to be included. \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"plotly.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = page_info . idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ) self . _settings = settings","title":"__init__()"},{"location":"Reference/md/list/","text":"List ( MdObj ) Markdown list. Source code in mkreports/md/list.py @register_md ( \"List\" ) class List ( MdObj ): \"\"\" Markdown list. \"\"\" marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] list : MdSeq def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): \"\"\" Initialize the list as a markdown object. Args: items (Union[str, Iterable[Union[MdObj, str]]]): List of items in the list. marker (Literal[\"-\", \"*\", \"+\", \"1\"]): Marker to use for the list. \"\"\" super () . __init__ () self . list = MdSeq ( items ) self . marker = marker # create the markdown output for every item; indent it appropriately # and then put it all together. # create the body # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( self . num_items )] else : prefix = [ f \" { self . marker } \" ] * self . num_items md_list = [ _indent_hanging ( elem . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] self . _body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) self . _back = self . list . back self . _settings = self . list . settings def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : \"\"\" Append an item. This returns a new list, does not append to the old. Args: item (Union[Text, MdObj]): The item to append to the list. Returns: List: A list object with the new item appended. \"\"\" if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : \"\"\" Extend the list by additional items. The old list will not be updated. A new one will be created. Args: items (Sequence[Union[Text, MdObj]]): The items with which to extend the list. Returns: List: A new list object \"\"\" items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) @property def num_items ( self ) -> int : \"\"\" Number of items in the list. Returns: int: Number of items in the list. \"\"\" return len ( self . list ) num_items : int property readonly Number of items in the list. Returns: Type Description int Number of items in the list. __init__ ( self , items = (), marker = '-' ) special Initialize the list as a markdown object. Parameters: Name Type Description Default items Union[str, Iterable[Union[MdObj, str]]] List of items in the list. () marker Literal[\"-\", \"*\", \"+\", \"1\"] Marker to use for the list. '-' Source code in mkreports/md/list.py def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): \"\"\" Initialize the list as a markdown object. Args: items (Union[str, Iterable[Union[MdObj, str]]]): List of items in the list. marker (Literal[\"-\", \"*\", \"+\", \"1\"]): Marker to use for the list. \"\"\" super () . __init__ () self . list = MdSeq ( items ) self . marker = marker # create the markdown output for every item; indent it appropriately # and then put it all together. # create the body # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( self . num_items )] else : prefix = [ f \" { self . marker } \" ] * self . num_items md_list = [ _indent_hanging ( elem . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] self . _body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) self . _back = self . list . back self . _settings = self . list . settings append ( self , item ) Append an item. This returns a new list, does not append to the old. Parameters: Name Type Description Default item Union[Text, MdObj] The item to append to the list. required Returns: Type Description List A list object with the new item appended. Source code in mkreports/md/list.py def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : \"\"\" Append an item. This returns a new list, does not append to the old. Args: item (Union[Text, MdObj]): The item to append to the list. Returns: List: A list object with the new item appended. \"\"\" if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) extend ( self , items ) Extend the list by additional items. The old list will not be updated. A new one will be created. Parameters: Name Type Description Default items Sequence[Union[Text, MdObj]] The items with which to extend the list. required Returns: Type Description List A new list object Source code in mkreports/md/list.py def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : \"\"\" Extend the list by additional items. The old list will not be updated. A new one will be created. Args: items (Sequence[Union[Text, MdObj]]): The items with which to extend the list. Returns: List: A new list object \"\"\" items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker )","title":"list"},{"location":"Reference/md/list/#mkreports.md.list.List","text":"Markdown list. Source code in mkreports/md/list.py @register_md ( \"List\" ) class List ( MdObj ): \"\"\" Markdown list. \"\"\" marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] list : MdSeq def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): \"\"\" Initialize the list as a markdown object. Args: items (Union[str, Iterable[Union[MdObj, str]]]): List of items in the list. marker (Literal[\"-\", \"*\", \"+\", \"1\"]): Marker to use for the list. \"\"\" super () . __init__ () self . list = MdSeq ( items ) self . marker = marker # create the markdown output for every item; indent it appropriately # and then put it all together. # create the body # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( self . num_items )] else : prefix = [ f \" { self . marker } \" ] * self . num_items md_list = [ _indent_hanging ( elem . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] self . _body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) self . _back = self . list . back self . _settings = self . list . settings def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : \"\"\" Append an item. This returns a new list, does not append to the old. Args: item (Union[Text, MdObj]): The item to append to the list. Returns: List: A list object with the new item appended. \"\"\" if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : \"\"\" Extend the list by additional items. The old list will not be updated. A new one will be created. Args: items (Sequence[Union[Text, MdObj]]): The items with which to extend the list. Returns: List: A new list object \"\"\" items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) @property def num_items ( self ) -> int : \"\"\" Number of items in the list. Returns: int: Number of items in the list. \"\"\" return len ( self . list )","title":"List"},{"location":"Reference/md/list/#mkreports.md.list.List.num_items","text":"Number of items in the list. Returns: Type Description int Number of items in the list.","title":"num_items"},{"location":"Reference/md/list/#mkreports.md.list.List.__init__","text":"Initialize the list as a markdown object. Parameters: Name Type Description Default items Union[str, Iterable[Union[MdObj, str]]] List of items in the list. () marker Literal[\"-\", \"*\", \"+\", \"1\"] Marker to use for the list. '-' Source code in mkreports/md/list.py def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): \"\"\" Initialize the list as a markdown object. Args: items (Union[str, Iterable[Union[MdObj, str]]]): List of items in the list. marker (Literal[\"-\", \"*\", \"+\", \"1\"]): Marker to use for the list. \"\"\" super () . __init__ () self . list = MdSeq ( items ) self . marker = marker # create the markdown output for every item; indent it appropriately # and then put it all together. # create the body # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( self . num_items )] else : prefix = [ f \" { self . marker } \" ] * self . num_items md_list = [ _indent_hanging ( elem . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] self . _body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) self . _back = self . list . back self . _settings = self . list . settings","title":"__init__()"},{"location":"Reference/md/list/#mkreports.md.list.List.append","text":"Append an item. This returns a new list, does not append to the old. Parameters: Name Type Description Default item Union[Text, MdObj] The item to append to the list. required Returns: Type Description List A list object with the new item appended. Source code in mkreports/md/list.py def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : \"\"\" Append an item. This returns a new list, does not append to the old. Args: item (Union[Text, MdObj]): The item to append to the list. Returns: List: A list object with the new item appended. \"\"\" if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker )","title":"append()"},{"location":"Reference/md/list/#mkreports.md.list.List.extend","text":"Extend the list by additional items. The old list will not be updated. A new one will be created. Parameters: Name Type Description Default items Sequence[Union[Text, MdObj]] The items with which to extend the list. required Returns: Type Description List A new list object Source code in mkreports/md/list.py def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : \"\"\" Extend the list by additional items. The old list will not be updated. A new one will be created. Args: items (Sequence[Union[Text, MdObj]]): The items with which to extend the list. Returns: List: A new list object \"\"\" items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker )","title":"extend()"},{"location":"Reference/md/md_proxy/","text":"MdProxy Proxies the MdObj objects Makes the MdObj available with PageInfo prefilled. Source code in mkreports/md/md_proxy.py class MdProxy : \"\"\" Proxies the MdObj objects Makes the MdObj available with PageInfo prefilled. \"\"\" _proxied_classes : Dict [ str , Any ] = dict () def __init__ ( self , page_info : PageInfo ): \"\"\" Initialize the proxy. Args: page_info (PageInfo): The info of the page for which the proxy works. \"\"\" self . page_info = page_info def __getattr__ ( self , name ): # we are not checking if it is included; if not, should raise error if name in self . _proxied_classes : obj = self . _proxied_classes [ name ] else : raise AttributeError ( f \"No MdObj of name ' { name } ' registered\" ) # if is a class; try to fix the init method if inspect . isclass ( obj ): # check the init method signature partial_kwargs = {} obj_sig = inspect . signature ( obj ) if \"page_info\" in obj_sig . parameters : partial_kwargs [ \"page_info\" ] = self . page_info if len ( partial_kwargs ) > 0 : partial_obj = partial ( obj , ** partial_kwargs ) update_wrapper ( partial_obj , obj ) partial_obj . __doc__ = obj . __init__ . __doc__ return partial_obj else : return obj else : return obj @property def proxied_classes ( self ) -> Dict [ str , Any ]: \"\"\" Returns: Dict[str, Any]: A dict with the registered items under their name. \"\"\" return self . _proxied_classes proxied_classes : Dict [ str , Any ] property readonly Returns: Type Description Dict[str, Any] A dict with the registered items under their name. __init__ ( self , page_info ) special Initialize the proxy. Parameters: Name Type Description Default page_info PageInfo The info of the page for which the proxy works. required Source code in mkreports/md/md_proxy.py def __init__ ( self , page_info : PageInfo ): \"\"\" Initialize the proxy. Args: page_info (PageInfo): The info of the page for which the proxy works. \"\"\" self . page_info = page_info","title":"md_proxy"},{"location":"Reference/md/md_proxy/#mkreports.md.md_proxy.MdProxy","text":"Proxies the MdObj objects Makes the MdObj available with PageInfo prefilled. Source code in mkreports/md/md_proxy.py class MdProxy : \"\"\" Proxies the MdObj objects Makes the MdObj available with PageInfo prefilled. \"\"\" _proxied_classes : Dict [ str , Any ] = dict () def __init__ ( self , page_info : PageInfo ): \"\"\" Initialize the proxy. Args: page_info (PageInfo): The info of the page for which the proxy works. \"\"\" self . page_info = page_info def __getattr__ ( self , name ): # we are not checking if it is included; if not, should raise error if name in self . _proxied_classes : obj = self . _proxied_classes [ name ] else : raise AttributeError ( f \"No MdObj of name ' { name } ' registered\" ) # if is a class; try to fix the init method if inspect . isclass ( obj ): # check the init method signature partial_kwargs = {} obj_sig = inspect . signature ( obj ) if \"page_info\" in obj_sig . parameters : partial_kwargs [ \"page_info\" ] = self . page_info if len ( partial_kwargs ) > 0 : partial_obj = partial ( obj , ** partial_kwargs ) update_wrapper ( partial_obj , obj ) partial_obj . __doc__ = obj . __init__ . __doc__ return partial_obj else : return obj else : return obj @property def proxied_classes ( self ) -> Dict [ str , Any ]: \"\"\" Returns: Dict[str, Any]: A dict with the registered items under their name. \"\"\" return self . _proxied_classes","title":"MdProxy"},{"location":"Reference/md/md_proxy/#mkreports.md.md_proxy.MdProxy.proxied_classes","text":"Returns: Type Description Dict[str, Any] A dict with the registered items under their name.","title":"proxied_classes"},{"location":"Reference/md/md_proxy/#mkreports.md.md_proxy.MdProxy.__init__","text":"Initialize the proxy. Parameters: Name Type Description Default page_info PageInfo The info of the page for which the proxy works. required Source code in mkreports/md/md_proxy.py def __init__ ( self , page_info : PageInfo ): \"\"\" Initialize the proxy. Args: page_info (PageInfo): The info of the page for which the proxy works. \"\"\" self . page_info = page_info","title":"__init__()"},{"location":"Reference/md/settings/","text":"PageInfo ( tuple ) PageInfo(store_path, page_path, report_path, project_root, javascript_path, idstore) Source code in mkreports/md/settings.py class PageInfo ( NamedTuple ): store_path : Optional [ Path ] = None page_path : Optional [ Path ] = None report_path : Optional [ Path ] = None project_root : Optional [ Path ] = None javascript_path : Optional [ Path ] = None idstore : Optional [ IDStore ] = None __getnewargs__ ( self ) special Return self as a plain tuple. Used by copy and pickle. Source code in mkreports/md/settings.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , store_path = None , page_path = None , report_path = None , project_root = None , javascript_path = None , idstore = None ) special staticmethod Create new instance of PageInfo(store_path, page_path, report_path, project_root, javascript_path, idstore) __repr__ ( self ) special Return a nicely formatted representation string Source code in mkreports/md/settings.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self Settings dataclass Settings(mkdocs: Dict[str, Any] = , page: Dict[str, Any] = ) Source code in mkreports/md/settings.py @dataclass class Settings : mkdocs : Dict [ str , Any ] = field ( default_factory = dict ) page : Dict [ str , Any ] = field ( default_factory = dict ) def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), ) __add__ ( self , other ) special Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. Source code in mkreports/md/settings.py def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), ) strategy_append_new ( config , path , base , nxt ) prepend nxt to base. Source code in mkreports/md/settings.py def strategy_append_new ( config , path , base , nxt ): \"\"\"prepend nxt to base.\"\"\" del config , path return base + [ x for x in nxt if x not in base ]","title":"settings"},{"location":"Reference/md/settings/#mkreports.md.settings.PageInfo","text":"PageInfo(store_path, page_path, report_path, project_root, javascript_path, idstore) Source code in mkreports/md/settings.py class PageInfo ( NamedTuple ): store_path : Optional [ Path ] = None page_path : Optional [ Path ] = None report_path : Optional [ Path ] = None project_root : Optional [ Path ] = None javascript_path : Optional [ Path ] = None idstore : Optional [ IDStore ] = None","title":"PageInfo"},{"location":"Reference/md/settings/#mkreports.md.settings.PageInfo.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in mkreports/md/settings.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"Reference/md/settings/#mkreports.md.settings.PageInfo.__new__","text":"Create new instance of PageInfo(store_path, page_path, report_path, project_root, javascript_path, idstore)","title":"__new__()"},{"location":"Reference/md/settings/#mkreports.md.settings.PageInfo.__repr__","text":"Return a nicely formatted representation string Source code in mkreports/md/settings.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"Reference/md/settings/#mkreports.md.settings.Settings","text":"Settings(mkdocs: Dict[str, Any] = , page: Dict[str, Any] = ) Source code in mkreports/md/settings.py @dataclass class Settings : mkdocs : Dict [ str , Any ] = field ( default_factory = dict ) page : Dict [ str , Any ] = field ( default_factory = dict ) def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), )","title":"Settings"},{"location":"Reference/md/settings/#mkreports.md.settings.Settings.__add__","text":"Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. Source code in mkreports/md/settings.py def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), )","title":"__add__()"},{"location":"Reference/md/settings/#mkreports.md.settings.strategy_append_new","text":"prepend nxt to base. Source code in mkreports/md/settings.py def strategy_append_new ( config , path , base , nxt ): \"\"\"prepend nxt to base.\"\"\" del config , path return base + [ x for x in nxt if x not in base ]","title":"strategy_append_new()"},{"location":"Reference/md/table/","text":"DataTable ( File ) Table using DataTable javascript library. Source code in mkreports/md/table.py @register_md ( \"DataTable\" ) class DataTable ( File ): \"\"\"Table using DataTable javascript library.\"\"\" def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , column_settings : Optional [ dict ] = None , prettify_colnames : bool = True , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , ** kwargs , ): \"\"\" Initialize the table using the DataTable javascript library. Args: table (pd.DataFrame): The table in pandas.DataFrame format. page_info (PageInfo): PageInfo object for the page where the table should be located. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. column_settings (Optional[dict]): Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. prettify_colnames (bool): Run colnames through 'snake_to_text' function. add_header_filters (bool): Should header filters be added. yadcf_settings (Optional[dict]): Settings for the *yadcf* header filter plugin. Overrides any automatic settings. \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"datatable.json\" ) # here we use the split method; the index and columns if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # prepare the table settings if prettify_colnames : col_set = { col : { \"title\" : snake_to_text ( col ) if isinstance ( col , str ) else col } for col in table . columns } else : col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = _create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } datatable_id = page_info . idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = serialize_json ( table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ) self . _settings = settings __init__ ( self , table , page_info , max_rows = 1000 , column_settings = None , prettify_colnames = True , add_header_filters = False , yadcf_settings = None , ** kwargs ) special Initialize the table using the DataTable javascript library. Parameters: Name Type Description Default table pd.DataFrame The table in pandas.DataFrame format. required page_info PageInfo PageInfo object for the page where the table should be located. required max_rows Optional[int] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 1000 column_settings Optional[dict] Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. None prettify_colnames bool Run colnames through 'snake_to_text' function. True add_header_filters bool Should header filters be added. False yadcf_settings Optional[dict] Settings for the yadcf header filter plugin. Overrides any automatic settings. None Source code in mkreports/md/table.py def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , column_settings : Optional [ dict ] = None , prettify_colnames : bool = True , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , ** kwargs , ): \"\"\" Initialize the table using the DataTable javascript library. Args: table (pd.DataFrame): The table in pandas.DataFrame format. page_info (PageInfo): PageInfo object for the page where the table should be located. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. column_settings (Optional[dict]): Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. prettify_colnames (bool): Run colnames through 'snake_to_text' function. add_header_filters (bool): Should header filters be added. yadcf_settings (Optional[dict]): Settings for the *yadcf* header filter plugin. Overrides any automatic settings. \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"datatable.json\" ) # here we use the split method; the index and columns if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # prepare the table settings if prettify_colnames : col_set = { col : { \"title\" : snake_to_text ( col ) if isinstance ( col , str ) else col } for col in table . columns } else : col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = _create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } datatable_id = page_info . idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = serialize_json ( table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ) self . _settings = settings Table ( MdObj ) Standard markdown table. Source code in mkreports/md/table.py @register_md ( \"Table\" ) class Table ( MdObj ): \"\"\"Standard markdown table.\"\"\" table : pd . DataFrame kwargs : Dict [ str , Any ] def __init__ ( self , table : pd . DataFrame , max_rows : Optional [ int ] = 100 , ** kwargs ): \"\"\" Initialize the table object. Args: table (pd.DataFrame): The table to include in pandas format. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. \"\"\" super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) # check if the table has too many rows if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) self . table = self . table . iloc [ 0 : max_rows ] table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" self . _body = SpacedText ( table_md , ( 2 , 2 )) self . _back = None self . _settings = None __init__ ( self , table , max_rows = 100 , ** kwargs ) special Initialize the table object. Parameters: Name Type Description Default table pd.DataFrame The table to include in pandas format. required max_rows Optional[int] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 100 Source code in mkreports/md/table.py def __init__ ( self , table : pd . DataFrame , max_rows : Optional [ int ] = 100 , ** kwargs ): \"\"\" Initialize the table object. Args: table (pd.DataFrame): The table to include in pandas format. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. \"\"\" super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) # check if the table has too many rows if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) self . table = self . table . iloc [ 0 : max_rows ] table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" self . _body = SpacedText ( table_md , ( 2 , 2 )) self . _back = None self . _settings = None Tabulator ( File ) A table using the Tabulator javascript library. Source code in mkreports/md/table.py @register_md ( \"Tabulator\" ) class Tabulator ( File ): \"\"\"A table using the Tabulator javascript library.\"\"\" def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , ** kwargs , ): \"\"\" Args: table (pd.DataFrame): The table to be added. page_info (PageInfo): PageInfo for the page where the table should be added. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. table_settings (Optional[dict]): Settings passed to Tabulator as json. Overrides any internal settings created by this function. add_header_filters (bool): Should header-filters be added. prettify_colnames (bool): Run column names through *snake_to_text*. col_settings (Optional[dict]): Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None assert page_info . javascript_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"tabulator.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] table . to_json ( path , orient = \"records\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # create the javascript file self . min_max_filter_path = page_info . javascript_path / \"min_max_filter.js\" self . min_max_filter_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"tabulator_js\" / \"min_max_filter.js\" , self . min_max_filter_path , ) # produce the column settings col_list = _create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list tabulator_id = page_info . idstore . next_id ( \"tabulator_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_filter_path = relpath_html ( self . min_max_filter_path , page_info . page_path ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , rel_filter_path , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( tabulator_id ) self . _settings = settings __init__ ( self , table , page_info , max_rows = 1000 , table_settings = None , add_header_filters = True , prettify_colnames = True , col_settings = None , ** kwargs ) special Parameters: Name Type Description Default table pd.DataFrame The table to be added. required page_info PageInfo PageInfo for the page where the table should be added. required max_rows Optional[int] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 1000 table_settings Optional[dict] Settings passed to Tabulator as json. Overrides any internal settings created by this function. None add_header_filters bool Should header-filters be added. True prettify_colnames bool Run column names through snake_to_text . True col_settings Optional[dict] Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. None Source code in mkreports/md/table.py def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , ** kwargs , ): \"\"\" Args: table (pd.DataFrame): The table to be added. page_info (PageInfo): PageInfo for the page where the table should be added. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. table_settings (Optional[dict]): Settings passed to Tabulator as json. Overrides any internal settings created by this function. add_header_filters (bool): Should header-filters be added. prettify_colnames (bool): Run column names through *snake_to_text*. col_settings (Optional[dict]): Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None assert page_info . javascript_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"tabulator.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] table . to_json ( path , orient = \"records\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # create the javascript file self . min_max_filter_path = page_info . javascript_path / \"min_max_filter.js\" self . min_max_filter_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"tabulator_js\" / \"min_max_filter.js\" , self . min_max_filter_path , ) # produce the column settings col_list = _create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list tabulator_id = page_info . idstore . next_id ( \"tabulator_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_filter_path = relpath_html ( self . min_max_filter_path , page_info . page_path ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , rel_filter_path , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( tabulator_id ) self . _settings = settings","title":"table"},{"location":"Reference/md/table/#mkreports.md.table.DataTable","text":"Table using DataTable javascript library. Source code in mkreports/md/table.py @register_md ( \"DataTable\" ) class DataTable ( File ): \"\"\"Table using DataTable javascript library.\"\"\" def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , column_settings : Optional [ dict ] = None , prettify_colnames : bool = True , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , ** kwargs , ): \"\"\" Initialize the table using the DataTable javascript library. Args: table (pd.DataFrame): The table in pandas.DataFrame format. page_info (PageInfo): PageInfo object for the page where the table should be located. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. column_settings (Optional[dict]): Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. prettify_colnames (bool): Run colnames through 'snake_to_text' function. add_header_filters (bool): Should header filters be added. yadcf_settings (Optional[dict]): Settings for the *yadcf* header filter plugin. Overrides any automatic settings. \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"datatable.json\" ) # here we use the split method; the index and columns if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # prepare the table settings if prettify_colnames : col_set = { col : { \"title\" : snake_to_text ( col ) if isinstance ( col , str ) else col } for col in table . columns } else : col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = _create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } datatable_id = page_info . idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = serialize_json ( table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ) self . _settings = settings","title":"DataTable"},{"location":"Reference/md/table/#mkreports.md.table.DataTable.__init__","text":"Initialize the table using the DataTable javascript library. Parameters: Name Type Description Default table pd.DataFrame The table in pandas.DataFrame format. required page_info PageInfo PageInfo object for the page where the table should be located. required max_rows Optional[int] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 1000 column_settings Optional[dict] Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. None prettify_colnames bool Run colnames through 'snake_to_text' function. True add_header_filters bool Should header filters be added. False yadcf_settings Optional[dict] Settings for the yadcf header filter plugin. Overrides any automatic settings. None Source code in mkreports/md/table.py def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , column_settings : Optional [ dict ] = None , prettify_colnames : bool = True , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , ** kwargs , ): \"\"\" Initialize the table using the DataTable javascript library. Args: table (pd.DataFrame): The table in pandas.DataFrame format. page_info (PageInfo): PageInfo object for the page where the table should be located. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. column_settings (Optional[dict]): Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. prettify_colnames (bool): Run colnames through 'snake_to_text' function. add_header_filters (bool): Should header filters be added. yadcf_settings (Optional[dict]): Settings for the *yadcf* header filter plugin. Overrides any automatic settings. \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"datatable.json\" ) # here we use the split method; the index and columns if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # prepare the table settings if prettify_colnames : col_set = { col : { \"title\" : snake_to_text ( col ) if isinstance ( col , str ) else col } for col in table . columns } else : col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = _create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } datatable_id = page_info . idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajax\" ] = str ( rel_table_path ) settings_str = serialize_json ( table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ], css = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ) self . _settings = settings","title":"__init__()"},{"location":"Reference/md/table/#mkreports.md.table.Table","text":"Standard markdown table. Source code in mkreports/md/table.py @register_md ( \"Table\" ) class Table ( MdObj ): \"\"\"Standard markdown table.\"\"\" table : pd . DataFrame kwargs : Dict [ str , Any ] def __init__ ( self , table : pd . DataFrame , max_rows : Optional [ int ] = 100 , ** kwargs ): \"\"\" Initialize the table object. Args: table (pd.DataFrame): The table to include in pandas format. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. \"\"\" super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) # check if the table has too many rows if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) self . table = self . table . iloc [ 0 : max_rows ] table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" self . _body = SpacedText ( table_md , ( 2 , 2 )) self . _back = None self . _settings = None","title":"Table"},{"location":"Reference/md/table/#mkreports.md.table.Table.__init__","text":"Initialize the table object. Parameters: Name Type Description Default table pd.DataFrame The table to include in pandas format. required max_rows Optional[int] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 100 Source code in mkreports/md/table.py def __init__ ( self , table : pd . DataFrame , max_rows : Optional [ int ] = 100 , ** kwargs ): \"\"\" Initialize the table object. Args: table (pd.DataFrame): The table to include in pandas format. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. \"\"\" super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) # check if the table has too many rows if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) self . table = self . table . iloc [ 0 : max_rows ] table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" self . _body = SpacedText ( table_md , ( 2 , 2 )) self . _back = None self . _settings = None","title":"__init__()"},{"location":"Reference/md/table/#mkreports.md.table.Tabulator","text":"A table using the Tabulator javascript library. Source code in mkreports/md/table.py @register_md ( \"Tabulator\" ) class Tabulator ( File ): \"\"\"A table using the Tabulator javascript library.\"\"\" def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , ** kwargs , ): \"\"\" Args: table (pd.DataFrame): The table to be added. page_info (PageInfo): PageInfo for the page where the table should be added. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. table_settings (Optional[dict]): Settings passed to Tabulator as json. Overrides any internal settings created by this function. add_header_filters (bool): Should header-filters be added. prettify_colnames (bool): Run column names through *snake_to_text*. col_settings (Optional[dict]): Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None assert page_info . javascript_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"tabulator.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] table . to_json ( path , orient = \"records\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # create the javascript file self . min_max_filter_path = page_info . javascript_path / \"min_max_filter.js\" self . min_max_filter_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"tabulator_js\" / \"min_max_filter.js\" , self . min_max_filter_path , ) # produce the column settings col_list = _create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list tabulator_id = page_info . idstore . next_id ( \"tabulator_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_filter_path = relpath_html ( self . min_max_filter_path , page_info . page_path ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , rel_filter_path , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( tabulator_id ) self . _settings = settings","title":"Tabulator"},{"location":"Reference/md/table/#mkreports.md.table.Tabulator.__init__","text":"Parameters: Name Type Description Default table pd.DataFrame The table to be added. required page_info PageInfo PageInfo for the page where the table should be added. required max_rows Optional[int] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 1000 table_settings Optional[dict] Settings passed to Tabulator as json. Overrides any internal settings created by this function. None add_header_filters bool Should header-filters be added. True prettify_colnames bool Run column names through snake_to_text . True col_settings Optional[dict] Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. None Source code in mkreports/md/table.py def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , ** kwargs , ): \"\"\" Args: table (pd.DataFrame): The table to be added. page_info (PageInfo): PageInfo for the page where the table should be added. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. table_settings (Optional[dict]): Settings passed to Tabulator as json. Overrides any internal settings created by this function. add_header_filters (bool): Should header-filters be added. prettify_colnames (bool): Run column names through *snake_to_text*. col_settings (Optional[dict]): Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None assert page_info . javascript_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( \"tabulator.json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] table . to_json ( path , orient = \"records\" , default_handler = str , ** kwargs ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) # create the javascript file self . min_max_filter_path = page_info . javascript_path / \"min_max_filter.js\" self . min_max_filter_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( Path ( __file__ ) . parent / \"tabulator_js\" / \"min_max_filter.js\" , self . min_max_filter_path , ) # produce the column settings col_list = _create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list tabulator_id = page_info . idstore . next_id ( \"tabulator_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_filter_path = relpath_html ( self . min_max_filter_path , page_info . page_path ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , rel_filter_path , ], css = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( tabulator_id ) self . _settings = settings","title":"__init__()"},{"location":"Reference/md/text/","text":"SpacedText Representation of text with newlines before or after. Source code in mkreports/md/text.py class SpacedText : \"\"\"Representation of text with newlines before or after.\"\"\" text : str req_nl : Tuple [ int , int ] def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : \"\"\" Initialize the object. Args: text (Text): The text to print. req_nl (Tuple[int, int]): Number of newlines before and after to ensure. \"\"\" if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) def __eq__ ( self , other : Any ) -> bool : if type ( self ) != type ( other ): return False return self . text == other . text and self . req_nl == other . req_nl def __add__ ( self , follow : Text ) -> \"SpacedText\" : return _add_text ( self , SpacedText ( follow )) def __radd__ ( self , precede : Text ) -> \"SpacedText\" : return _add_text ( SpacedText ( precede ), self ) def format_text ( self , precede : Text = \"\" , follow : Text = \"\" ) -> str : add_before = _needed_nl_between ( SpacedText ( precede ), self ) add_after = _needed_nl_between ( self , SpacedText ( follow )) # return with the required additional newlines return ( \" \\n \" * add_before ) + self . text + ( \" \\n \" * add_after ) __init__ ( self , text = '' , req_nl = ( 0 , 0 )) special Initialize the object. Parameters: Name Type Description Default text Text The text to print. '' req_nl Tuple[int, int] Number of newlines before and after to ensure. (0, 0) Source code in mkreports/md/text.py def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : \"\"\" Initialize the object. Args: text (Text): The text to print. req_nl (Tuple[int, int]): Number of newlines before and after to ensure. \"\"\" if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl __str__ ( self ) special Return a formatted str. We assume that 3 newlines are before and after. That should be enough. Source code in mkreports/md/text.py def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) count_newlines ( x , before = True ) Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. Source code in mkreports/md/text.py def count_newlines ( x : str , before = True ) -> int : \"\"\" Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. \"\"\" num_nl = 0 whitespace = [ \" \" , \" \\r \" , \" \\t \" ] y = x if before else reversed ( x ) for ch in y : if ch == \" \\n \" : num_nl += 1 elif ch in whitespace : continue else : return num_nl return num_nl","title":"text"},{"location":"Reference/md/text/#mkreports.md.text.SpacedText","text":"Representation of text with newlines before or after. Source code in mkreports/md/text.py class SpacedText : \"\"\"Representation of text with newlines before or after.\"\"\" text : str req_nl : Tuple [ int , int ] def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : \"\"\" Initialize the object. Args: text (Text): The text to print. req_nl (Tuple[int, int]): Number of newlines before and after to ensure. \"\"\" if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) def __eq__ ( self , other : Any ) -> bool : if type ( self ) != type ( other ): return False return self . text == other . text and self . req_nl == other . req_nl def __add__ ( self , follow : Text ) -> \"SpacedText\" : return _add_text ( self , SpacedText ( follow )) def __radd__ ( self , precede : Text ) -> \"SpacedText\" : return _add_text ( SpacedText ( precede ), self ) def format_text ( self , precede : Text = \"\" , follow : Text = \"\" ) -> str : add_before = _needed_nl_between ( SpacedText ( precede ), self ) add_after = _needed_nl_between ( self , SpacedText ( follow )) # return with the required additional newlines return ( \" \\n \" * add_before ) + self . text + ( \" \\n \" * add_after )","title":"SpacedText"},{"location":"Reference/md/text/#mkreports.md.text.SpacedText.__init__","text":"Initialize the object. Parameters: Name Type Description Default text Text The text to print. '' req_nl Tuple[int, int] Number of newlines before and after to ensure. (0, 0) Source code in mkreports/md/text.py def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : \"\"\" Initialize the object. Args: text (Text): The text to print. req_nl (Tuple[int, int]): Number of newlines before and after to ensure. \"\"\" if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl","title":"__init__()"},{"location":"Reference/md/text/#mkreports.md.text.SpacedText.__str__","text":"Return a formatted str. We assume that 3 newlines are before and after. That should be enough. Source code in mkreports/md/text.py def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" )","title":"__str__()"},{"location":"Reference/md/text/#mkreports.md.text.count_newlines","text":"Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. Source code in mkreports/md/text.py def count_newlines ( x : str , before = True ) -> int : \"\"\" Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. \"\"\" num_nl = 0 whitespace = [ \" \" , \" \\r \" , \" \\t \" ] y = x if before else reversed ( x ) for ch in y : if ch == \" \\n \" : num_nl += 1 elif ch in whitespace : continue else : return num_nl return num_nl","title":"count_newlines()"},{"location":"site_code/__init__/","text":"__init__.py","title":"  Init  "},{"location":"site_code/basic/","text":"basic.py from mkreports import Report , md def use_basic ( report : Report ) -> None : p = report . page ( \"usage/basic.md\" , truncate = True ) p . H1 ( \"Basic formatting elements\" ) p . CollapsedCodeFile ( __file__ ) with p . H2 ( \"Headings\" , anchor = ( heading_anchor := p . md . Anchor ())): p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) with p . H2 ( \"Lists\" ) as p2 : numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) with p . H2 ( \"Links\" ) as p2 : p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Basic"},{"location":"site_code/code_blocks/","text":"code_blocks.py from mkreports import Report def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" p = report . page ( \"usage/code_blocks.md\" , truncate = True ) with p . H1 ( \"Code blocks\" ) . ctx ( \"top-c\" ): p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" )","title":"Code Blocks"},{"location":"site_code/images/","text":"images.py import matplotlib.pyplot as plt import numpy as np import seaborn as sns from mkreports import Report from PIL import Image from plotnine import aes , facet_wrap , geom_point , ggplot , stat_smooth from plotnine.data import mtcars def use_images ( report : Report ) -> None : \"\"\" Show all different ways on how we can include images. \"\"\" p = report . page ( \"usage/images.md\" , truncate = True ) # we don't need an indentation for everything if we don't want p . H1 ( \"Images\" ) p . CollapsedCodeFile ( __file__ ) p . H2 ( \"Supported formats\" ) p . Raw ( \"\"\" Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an `ImageFile` object. \"\"\" ) with p . H3 ( \"PIL\" ): p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) with p . H3 ( \"Matplotlib\" ): p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Image ( fig ) with p . H3 ( \"Plotnine\" ): p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) with p . H3 ( \"Seaborn\" ): p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) with p . H3 ( \"Altair\" ): import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) with p . H3 ( \"Plotly\" ): import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) p . H2 ( \"Different image sizes\" ) p . P ( \"\"\" In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change. \"\"\" ) with p . H3 ( \"Plotnine\" ): p . H4 ( \"Larger\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , )","title":"Images"},{"location":"site_code/main/","text":"main.py import inspect import shutil from pathlib import Path import mkreports import typer from mkreports import Report , add_pkg_docs from .basic import use_basic from .code_blocks import use_code_blocks from .images import use_images from .quickstart import do_quickstart from .sidebar import use_sidebar from .tables import use_tables def add_md_pages ( report : Report ): \"\"\" Add pages written in pure markdown format. \"\"\" # open the page, and copy the other one over it index_page = report . page ( \"index.md\" ) shutil . copy ( Path ( __file__ ) . parent / \"index.md\" , index_page . path ) markdown_page = report . page ( \"usage/markdown.md\" ) shutil . copy ( Path ( __file__ ) . parent / \"markdown.md\" , markdown_page . path ) plugins_page = report . page ( \"usage/plugins.md\" ) shutil . copy ( Path ( __file__ ) . parent / \"plugins.md\" , plugins_page . path ) ipython_page = report . page ( \"usage/ipython.md\" ) shutil . copy ( Path ( __file__ ) . parent / \"ipython.md\" , ipython_page . path ) def add_code_pages ( report : Report , code_dir : Path ): code_files = list ( code_dir . glob ( \"**/*.py\" )) code_files . sort () for code_file in code_files : rel_code_file = code_file . relative_to ( code_dir ) site_file_name = \"site_code\" / rel_code_file . with_suffix ( \".md\" ) p = report . page ( site_file_name , truncate = True ) with code_file . open ( \"r\" ) as f : p . Code ( f . read (), language = \"python\" , title = str ( rel_code_file )) def run_all ( report : Report ): do_quickstart ( report ) add_md_pages ( report ) use_basic ( report ) # documentation for images use_images ( report ) # documentation for tables use_tables ( report ) # documentation for code blocks use_code_blocks ( report ) # sidebar use_sidebar ( report ) # add the docstrings add_pkg_docs ( Path ( inspect . getfile ( mkreports )) . parent , parent_name = \"Reference\" , report = report , omit_package_name = True , ) add_code_pages ( report , Path ( __file__ ) . parent ) def main ( report_dir : Path ): report = Report . create ( report_dir , report_name = \"Mkreports documentations\" , exist_ok = True ) run_all ( report ) if __name__ == \"__main__\" : typer . run ( main )","title":"Main"},{"location":"site_code/quickstart/","text":"quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Image ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report )","title":"Quickstart"},{"location":"site_code/sidebar/","text":"sidebar.py from mkreports import Report def use_sidebar ( report : Report ) -> None : p = report . page ( \"usage/sidebar\" , truncate = True ) p . CollapsedCodeFile ( __file__ ) p . H1 ( \"Sidebars\" ) p . P ( \"\"\" We can hide the table of contents sidebar as well as the navigation bar. On this page, we only hide the ToC. When hiding the navigation bar, you should think about setting navigation tabs as well (otherwise there is no direct navigation option. Below a code block showing how to hide the ToC, Nav and set the navigations tabs. \"\"\" ) p . HideToc () p . Code ( \"\"\" p.HideToc() p.HideNav() p.NavTabs() \"\"\" )","title":"Sidebar"},{"location":"site_code/tables/","text":"tables.py import pandas as pd from mkreports import Report , md from plotnine.data import mtcars def use_tables ( report : Report ) -> None : \"\"\" Show all the different ways on how we can work with tables. \"\"\" ex_table = pd . DataFrame ( [ { \"name\" : \"Alfred\" , \"age\" : 30 , \"hair\" : \"red\" , \"married\" : True }, { \"name\" : \"Beate\" , \"age\" : 50 , \"hair\" : \"brown\" , \"married\" : False }, { \"name\" : \"Caro\" , \"age\" : 7 , \"hair\" : \"green\" , \"married\" : False , }, ] ) ex_table [ \"hair\" ] = pd . Categorical ( ex_table . hair ) p = report . page ( \"usage/tables.md\" , truncate = True ) p . H1 ( \"Different ways of handling tables\" ) p . CollapsedCodeFile ( __file__ ) p . Raw ( \"\"\" Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. \"\"\" ) with p . H2 ( \"Markdown tables\" ): p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) with p . H2 ( \"DataTable javascript library\" ): p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) with p . H2 ( \"Tabulator javascript library\" ): p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Notes\" ): p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" )","title":"Tables"},{"location":"usage/basic/","text":"Basic formatting elements Code docs/staging/basic.py from mkreports import Report , md def use_basic ( report : Report ) -> None : p = report . page ( \"usage/basic.md\" , truncate = True ) p . H1 ( \"Basic formatting elements\" ) p . CollapsedCodeFile ( __file__ ) with p . H2 ( \"Headings\" , anchor = ( heading_anchor := p . md . Anchor ())): p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) with p . H2 ( \"Lists\" ) as p2 : numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) with p . H2 ( \"Links\" ) as p2 : p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" ) Headings Content Code Available headings md . H1 ( \"Header type 1\" ) md . H2 ( \"Header type 2\" ) md . H3 ( \"Header type 3\" ) md . H4 ( \"Header type 4\" ) md . H5 ( \"Header type 5\" ) md . H6 ( \"Header type 6\" ) md . H7 ( \"Header type 7\" ) docs/staging/basic.py 12 13 14 15 16 17 18 19 20 21 22 23 p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) Lists Content Code First item Second item Third item Some fruit: apples pears strawberry A code block: Hello world print ( \"Hello world\" ) docs/staging/basic.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) Links Content Code A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) A link back to the first heading A link to another page Images Or just to any page Google Or of course also just straight markdown Google docs/staging/basic.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Basic"},{"location":"usage/basic/#basic-formatting-elements","text":"Code docs/staging/basic.py from mkreports import Report , md def use_basic ( report : Report ) -> None : p = report . page ( \"usage/basic.md\" , truncate = True ) p . H1 ( \"Basic formatting elements\" ) p . CollapsedCodeFile ( __file__ ) with p . H2 ( \"Headings\" , anchor = ( heading_anchor := p . md . Anchor ())): p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) with p . H2 ( \"Lists\" ) as p2 : numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) with p . H2 ( \"Links\" ) as p2 : p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Basic formatting elements"},{"location":"usage/basic/#headings","text":"Content Code Available headings md . H1 ( \"Header type 1\" ) md . H2 ( \"Header type 2\" ) md . H3 ( \"Header type 3\" ) md . H4 ( \"Header type 4\" ) md . H5 ( \"Header type 5\" ) md . H6 ( \"Header type 6\" ) md . H7 ( \"Header type 7\" ) docs/staging/basic.py 12 13 14 15 16 17 18 19 20 21 22 23 p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , )","title":"Headings"},{"location":"usage/basic/#lists","text":"Content Code First item Second item Third item Some fruit: apples pears strawberry A code block: Hello world print ( \"Hello world\" ) docs/staging/basic.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list )","title":"Lists"},{"location":"usage/basic/#links","text":"Content Code A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) A link back to the first heading A link to another page Images Or just to any page Google Or of course also just straight markdown Google docs/staging/basic.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Links"},{"location":"usage/code_blocks/","text":"Code blocks Code docs/staging/code_blocks.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. Tracking code (tabbed) Content Code One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. fib(3) = 2 By default, the tabbed version will be used, but there are also the options top-c : Collapsed code block at the top top-o : Open code block at the top bottom-c : Collapsed code block at the bottom bottom-o : Open code block at the bottom The default style can be set when creating the page using the code_layout parameter, but can also be set one at a time later using the ctx method on a page. docs/staging/code_blocks.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) Tracking code (top-c) Code docs/staging/code_blocks.py 61 62 63 64 65 p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as a collapsed admonition before the output. fib(4) = 3 Tracking code (top-o) docs/staging/code_blocks.py 68 69 70 71 72 p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as an open code block before the output. fib(5) = 5 Tracking code (bottom-c) The code as a collapsed admoniton after the output. fib(6) = 8 Code docs/staging/code_blocks.py 75 76 77 78 79 p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) Tracking code (bottom-o) The code as an open code block after the output. fib(7) = 13 docs/staging/code_blocks.py 82 83 84 85 86 p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) Adding code files Content Code In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. Code docs/staging/code_blocks.py from mkreports import Report def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" p = report . page ( \"usage/code_blocks.md\" , truncate = True ) with p . H1 ( \"Code blocks\" ) . ctx ( \"top-c\" ): p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) docs/staging/code_blocks.py 89 90 91 92 93 94 95 96 97 98 p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) And at the end will add another copy of the code-file, but automatically when ending the page context manager.","title":"Code Blocks"},{"location":"usage/code_blocks/#code-blocks","text":"Code docs/staging/code_blocks.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one.","title":"Code blocks"},{"location":"usage/code_blocks/#tracking-code-tabbed","text":"Content Code One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. fib(3) = 2 By default, the tabbed version will be used, but there are also the options top-c : Collapsed code block at the top top-o : Open code block at the top bottom-c : Collapsed code block at the bottom bottom-o : Open code block at the bottom The default style can be set when creating the page using the code_layout parameter, but can also be set one at a time later using the ctx method on a page. docs/staging/code_blocks.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" )","title":"Tracking code (tabbed)"},{"location":"usage/code_blocks/#tracking-code-top-c","text":"Code docs/staging/code_blocks.py 61 62 63 64 65 p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as a collapsed admonition before the output. fib(4) = 3","title":"Tracking code (top-c)"},{"location":"usage/code_blocks/#tracking-code-top-o","text":"docs/staging/code_blocks.py 68 69 70 71 72 p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as an open code block before the output. fib(5) = 5","title":"Tracking code (top-o)"},{"location":"usage/code_blocks/#tracking-code-bottom-c","text":"The code as a collapsed admoniton after the output. fib(6) = 8 Code docs/staging/code_blocks.py 75 76 77 78 79 p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" )","title":"Tracking code (bottom-c)"},{"location":"usage/code_blocks/#tracking-code-bottom-o","text":"The code as an open code block after the output. fib(7) = 13 docs/staging/code_blocks.py 82 83 84 85 86 p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" )","title":"Tracking code (bottom-o)"},{"location":"usage/code_blocks/#adding-code-files","text":"Content Code In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. Code docs/staging/code_blocks.py from mkreports import Report def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" p = report . page ( \"usage/code_blocks.md\" , truncate = True ) with p . H1 ( \"Code blocks\" ) . ctx ( \"top-c\" ): p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) docs/staging/code_blocks.py 89 90 91 92 93 94 95 96 97 98 p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) And at the end will add another copy of the code-file, but automatically when ending the page context manager.","title":"Adding code files"},{"location":"usage/images/","text":"Images Code docs/staging/images.py import matplotlib.pyplot as plt import numpy as np import seaborn as sns from mkreports import Report from PIL import Image from plotnine import aes , facet_wrap , geom_point , ggplot , stat_smooth from plotnine.data import mtcars def use_images ( report : Report ) -> None : \"\"\" Show all different ways on how we can include images. \"\"\" p = report . page ( \"usage/images.md\" , truncate = True ) # we don't need an indentation for everything if we don't want p . H1 ( \"Images\" ) p . CollapsedCodeFile ( __file__ ) p . H2 ( \"Supported formats\" ) p . Raw ( \"\"\" Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an `ImageFile` object. \"\"\" ) with p . H3 ( \"PIL\" ): p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) with p . H3 ( \"Matplotlib\" ): p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Image ( fig ) with p . H3 ( \"Plotnine\" ): p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) with p . H3 ( \"Seaborn\" ): p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) with p . H3 ( \"Altair\" ): import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) with p . H3 ( \"Plotly\" ): import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) p . H2 ( \"Different image sizes\" ) p . P ( \"\"\" In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change. \"\"\" ) with p . H3 ( \"Plotnine\" ): p . H4 ( \"Larger\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , ) Supported formats Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an ImageFile object. PIL Content Code PIL is the standard python image library. Image objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. docs/staging/images.py 33 34 35 36 37 38 39 40 41 42 43 44 45 p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) Matplotlib Content Code For many scientific graphing purposes, matplotlib is either the direct choice or the backend being used for plotting. docs/staging/images.py 49 50 51 52 53 54 55 56 57 58 p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Image ( fig ) Plotnine Content Code Any plots created by plotnine can be included directly. The code below is from the beginner example of the library. docs/staging/images.py 61 62 63 64 65 66 67 68 69 70 71 72 73 p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) Seaborn Content Code Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the figure attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. docs/staging/images.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) Altair Content Code docs/staging/images.py 106 107 108 109 110 111 112 113 114 115 116 117 118 import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) vegaEmbed(\"#altair_id-0\", \"../images_store/altair-a7a2eb773c7d9454c694b490a77e5a7e.csv\") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); Plotly Content Code docs/staging/images.py 121 122 123 124 import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) fetch('../images_store/plotly-2c4e085bcb294e03c4c01a147570a8c5.json') .then(function (response) { return response.json(); }) .then(function (data) { doPlotly(data); }) .catch(function (err) { console.log('error: ' + err); }); function doPlotly(plotlyJson) { Plotly.newPlot(\"plotly_id-0\", { \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }) } Different image sizes In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change. Plotnine Content Code Larger Smaller docs/staging/images.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 p . H4 ( \"Larger\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , )","title":"Images"},{"location":"usage/images/#images","text":"Code docs/staging/images.py import matplotlib.pyplot as plt import numpy as np import seaborn as sns from mkreports import Report from PIL import Image from plotnine import aes , facet_wrap , geom_point , ggplot , stat_smooth from plotnine.data import mtcars def use_images ( report : Report ) -> None : \"\"\" Show all different ways on how we can include images. \"\"\" p = report . page ( \"usage/images.md\" , truncate = True ) # we don't need an indentation for everything if we don't want p . H1 ( \"Images\" ) p . CollapsedCodeFile ( __file__ ) p . H2 ( \"Supported formats\" ) p . Raw ( \"\"\" Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an `ImageFile` object. \"\"\" ) with p . H3 ( \"PIL\" ): p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) with p . H3 ( \"Matplotlib\" ): p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Image ( fig ) with p . H3 ( \"Plotnine\" ): p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) with p . H3 ( \"Seaborn\" ): p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) with p . H3 ( \"Altair\" ): import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) with p . H3 ( \"Plotly\" ): import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) p . H2 ( \"Different image sizes\" ) p . P ( \"\"\" In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change. \"\"\" ) with p . H3 ( \"Plotnine\" ): p . H4 ( \"Larger\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , )","title":"Images"},{"location":"usage/images/#supported-formats","text":"Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an ImageFile object.","title":"Supported formats"},{"location":"usage/images/#pil","text":"Content Code PIL is the standard python image library. Image objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. docs/staging/images.py 33 34 35 36 37 38 39 40 41 42 43 44 45 p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img )","title":"PIL"},{"location":"usage/images/#matplotlib","text":"Content Code For many scientific graphing purposes, matplotlib is either the direct choice or the backend being used for plotting. docs/staging/images.py 49 50 51 52 53 54 55 56 57 58 p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Image ( fig )","title":"Matplotlib"},{"location":"usage/images/#plotnine","text":"Content Code Any plots created by plotnine can be included directly. The code below is from the beginner example of the library. docs/staging/images.py 61 62 63 64 65 66 67 68 69 70 71 72 73 p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), )","title":"Plotnine"},{"location":"usage/images/#seaborn","text":"Content Code Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the figure attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. docs/staging/images.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Image ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), )","title":"Seaborn"},{"location":"usage/images/#altair","text":"Content Code docs/staging/images.py 106 107 108 109 110 111 112 113 114 115 116 117 118 import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) vegaEmbed(\"#altair_id-0\", \"../images_store/altair-a7a2eb773c7d9454c694b490a77e5a7e.csv\") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn);","title":"Altair"},{"location":"usage/images/#plotly","text":"Content Code docs/staging/images.py 121 122 123 124 import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) fetch('../images_store/plotly-2c4e085bcb294e03c4c01a147570a8c5.json') .then(function (response) { return response.json(); }) .then(function (data) { doPlotly(data); }) .catch(function (err) { console.log('error: ' + err); }); function doPlotly(plotlyJson) { Plotly.newPlot(\"plotly_id-0\", { \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }) }","title":"Plotly"},{"location":"usage/images/#different-image-sizes","text":"In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change.","title":"Different image sizes"},{"location":"usage/images/#plotnine_1","text":"Content Code","title":"Plotnine"},{"location":"usage/images/#larger","text":"","title":"Larger"},{"location":"usage/images/#smaller","text":"docs/staging/images.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 p . H4 ( \"Larger\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Image ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , )","title":"Smaller"},{"location":"usage/ipython/","text":"Using IPython The extension The mkreports package also has an extension for IPython. Here, we are referring to the console-application IPython, not a Jupyter notebook (which were in the past also referred to as IPython notebooks). IPython here is just a replacement for the python console, similar to for example bpython . The reason we are using IPython is that it provides a plugin interface that allows us to extend its functionality. The key ability here is to have tables and images that are the results of commands in the IPython console to be automatically piped to a Console page in the mkdocs report. How to use it In order to use the IPython extension, we have to set the MKREPORTS_DIR environment variable to the folder in which the mkdocs report will be stored. Then we can start the IPython console and execute % load_ext mkreports Then in a separate shell, we go the directory that is referred to in MKREPORTS_DIR and run mkdocs serve and start a browser. Then we visit the Console subpage. Now, for every table or image that we create in the console, it will also be added to the Console page. Each entry will have a timestamp and end with a horizontal line. The code executed in the console since the last item was added will also be added as a tab. New entries will be added to the top of the page (at the bottom, there are problems with inadvertent scrolling). In addition, there are variables cons and md added to the console. The cons variable refers to the Console page and can be used just like any other report page in mkreports . The md object is the same as cons.md , just added for convenience, and can be used to create MdObj instances. An MdObj instance that is the result of a code-block will also automatically be added to the Console page. Layout By default, content and code will be presented as tabs. However, it also possible to choose other layouts. For the options, look to the section on code-blocks. In order to set a different layout, do cons.code_layout = 'top-o' in the IPython console. This, for example, will create visible code-blocks above the content. Archiving Once the Console page gets too long and becomes slower on reload, run % archive_console This will push the old Console page to a page with a time-stamp and create a new empty page to use for new additions.","title":"Ipython"},{"location":"usage/ipython/#using-ipython","text":"","title":"Using IPython"},{"location":"usage/ipython/#the-extension","text":"The mkreports package also has an extension for IPython. Here, we are referring to the console-application IPython, not a Jupyter notebook (which were in the past also referred to as IPython notebooks). IPython here is just a replacement for the python console, similar to for example bpython . The reason we are using IPython is that it provides a plugin interface that allows us to extend its functionality. The key ability here is to have tables and images that are the results of commands in the IPython console to be automatically piped to a Console page in the mkdocs report.","title":"The extension"},{"location":"usage/ipython/#how-to-use-it","text":"In order to use the IPython extension, we have to set the MKREPORTS_DIR environment variable to the folder in which the mkdocs report will be stored. Then we can start the IPython console and execute % load_ext mkreports Then in a separate shell, we go the directory that is referred to in MKREPORTS_DIR and run mkdocs serve and start a browser. Then we visit the Console subpage. Now, for every table or image that we create in the console, it will also be added to the Console page. Each entry will have a timestamp and end with a horizontal line. The code executed in the console since the last item was added will also be added as a tab. New entries will be added to the top of the page (at the bottom, there are problems with inadvertent scrolling). In addition, there are variables cons and md added to the console. The cons variable refers to the Console page and can be used just like any other report page in mkreports . The md object is the same as cons.md , just added for convenience, and can be used to create MdObj instances. An MdObj instance that is the result of a code-block will also automatically be added to the Console page.","title":"How to use it"},{"location":"usage/ipython/#layout","text":"By default, content and code will be presented as tabs. However, it also possible to choose other layouts. For the options, look to the section on code-blocks. In order to set a different layout, do cons.code_layout = 'top-o' in the IPython console. This, for example, will create visible code-blocks above the content.","title":"Layout"},{"location":"usage/ipython/#archiving","text":"Once the Console page gets too long and becomes slower on reload, run % archive_console This will push the old Console page to a page with a time-stamp and create a new empty page to use for new additions.","title":"Archiving"},{"location":"usage/markdown/","text":"Adding markdown elements to a page Opening pages The first step is to define a report directory and open a page in it. There is always at least the 'index.md' page included in any report, which is listed in the navigation under Home . from mkreports import Report report = Report () page = report . page ( 'index.md' ) Adding markdown There are overall 3 ways to use and add markdown elements to a page. Each of these provides a different level of convenient. As a summary for the user: If you want to add an element immediately to a page, use the markdown classes directly available as attributes in the page itself. These preset certain parameters and add the markdown object directly to the page after it is instantiated. If you need to build up more complicated markdown objects before adding it to a page (e.g. in the case of nested objects), use the Page.md attribute to get the markdown object that pre-populates certain parameters to sensible defaults In some special circumstances it may be necessary to get the raw markdown with full control. In this case the mkreports.md module can be used. Markdown attributes of a page All markdown objects are available under their name directory for a Page object (created from a Report ). For these, all parameters related to a page and project are captured in a single parameter page_info that expects and object of type PageInfo with names: store_path page_path report_path project_root javascript_path idstore When requesting a markdown object from a page, this is automatically added. The object is immediately added to the page. A list of all available object can be obtained with page . md . proxied_classes where page is a Page and the returned object is a dict of all registered markdown objects. The key of the dict is the name under which it is available as an attribute from the page. md attribute of a Page Each Page instance also has a md attribute. These expose the markdown object same as explained above, except that they will not be added to the page. This would have to be done manually. This is sometimes useful if more complex nested objects need to be created (e.g. for lists). md module Also available is the mkreports.md module. These are the base objects with no parameters pre-filled. This is only intended for experts that need special behavior that is not covered by the regular Page object.","title":"Markdown"},{"location":"usage/markdown/#adding-markdown-elements-to-a-page","text":"","title":"Adding markdown elements to a page"},{"location":"usage/markdown/#opening-pages","text":"The first step is to define a report directory and open a page in it. There is always at least the 'index.md' page included in any report, which is listed in the navigation under Home . from mkreports import Report report = Report () page = report . page ( 'index.md' )","title":"Opening pages"},{"location":"usage/markdown/#adding-markdown","text":"There are overall 3 ways to use and add markdown elements to a page. Each of these provides a different level of convenient. As a summary for the user: If you want to add an element immediately to a page, use the markdown classes directly available as attributes in the page itself. These preset certain parameters and add the markdown object directly to the page after it is instantiated. If you need to build up more complicated markdown objects before adding it to a page (e.g. in the case of nested objects), use the Page.md attribute to get the markdown object that pre-populates certain parameters to sensible defaults In some special circumstances it may be necessary to get the raw markdown with full control. In this case the mkreports.md module can be used.","title":"Adding markdown"},{"location":"usage/markdown/#markdown-attributes-of-a-page","text":"All markdown objects are available under their name directory for a Page object (created from a Report ). For these, all parameters related to a page and project are captured in a single parameter page_info that expects and object of type PageInfo with names: store_path page_path report_path project_root javascript_path idstore When requesting a markdown object from a page, this is automatically added. The object is immediately added to the page. A list of all available object can be obtained with page . md . proxied_classes where page is a Page and the returned object is a dict of all registered markdown objects. The key of the dict is the name under which it is available as an attribute from the page.","title":"Markdown attributes of a page"},{"location":"usage/markdown/#md-attribute-of-a-page","text":"Each Page instance also has a md attribute. These expose the markdown object same as explained above, except that they will not be added to the page. This would have to be done manually. This is sometimes useful if more complex nested objects need to be created (e.g. for lists).","title":"md attribute of a Page"},{"location":"usage/markdown/#md-module","text":"Also available is the mkreports.md module. These are the base objects with no parameters pre-filled. This is only intended for experts that need special behavior that is not covered by the regular Page object.","title":"md module"},{"location":"usage/plugins/","text":"Creating custom plugins All objects in this package that are used to add markdown (or html) to a page are all created using a plugin system. This enables other people to easily create their own MdObj objects and register them with mkreports so that they behave exactly as all other objects shipped with this package. Essentially, only 2 steps are needed: Create a new class that inherits from MdObj . There are many examples available in this package on how to do that. Especially interesting examples are the tables as well as images, but also HideNav , HideToc and NavTabs as they show how to use settings. Register the new class. This is easily done using the register_md decorator, which takes as its only argument the name under which the new class should be registered. After this is done, all classes are available as attributes on a Page as well as in Page.md with page_info parameters pre-set with the appropriate PageInfo object.","title":"Plugins"},{"location":"usage/plugins/#creating-custom-plugins","text":"All objects in this package that are used to add markdown (or html) to a page are all created using a plugin system. This enables other people to easily create their own MdObj objects and register them with mkreports so that they behave exactly as all other objects shipped with this package. Essentially, only 2 steps are needed: Create a new class that inherits from MdObj . There are many examples available in this package on how to do that. Especially interesting examples are the tables as well as images, but also HideNav , HideToc and NavTabs as they show how to use settings. Register the new class. This is easily done using the register_md decorator, which takes as its only argument the name under which the new class should be registered. After this is done, all classes are available as attributes on a Page as well as in Page.md with page_info parameters pre-set with the appropriate PageInfo object.","title":"Creating custom plugins"},{"location":"usage/sidebar/","text":"Code docs/staging/sidebar.py from mkreports import Report def use_sidebar ( report : Report ) -> None : p = report . page ( \"usage/sidebar\" , truncate = True ) p . CollapsedCodeFile ( __file__ ) p . H1 ( \"Sidebars\" ) p . P ( \"\"\" We can hide the table of contents sidebar as well as the navigation bar. On this page, we only hide the ToC. When hiding the navigation bar, you should think about setting navigation tabs as well (otherwise there is no direct navigation option. Below a code block showing how to hide the ToC, Nav and set the navigations tabs. \"\"\" ) p . HideToc () p . Code ( \"\"\" p.HideToc() p.HideNav() p.NavTabs() \"\"\" ) Sidebars We can hide the table of contents sidebar as well as the navigation bar. On this page, we only hide the ToC. When hiding the navigation bar, you should think about setting navigation tabs as well (otherwise there is no direct navigation option. Below a code block showing how to hide the ToC, Nav and set the navigations tabs. p . HideToc () p . HideNav () p . NavTabs ()","title":"Sidebar"},{"location":"usage/sidebar/#sidebars","text":"We can hide the table of contents sidebar as well as the navigation bar. On this page, we only hide the ToC. When hiding the navigation bar, you should think about setting navigation tabs as well (otherwise there is no direct navigation option. Below a code block showing how to hide the ToC, Nav and set the navigations tabs. p . HideToc () p . HideNav () p . NavTabs ()","title":"Sidebars"},{"location":"usage/tables/","text":"Different ways of handling tables Code docs/staging/tables.py import pandas as pd from mkreports import Report , md from plotnine.data import mtcars def use_tables ( report : Report ) -> None : \"\"\" Show all the different ways on how we can work with tables. \"\"\" ex_table = pd . DataFrame ( [ { \"name\" : \"Alfred\" , \"age\" : 30 , \"hair\" : \"red\" , \"married\" : True }, { \"name\" : \"Beate\" , \"age\" : 50 , \"hair\" : \"brown\" , \"married\" : False }, { \"name\" : \"Caro\" , \"age\" : 7 , \"hair\" : \"green\" , \"married\" : False , }, ] ) ex_table [ \"hair\" ] = pd . Categorical ( ex_table . hair ) p = report . page ( \"usage/tables.md\" , truncate = True ) p . H1 ( \"Different ways of handling tables\" ) p . CollapsedCodeFile ( __file__ ) p . Raw ( \"\"\" Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. \"\"\" ) with p . H2 ( \"Markdown tables\" ): p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) with p . H2 ( \"DataTable javascript library\" ): p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) with p . H2 ( \"Tabulator javascript library\" ): p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Notes\" ): p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" ) Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. Markdown tables Content Code Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. name mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 docs/staging/tables.py 39 40 41 42 43 44 45 46 p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) DataTable javascript library Content Code Here the same table, but displayed using the DataTables plugin. With this, we get automatic paging, searching as well as sorting by columns. Header filters Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. A numeric column gets a range selector A categorical or boolean column a dropdown selection Any other column a text-field. docs/staging/tables.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) $(document).ready( function () { var myTable = $('#datatable_id-0').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Mpg\"}, {\"title\": \"Cyl\"}, {\"title\": \"Disp\"}, {\"title\": \"Hp\"}, {\"title\": \"Drat\"}, {\"title\": \"Wt\"}, {\"title\": \"Qsec\"}, {\"title\": \"Vs\"}, {\"title\": \"Am\"}, {\"title\": \"Gear\"}, {\"title\": \"Carb\"}], \"ajax\": \"../tables_store/datatable-ca9b6f052f673e1d46f468ebb1ccc5d1.json\"}); } ); $(document).ready( function () { var myTable = $('#datatable_id-1').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Age\"}, {\"title\": \"Hair\"}, {\"title\": \"Married\"}], \"ajax\": \"../tables_store/datatable-580c4149445c9b58b5740c532e20a5a0.json\"}); yadcf.init(myTable, [{\"column_number\": 0, \"filter_type\": \"text\"}, {\"column_number\": 1, \"filter_type\": \"range_number\"}, {\"column_number\": 2, \"filter_type\": \"select\"}, {\"column_number\": 3, \"filter_type\": \"select\"}]); } ); Tabulator javascript library Content Code This time, we use the Tabulator library. A library with a lot of interesting functionality. Header filters We also can enable header filtering. For the datatypes numeric boolean categorical str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are Input filter for the names Range filter with min and max for age Select dropdown for hair color and checkbox for marital status docs/staging/tables.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"title\": \"name\"}, {\"field\": \"mpg\", \"title\": \"mpg\"}, {\"field\": \"cyl\", \"title\": \"cyl\"}, {\"field\": \"disp\", \"title\": \"disp\"}, {\"field\": \"hp\", \"title\": \"hp\"}, {\"field\": \"drat\", \"title\": \"drat\"}, {\"field\": \"wt\", \"title\": \"wt\"}, {\"field\": \"qsec\", \"title\": \"qsec\"}, {\"field\": \"vs\", \"title\": \"vs\"}, {\"field\": \"am\", \"title\": \"am\"}, {\"field\": \"gear\", \"title\": \"gear\"}, {\"field\": \"carb\", \"title\": \"carb\"}], \"ajaxURL\": \"../tables_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); var table = new Tabulator('#tabulator_id-1', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"age\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Age\"}, {\"field\": \"hair\", \"headerFilter\": \"select\", \"headerFilterParams\": {\"values\": [\"\", \"brown\", \"green\", \"red\"]}, \"title\": \"Hair\"}, {\"field\": \"married\", \"headerFilter\": \"tickCross\", \"formatter\": \"tickCross\", \"headerFilterParams\": {\"tristate\": true}, \"title\": \"Married\"}], \"ajaxURL\": \"../tables_store/tabulator-75b468c8a8bcf5fff9d211e88d0e6972.json\"}); Notes Content Code Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the str funtion is called. If this is not ok, please transform the table columns accordingly. docs/staging/tables.py 111 112 113 114 115 116 117 118 119 p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" )","title":"Tables"},{"location":"usage/tables/#different-ways-of-handling-tables","text":"Code docs/staging/tables.py import pandas as pd from mkreports import Report , md from plotnine.data import mtcars def use_tables ( report : Report ) -> None : \"\"\" Show all the different ways on how we can work with tables. \"\"\" ex_table = pd . DataFrame ( [ { \"name\" : \"Alfred\" , \"age\" : 30 , \"hair\" : \"red\" , \"married\" : True }, { \"name\" : \"Beate\" , \"age\" : 50 , \"hair\" : \"brown\" , \"married\" : False }, { \"name\" : \"Caro\" , \"age\" : 7 , \"hair\" : \"green\" , \"married\" : False , }, ] ) ex_table [ \"hair\" ] = pd . Categorical ( ex_table . hair ) p = report . page ( \"usage/tables.md\" , truncate = True ) p . H1 ( \"Different ways of handling tables\" ) p . CollapsedCodeFile ( __file__ ) p . Raw ( \"\"\" Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. \"\"\" ) with p . H2 ( \"Markdown tables\" ): p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) with p . H2 ( \"DataTable javascript library\" ): p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) with p . H2 ( \"Tabulator javascript library\" ): p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Notes\" ): p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" ) Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed.","title":"Different ways of handling tables"},{"location":"usage/tables/#markdown-tables","text":"Content Code Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. name mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 docs/staging/tables.py 39 40 41 42 43 44 45 46 p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False ))","title":"Markdown tables"},{"location":"usage/tables/#datatable-javascript-library","text":"Content Code Here the same table, but displayed using the DataTables plugin. With this, we get automatic paging, searching as well as sorting by columns.","title":"DataTable javascript library"},{"location":"usage/tables/#header-filters","text":"Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. A numeric column gets a range selector A categorical or boolean column a dropdown selection Any other column a text-field. docs/staging/tables.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) $(document).ready( function () { var myTable = $('#datatable_id-0').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Mpg\"}, {\"title\": \"Cyl\"}, {\"title\": \"Disp\"}, {\"title\": \"Hp\"}, {\"title\": \"Drat\"}, {\"title\": \"Wt\"}, {\"title\": \"Qsec\"}, {\"title\": \"Vs\"}, {\"title\": \"Am\"}, {\"title\": \"Gear\"}, {\"title\": \"Carb\"}], \"ajax\": \"../tables_store/datatable-ca9b6f052f673e1d46f468ebb1ccc5d1.json\"}); } ); $(document).ready( function () { var myTable = $('#datatable_id-1').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Age\"}, {\"title\": \"Hair\"}, {\"title\": \"Married\"}], \"ajax\": \"../tables_store/datatable-580c4149445c9b58b5740c532e20a5a0.json\"}); yadcf.init(myTable, [{\"column_number\": 0, \"filter_type\": \"text\"}, {\"column_number\": 1, \"filter_type\": \"range_number\"}, {\"column_number\": 2, \"filter_type\": \"select\"}, {\"column_number\": 3, \"filter_type\": \"select\"}]); } );","title":"Header filters"},{"location":"usage/tables/#tabulator-javascript-library","text":"Content Code This time, we use the Tabulator library. A library with a lot of interesting functionality.","title":"Tabulator javascript library"},{"location":"usage/tables/#header-filters_1","text":"We also can enable header filtering. For the datatypes numeric boolean categorical str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are Input filter for the names Range filter with min and max for age Select dropdown for hair color and checkbox for marital status docs/staging/tables.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . notrack : p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"title\": \"name\"}, {\"field\": \"mpg\", \"title\": \"mpg\"}, {\"field\": \"cyl\", \"title\": \"cyl\"}, {\"field\": \"disp\", \"title\": \"disp\"}, {\"field\": \"hp\", \"title\": \"hp\"}, {\"field\": \"drat\", \"title\": \"drat\"}, {\"field\": \"wt\", \"title\": \"wt\"}, {\"field\": \"qsec\", \"title\": \"qsec\"}, {\"field\": \"vs\", \"title\": \"vs\"}, {\"field\": \"am\", \"title\": \"am\"}, {\"field\": \"gear\", \"title\": \"gear\"}, {\"field\": \"carb\", \"title\": \"carb\"}], \"ajaxURL\": \"../tables_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); var table = new Tabulator('#tabulator_id-1', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"age\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Age\"}, {\"field\": \"hair\", \"headerFilter\": \"select\", \"headerFilterParams\": {\"values\": [\"\", \"brown\", \"green\", \"red\"]}, \"title\": \"Hair\"}, {\"field\": \"married\", \"headerFilter\": \"tickCross\", \"formatter\": \"tickCross\", \"headerFilterParams\": {\"tristate\": true}, \"title\": \"Married\"}], \"ajaxURL\": \"../tables_store/tabulator-75b468c8a8bcf5fff9d211e88d0e6972.json\"});","title":"Header filters"},{"location":"usage/tables/#notes","text":"Content Code Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the str funtion is called. If this is not ok, please transform the table columns accordingly. docs/staging/tables.py 111 112 113 114 115 116 117 118 119 p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" )","title":"Notes"}]}