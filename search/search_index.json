{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Purpose of the project Introduction For data analysts, the output of a project is typically a report of the derived results of the dataset, be it an algorithm, the summary of a regression model and the significance of variables or some other sort of requested insight. In order to simplify the writing of such reports, various tools have been invented, the most well known ones being RMarkdown in R and Jupyter that is mostly used with Python (but supports many other languages as well). These tools are incarnations of a Literate Programming , that had its beginnings with tools such as noweb and aims to mix regular text with code in an article, but of course that have been developed much further since then to extend to interactively editing and running code such as in Jupyter, processing entire books (see e.g. bookdown or also inverting the text and code-blocks such that the regular text becomes comments inside a script in e.g. R or Python (see jupytext ). Jupyter and related tools As this package is only for Python, I will focus in the following on aspects of these tools for this language, but some comments are certainly also valid for other frameworks. Jupyter is for sure the most used framework for this purpose with a very large set of tools and users. Since its invention, it has certainly changed how datascience is being done in many organizations. Some of its most noteworthy advantages are: - Deployment through the browser without the need of direct access to hardware. Due to this it is also simpler to have users work with on-demand resources - A good console with outputs of tables and figures that make rapid development easy - Tools such as turning jupyter notebooks into websites - Jupyterlab, which is (almost) a full Python IDE Next to these positive sides are however also a few shortcomings. Shortcomings of Jupyter One of the side-effects of structure of Jupyter-notebooks is their linear form where code and output blocks are mixed, which can cause notebooks to become very large and particular places can be hard to find. Code sharing between notebooks is also not easily possible, requiring to write libraries outside the notebook to fulfill this purpose, mixing very different styles of coding. Also related to their design of one notebook, one html page, parametrization of notebooks can be cumbersome and is certainly not as simple and straightforward as a function. This package This package was developed to give an alternative to Jupyter providing more sophisticated ways to create reports while retaining (some) of the interactivity of the browser. All this will be done in pure python without any specially formatted file or overloading of the meaning of any comments. It will further retain the ability to include live code-blocks from the scripts in the output, but less intrusively than for Jupyter notebooks. In particular, it is intended to work by providing functions to easily write out markdown pages that are part of an mkdocs site. For this convenience functions for Figures and Tables as well as other objects are available. For viewing these results, mkdocs is used that contains a development server that automatically watches input files and updates the browser on any change. This update process is typically very fast. Last, a plugin for the ipython console is provided that writes any appropriate output in the console to a special markdown page that can then also be viewed using mkdocs. This way, it is easy to visualize figues and tables from the ipython console, where tables in the browser are sortable or can even be filtered, thus providing better functionality than default Jupyter tables in an output cell.","title":"Home"},{"location":"#purpose-of-the-project","text":"","title":"Purpose of the project"},{"location":"#introduction","text":"For data analysts, the output of a project is typically a report of the derived results of the dataset, be it an algorithm, the summary of a regression model and the significance of variables or some other sort of requested insight. In order to simplify the writing of such reports, various tools have been invented, the most well known ones being RMarkdown in R and Jupyter that is mostly used with Python (but supports many other languages as well). These tools are incarnations of a Literate Programming , that had its beginnings with tools such as noweb and aims to mix regular text with code in an article, but of course that have been developed much further since then to extend to interactively editing and running code such as in Jupyter, processing entire books (see e.g. bookdown or also inverting the text and code-blocks such that the regular text becomes comments inside a script in e.g. R or Python (see jupytext ).","title":"Introduction"},{"location":"#jupyter-and-related-tools","text":"As this package is only for Python, I will focus in the following on aspects of these tools for this language, but some comments are certainly also valid for other frameworks. Jupyter is for sure the most used framework for this purpose with a very large set of tools and users. Since its invention, it has certainly changed how datascience is being done in many organizations. Some of its most noteworthy advantages are: - Deployment through the browser without the need of direct access to hardware. Due to this it is also simpler to have users work with on-demand resources - A good console with outputs of tables and figures that make rapid development easy - Tools such as turning jupyter notebooks into websites - Jupyterlab, which is (almost) a full Python IDE Next to these positive sides are however also a few shortcomings.","title":"Jupyter and related tools"},{"location":"#shortcomings-of-jupyter","text":"One of the side-effects of structure of Jupyter-notebooks is their linear form where code and output blocks are mixed, which can cause notebooks to become very large and particular places can be hard to find. Code sharing between notebooks is also not easily possible, requiring to write libraries outside the notebook to fulfill this purpose, mixing very different styles of coding. Also related to their design of one notebook, one html page, parametrization of notebooks can be cumbersome and is certainly not as simple and straightforward as a function.","title":"Shortcomings of Jupyter"},{"location":"#this-package","text":"This package was developed to give an alternative to Jupyter providing more sophisticated ways to create reports while retaining (some) of the interactivity of the browser. All this will be done in pure python without any specially formatted file or overloading of the meaning of any comments. It will further retain the ability to include live code-blocks from the scripts in the output, but less intrusively than for Jupyter notebooks. In particular, it is intended to work by providing functions to easily write out markdown pages that are part of an mkdocs site. For this convenience functions for Figures and Tables as well as other objects are available. For viewing these results, mkdocs is used that contains a development server that automatically watches input files and updates the browser on any change. This update process is typically very fast. Last, a plugin for the ipython console is provided that writes any appropriate output in the console to a special markdown page that can then also be viewed using mkdocs. This way, it is easy to visualize figues and tables from the ipython console, where tables in the browser are sortable or can even be filtered, thus providing better functionality than default Jupyter tables in an output cell.","title":"This package"},{"location":"quickstart/","text":"Quickstart First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" , truncate = True ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Plotnine ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine. Data as a table Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); Some simple plots Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Plotnine ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. docs/staging/quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" , truncate = True ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Plotnine ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report ) We are quickly analyzing the mtcars dataset that is included with plotnine.","title":"Quickstart"},{"location":"quickstart/#data-as-a-table","text":"Content Code docs/staging/quickstart.py 30 p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"mpg\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Mpg\"}, {\"field\": \"cyl\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Cyl\"}, {\"field\": \"disp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Disp\"}, {\"field\": \"hp\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Hp\"}, {\"field\": \"drat\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Drat\"}, {\"field\": \"wt\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Wt\"}, {\"field\": \"qsec\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Qsec\"}, {\"field\": \"vs\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Vs\"}, {\"field\": \"am\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Am\"}, {\"field\": \"gear\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Gear\"}, {\"field\": \"carb\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Carb\"}], \"ajaxURL\": \"../quickstart_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"});","title":"Data as a table"},{"location":"quickstart/#some-simple-plots","text":"Content Code docs/staging/quickstart.py 34 35 36 37 38 39 40 41 p . Plotnine ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) )","title":"Some simple plots"},{"location":"Reference/cli/","text":"dir () Print the directory mkreports uses by default to the screen. Source code in mkreports/cli.py 14 15 16 17 @app . command () def dir (): \"\"\"Print the directory mkreports uses by default to the screen.\"\"\" typer . echo ( f \" { get_mkreports_dir () } \" ) new ( mkreports_dir = typer . Argument ( None , help = 'mkreports directory to use to serve out of. If not given, then default directory as shown by `dir` subcommand used.' ), name = typer . Option ( 'Mkreports report' , help = 'Name of the report' )) Create a new mkreports report. Source code in mkreports/cli.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @app . command () def new ( mkreports_dir : Optional [ Path ] = typer . Argument ( None , help = \"mkreports directory to use to serve out of. If not given, then default directory as shown by `dir` subcommand used.\" , ), name : str = typer . Option ( \"Mkreports report\" , help = \"Name of the report\" ), ): \"\"\"Create a new mkreports report.\"\"\" if mkreports_dir is None : mkreports_dir = get_mkreports_dir () try : Report . create ( mkreports_dir , report_name = name ) typer . echo ( f \"Create report in { mkreports_dir } \" ) except : if mkreports_dir . is_dir (): typer . echo ( f \"Directory already exists and could not create report in { mkreports_dir } \" ) else : typer . echo ( f \"Could not create report in { mkreports_dir } \" ) serve ( mkreports_dir = typer . Argument ( None , help = 'mkreports directory to use to serve out of. If not given, then default directory as shown by `dir` subcommand used.' ), mkdocs_args = typer . Argument ( None , help = 'All values passed directly to `mkdocs serve` function. Use `--` to separate options for mkdocs from options for the core command.' )) Serve an mkdocs site. This is a convenience wrapper for mkdocs serve that changes to the correct directory and invokes mkdocs serve , restarting when error occur. Source code in mkreports/cli.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @app . command () def serve ( mkreports_dir : Optional [ Path ] = typer . Argument ( None , help = \"mkreports directory to use to serve out of. If not given, then default directory as shown by `dir` subcommand used.\" , ), mkdocs_args : List [ str ] = typer . Argument ( None , help = \"All values passed directly to `mkdocs serve` function. Use `--` to separate options for mkdocs from options for the core command.\" , ), ): \"\"\" Serve an mkdocs site. This is a convenience wrapper for `mkdocs serve` that changes to the correct directory and invokes `mkdocs serve`, restarting when error occur. \"\"\" if mkreports_dir is None : mkreports_dir = get_mkreports_dir () mkdocs_cmd = f \"cd { mkreports_dir } && mkdocs serve { ' ' . join ( mkdocs_args ) } \" # we first do an initial start; this has to run without error # for a few seconds before the automatic restart is initiated if not mkreports_dir . is_dir (): typer . echo ( f \"Directory { mkreports_dir } does not exist or is not a directory.\" , err = True ) raise typer . Exit ( 1 ) # we do the initial run; this needs to last for at least 5 seconds; # if an error occurs in this time, we do not restart time_first_start = datetime . now () try : while True : try : typer . echo ( f \"Run bash command: { mkdocs_cmd } \" ) cmd = sh . bash ( \"-c\" , mkdocs_cmd , _out = _process_out , _err = _process_err , _bg = True ) # type: ignore cmd . wait () except sh . ErrorReturnCode : time_error = datetime . now () elapsed_time = time_error - time_first_start if elapsed_time . total_seconds () <= 5 : typer . echo ( \"Error occured before 5 seconds. Exiting.\" ) raise typer . Exit ( 2 ) else : typer . echo ( \"Restarting!\" ) except KeyboardInterrupt : try : if cmd . is_alive (): # type: ignore cmd . terminate () # type: ignore typer . echo ( \" \\n Terminated mkdocs serve\" ) typer . Abort () except UnboundLocalError : pass","title":"cli"},{"location":"Reference/cli/#mkreports.cli.dir","text":"Print the directory mkreports uses by default to the screen. Source code in mkreports/cli.py 14 15 16 17 @app . command () def dir (): \"\"\"Print the directory mkreports uses by default to the screen.\"\"\" typer . echo ( f \" { get_mkreports_dir () } \" )","title":"dir()"},{"location":"Reference/cli/#mkreports.cli.new","text":"Create a new mkreports report. Source code in mkreports/cli.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 @app . command () def new ( mkreports_dir : Optional [ Path ] = typer . Argument ( None , help = \"mkreports directory to use to serve out of. If not given, then default directory as shown by `dir` subcommand used.\" , ), name : str = typer . Option ( \"Mkreports report\" , help = \"Name of the report\" ), ): \"\"\"Create a new mkreports report.\"\"\" if mkreports_dir is None : mkreports_dir = get_mkreports_dir () try : Report . create ( mkreports_dir , report_name = name ) typer . echo ( f \"Create report in { mkreports_dir } \" ) except : if mkreports_dir . is_dir (): typer . echo ( f \"Directory already exists and could not create report in { mkreports_dir } \" ) else : typer . echo ( f \"Could not create report in { mkreports_dir } \" )","title":"new()"},{"location":"Reference/cli/#mkreports.cli.serve","text":"Serve an mkdocs site. This is a convenience wrapper for mkdocs serve that changes to the correct directory and invokes mkdocs serve , restarting when error occur. Source code in mkreports/cli.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @app . command () def serve ( mkreports_dir : Optional [ Path ] = typer . Argument ( None , help = \"mkreports directory to use to serve out of. If not given, then default directory as shown by `dir` subcommand used.\" , ), mkdocs_args : List [ str ] = typer . Argument ( None , help = \"All values passed directly to `mkdocs serve` function. Use `--` to separate options for mkdocs from options for the core command.\" , ), ): \"\"\" Serve an mkdocs site. This is a convenience wrapper for `mkdocs serve` that changes to the correct directory and invokes `mkdocs serve`, restarting when error occur. \"\"\" if mkreports_dir is None : mkreports_dir = get_mkreports_dir () mkdocs_cmd = f \"cd { mkreports_dir } && mkdocs serve { ' ' . join ( mkdocs_args ) } \" # we first do an initial start; this has to run without error # for a few seconds before the automatic restart is initiated if not mkreports_dir . is_dir (): typer . echo ( f \"Directory { mkreports_dir } does not exist or is not a directory.\" , err = True ) raise typer . Exit ( 1 ) # we do the initial run; this needs to last for at least 5 seconds; # if an error occurs in this time, we do not restart time_first_start = datetime . now () try : while True : try : typer . echo ( f \"Run bash command: { mkdocs_cmd } \" ) cmd = sh . bash ( \"-c\" , mkdocs_cmd , _out = _process_out , _err = _process_err , _bg = True ) # type: ignore cmd . wait () except sh . ErrorReturnCode : time_error = datetime . now () elapsed_time = time_error - time_first_start if elapsed_time . total_seconds () <= 5 : typer . echo ( \"Error occured before 5 seconds. Exiting.\" ) raise typer . Exit ( 2 ) else : typer . echo ( \"Restarting!\" ) except KeyboardInterrupt : try : if cmd . is_alive (): # type: ignore cmd . terminate () # type: ignore typer . echo ( \" \\n Terminated mkdocs serve\" ) typer . Abort () except UnboundLocalError : pass","title":"serve()"},{"location":"Reference/code_context/","text":"Module providing a class and context manager for tracking code. The way of tracking code and displaying it is handled through a context manager, which is the return value obtained when adding an object to a page. The context manager gives different options on how to display the code and the results such as: A code block at the top followed by the output similar to standard jupyter notebooks. A Tab-format where output and code are on separate tabs A collapsed code block followed by the output or the output followed by a collapsed code block. CodeContext Context manager for the code tracking and content accumulation. Source code in mkreports/code_context.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class CodeContext : \"\"\" Context manager for the code tracking and content accumulation. \"\"\" tracker : BaseTracker def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): \"\"\" Initialize the context manager. This should usually not be needed by end users. Args: layout (Layouts): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. relative_to (Optional[Path]): Path relative to where the code file will be named. name_only (bool): For the code file, use name instead of path? add_bottom (bool): Should content be added to bottom or top of page? stack_level (int): Levels lower in the stack where the code is to be tracked. \"\"\" self . layout : Layouts = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only self . _active = False def __enter__ ( self ) -> \"CodeContext\" : if self . do_tracking : self . tracker . start ( inspect . stack ()[ self . stack_level ]) self . _active = True return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : del exc_type , exc_val , traceback self . _active = False if self . do_tracking : self . tracker . stop ( inspect . stack ()[ self . stack_level ]) @property def active ( self ): \"\"\"Indicates if the context-manager is active.\"\"\" return self . _active def add ( self , md_obj : MdObj ) -> None : \"\"\" Add a new content object. Args: md_obj (MdObj): The content to be added. \"\"\" if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj ) def md_obj ( self , page_info : PageInfo ) -> MdObj : \"\"\" Return the markdown object that represents output and code. Args: page_info (PageInfo): PageInfo object about the page where the content is to be added. Returns: MdObj: Markdown object representing the formatted output in the requested layout \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : code_final = None else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] return do_layout ( code = code_final , content = content , page_info = page_info , layout = self . layout ) __init__ ( layout , relative_to = None , name_only = False , add_bottom = True , stack_level = 2 ) Initialize the context manager. This should usually not be needed by end users. Parameters: Name Type Description Default layout Layouts The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. required relative_to Optional [ Path ] Path relative to where the code file will be named. None name_only bool For the code file, use name instead of path? False add_bottom bool Should content be added to bottom or top of page? True stack_level int Levels lower in the stack where the code is to be tracked. 2 Source code in mkreports/code_context.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): \"\"\" Initialize the context manager. This should usually not be needed by end users. Args: layout (Layouts): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. relative_to (Optional[Path]): Path relative to where the code file will be named. name_only (bool): For the code file, use name instead of path? add_bottom (bool): Should content be added to bottom or top of page? stack_level (int): Levels lower in the stack where the code is to be tracked. \"\"\" self . layout : Layouts = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only self . _active = False active () Indicates if the context-manager is active. Source code in mkreports/code_context.py 132 133 134 135 @property def active ( self ): \"\"\"Indicates if the context-manager is active.\"\"\" return self . _active add ( md_obj ) Add a new content object. Parameters: Name Type Description Default md_obj MdObj The content to be added. required Source code in mkreports/code_context.py 137 138 139 140 141 142 143 144 145 146 147 def add ( self , md_obj : MdObj ) -> None : \"\"\" Add a new content object. Args: md_obj (MdObj): The content to be added. \"\"\" if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj ) md_obj ( page_info ) Return the markdown object that represents output and code. Parameters: Name Type Description Default page_info PageInfo PageInfo object about the page where the content is to be added. required Returns: Name Type Description MdObj MdObj Markdown object representing the formatted output in the requested layout Source code in mkreports/code_context.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def md_obj ( self , page_info : PageInfo ) -> MdObj : \"\"\" Return the markdown object that represents output and code. Args: page_info (PageInfo): PageInfo object about the page where the content is to be added. Returns: MdObj: Markdown object representing the formatted output in the requested layout \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : code_final = None else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] return do_layout ( code = code_final , content = content , page_info = page_info , layout = self . layout ) do_layout ( code , content , layout , page_info ) Do the layouting for a content and code block. Parameters: Name Type Description Default code Optional [ MdObj ] The MdObj for the code. If layout is 'nocode', can be None. required content MdObj The content to add. Can't be missing. required layout Layouts Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. required page_info PageInfo PageInfo object corresponding to the page to which it should be added. required Returns: Type Description MdObj A MdObj with the requested layout. Source code in mkreports/code_context.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def do_layout ( code : Optional [ MdObj ], content : MdObj , layout : Layouts , page_info : PageInfo ) -> MdObj : \"\"\" Do the layouting for a content and code block. Args: code (Optional[MdObj]): The MdObj for the code. If layout is 'nocode', can be None. content (MdObj): The content to add. Can't be missing. layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. page_info (PageInfo): PageInfo object corresponding to the page to which it should be added. Returns: A MdObj with the requested layout. \"\"\" if layout == \"nocode\" : return content else : assert code is not None if layout == \"top-c\" : return ( Admonition ( code , page_info = page_info , collapse = True , title = \"Code\" , kind = \"code\" , ) + content + HLine () ) elif layout == \"top-o\" : return code + content + HLine () elif layout == \"bottom-c\" : return ( content + Admonition ( code , page_info = page_info , collapse = True , title = \"Code\" , kind = \"code\" , ) + HLine () ) elif layout == \"bottom-o\" : return content + code + HLine () elif layout == \"tabbed\" : return Tab ( content , title = \"Content\" ) + Tab ( code , title = \"Code\" ) + HLine () else : raise Exception ( \"Unknown layout type.\" )","title":"code_context"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext","text":"Context manager for the code tracking and content accumulation. Source code in mkreports/code_context.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 class CodeContext : \"\"\" Context manager for the code tracking and content accumulation. \"\"\" tracker : BaseTracker def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): \"\"\" Initialize the context manager. This should usually not be needed by end users. Args: layout (Layouts): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. relative_to (Optional[Path]): Path relative to where the code file will be named. name_only (bool): For the code file, use name instead of path? add_bottom (bool): Should content be added to bottom or top of page? stack_level (int): Levels lower in the stack where the code is to be tracked. \"\"\" self . layout : Layouts = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only self . _active = False def __enter__ ( self ) -> \"CodeContext\" : if self . do_tracking : self . tracker . start ( inspect . stack ()[ self . stack_level ]) self . _active = True return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : del exc_type , exc_val , traceback self . _active = False if self . do_tracking : self . tracker . stop ( inspect . stack ()[ self . stack_level ]) @property def active ( self ): \"\"\"Indicates if the context-manager is active.\"\"\" return self . _active def add ( self , md_obj : MdObj ) -> None : \"\"\" Add a new content object. Args: md_obj (MdObj): The content to be added. \"\"\" if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj ) def md_obj ( self , page_info : PageInfo ) -> MdObj : \"\"\" Return the markdown object that represents output and code. Args: page_info (PageInfo): PageInfo object about the page where the content is to be added. Returns: MdObj: Markdown object representing the formatted output in the requested layout \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : code_final = None else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] return do_layout ( code = code_final , content = content , page_info = page_info , layout = self . layout )","title":"CodeContext"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext.__init__","text":"Initialize the context manager. This should usually not be needed by end users. Parameters: Name Type Description Default layout Layouts The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. required relative_to Optional [ Path ] Path relative to where the code file will be named. None name_only bool For the code file, use name instead of path? False add_bottom bool Should content be added to bottom or top of page? True stack_level int Levels lower in the stack where the code is to be tracked. 2 Source code in mkreports/code_context.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 def __init__ ( self , layout : Layouts , relative_to : Optional [ Path ] = None , name_only : bool = False , add_bottom : bool = True , stack_level : int = 2 , ): \"\"\" Initialize the context manager. This should usually not be needed by end users. Args: layout (Layouts): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. relative_to (Optional[Path]): Path relative to where the code file will be named. name_only (bool): For the code file, use name instead of path? add_bottom (bool): Should content be added to bottom or top of page? stack_level (int): Levels lower in the stack where the code is to be tracked. \"\"\" self . layout : Layouts = layout self . do_tracking = layout != \"nocode\" self . tracker = SimpleTracker () self . stack_level = stack_level self . obj_list = [] self . relative_to = relative_to self . add_bottom = add_bottom self . name_only = name_only self . _active = False","title":"__init__()"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext.active","text":"Indicates if the context-manager is active. Source code in mkreports/code_context.py 132 133 134 135 @property def active ( self ): \"\"\"Indicates if the context-manager is active.\"\"\" return self . _active","title":"active()"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext.add","text":"Add a new content object. Parameters: Name Type Description Default md_obj MdObj The content to be added. required Source code in mkreports/code_context.py 137 138 139 140 141 142 143 144 145 146 147 def add ( self , md_obj : MdObj ) -> None : \"\"\" Add a new content object. Args: md_obj (MdObj): The content to be added. \"\"\" if self . add_bottom : self . obj_list . append ( md_obj ) else : self . obj_list . insert ( 0 , md_obj )","title":"add()"},{"location":"Reference/code_context/#mkreports.code_context.CodeContext.md_obj","text":"Return the markdown object that represents output and code. Parameters: Name Type Description Default page_info PageInfo PageInfo object about the page where the content is to be added. required Returns: Name Type Description MdObj MdObj Markdown object representing the formatted output in the requested layout Source code in mkreports/code_context.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def md_obj ( self , page_info : PageInfo ) -> MdObj : \"\"\" Return the markdown object that represents output and code. Args: page_info (PageInfo): PageInfo object about the page where the content is to be added. Returns: MdObj: Markdown object representing the formatted output in the requested layout \"\"\" content = MdSeq ( self . obj_list ) if self . layout == \"nocode\" : code_final = None else : code_blocks = self . tracker . code () # turn code blocks into md code_md_list = [ block . md_code ( relative_to = self . relative_to , name_only = self . name_only ) for block in code_blocks ] if len ( code_md_list ) > 1 : # turn it into tabs code_final = Tab ( code_md_list [ 0 ], title = \"<main>\" ) for block , md_code in zip ( code_blocks , code_md_list ): code_final += Tab ( md_code , title = block . co_name ) else : # just keep the code block as is code_final = code_md_list [ 0 ] return do_layout ( code = code_final , content = content , page_info = page_info , layout = self . layout )","title":"md_obj()"},{"location":"Reference/code_context/#mkreports.code_context.do_layout","text":"Do the layouting for a content and code block. Parameters: Name Type Description Default code Optional [ MdObj ] The MdObj for the code. If layout is 'nocode', can be None. required content MdObj The content to add. Can't be missing. required layout Layouts Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. required page_info PageInfo PageInfo object corresponding to the page to which it should be added. required Returns: Type Description MdObj A MdObj with the requested layout. Source code in mkreports/code_context.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def do_layout ( code : Optional [ MdObj ], content : MdObj , layout : Layouts , page_info : PageInfo ) -> MdObj : \"\"\" Do the layouting for a content and code block. Args: code (Optional[MdObj]): The MdObj for the code. If layout is 'nocode', can be None. content (MdObj): The content to add. Can't be missing. layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. page_info (PageInfo): PageInfo object corresponding to the page to which it should be added. Returns: A MdObj with the requested layout. \"\"\" if layout == \"nocode\" : return content else : assert code is not None if layout == \"top-c\" : return ( Admonition ( code , page_info = page_info , collapse = True , title = \"Code\" , kind = \"code\" , ) + content + HLine () ) elif layout == \"top-o\" : return code + content + HLine () elif layout == \"bottom-c\" : return ( content + Admonition ( code , page_info = page_info , collapse = True , title = \"Code\" , kind = \"code\" , ) + HLine () ) elif layout == \"bottom-o\" : return content + code + HLine () elif layout == \"tabbed\" : return Tab ( content , title = \"Content\" ) + Tab ( code , title = \"Code\" ) + HLine () else : raise Exception ( \"Unknown layout type.\" )","title":"do_layout()"},{"location":"Reference/config/","text":"repo_root ( path = Path ( '.' )) Find the root of the current repository. Parameters: Name Type Description Default path Path A path in the repository. Path('.') Returns: Type Description Optional [ Path ] Optional[Path]: The root of the repo if it is a repo, None otherwise. Source code in mkreports/config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def repo_root ( path : Path = Path ( \".\" )) -> Optional [ Path ]: \"\"\" Find the root of the current repository. Args: path (Path): A path in the repository. Returns: Optional[Path]: The root of the repo if it is a repo, None otherwise. \"\"\" try : repo = Repo ( path , search_parent_directories = True ) if repo . working_tree_dir is None : return None else : return Path ( repo . working_tree_dir ) except Exception : pass return None set_mkreports_dir ( mkreports_dir = None , repo_root_dir = repo_root ( Path ( os . getcwd ())), mkreports_root_dir = Path ( os . environ . get ( 'MKREPORTS_ROOT_DIR' , Path ( tempfile . gettempdir ()) / 'mkreports' ))) Function to derive the ckpt directory. This is called once at initialization. The reason is that it could change if the working directory is changed and this would be undesirable behavior. Source code in mkreports/config.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def set_mkreports_dir ( mkreports_dir : Optional [ Path ] = None , repo_root_dir : Optional [ Path ] = repo_root ( Path ( os . getcwd ())), mkreports_root_dir : Path = Path ( os . environ . get ( \"MKREPORTS_ROOT_DIR\" , Path ( tempfile . gettempdir ()) / \"mkreports\" ) ), ): \"\"\" Function to derive the ckpt directory. This is called once at initialization. The reason is that it could change if the working directory is changed and this would be undesirable behavior. \"\"\" if mkreports_dir is None : if repo_root_dir is None : mkreports_dir = mkreports_root_dir / \"default\" else : hash_str = hashlib . md5 ( str ( repo_root_dir . resolve ()) . encode ()) . hexdigest () mkreports_dir = mkreports_root_dir / hash_str state [ \"mkreports_dir\" ] = mkreports_dir","title":"config"},{"location":"Reference/config/#mkreports.config.repo_root","text":"Find the root of the current repository. Parameters: Name Type Description Default path Path A path in the repository. Path('.') Returns: Type Description Optional [ Path ] Optional[Path]: The root of the repo if it is a repo, None otherwise. Source code in mkreports/config.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def repo_root ( path : Path = Path ( \".\" )) -> Optional [ Path ]: \"\"\" Find the root of the current repository. Args: path (Path): A path in the repository. Returns: Optional[Path]: The root of the repo if it is a repo, None otherwise. \"\"\" try : repo = Repo ( path , search_parent_directories = True ) if repo . working_tree_dir is None : return None else : return Path ( repo . working_tree_dir ) except Exception : pass return None","title":"repo_root()"},{"location":"Reference/config/#mkreports.config.set_mkreports_dir","text":"Function to derive the ckpt directory. This is called once at initialization. The reason is that it could change if the working directory is changed and this would be undesirable behavior. Source code in mkreports/config.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def set_mkreports_dir ( mkreports_dir : Optional [ Path ] = None , repo_root_dir : Optional [ Path ] = repo_root ( Path ( os . getcwd ())), mkreports_root_dir : Path = Path ( os . environ . get ( \"MKREPORTS_ROOT_DIR\" , Path ( tempfile . gettempdir ()) / \"mkreports\" ) ), ): \"\"\" Function to derive the ckpt directory. This is called once at initialization. The reason is that it could change if the working directory is changed and this would be undesirable behavior. \"\"\" if mkreports_dir is None : if repo_root_dir is None : mkreports_dir = mkreports_root_dir / \"default\" else : hash_str = hashlib . md5 ( str ( repo_root_dir . resolve ()) . encode ()) . hexdigest () mkreports_dir = mkreports_root_dir / hash_str state [ \"mkreports_dir\" ] = mkreports_dir","title":"set_mkreports_dir()"},{"location":"Reference/docs/","text":"add_pkg_docs ( pkg_path , parent_name , report , omit_package_name = False ) Add docstrings of the object to the report Parameters: Name Type Description Default pkg_path Path Path of the package for which to add the docs. required parent_name Union [ NavEntry , Path , str ] Name under which it should be added in the Navigation. required report Report the report to which it should be added. required omit_package_name bool Should the package-name be omitted in the nav? False Source code in mkreports/docs.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def add_pkg_docs ( pkg_path : Path , parent_name : Union [ NavEntry , Path , str ], report : Report , omit_package_name : bool = False , ): \"\"\" Add docstrings of the object to the report Args: pkg_path (Path): Path of the package for which to add the docs. parent_name (Union[NavEntry, Path, str]): Name under which it should be added in the Navigation. report (Report): the report to which it should be added. omit_package_name (bool): Should the package-name be omitted in the nav? \"\"\" # we need the parent name as a nav_entry if isinstance ( parent_name , str ): parent_name = Path ( parent_name ) if isinstance ( parent_name , Path ): parent_name = path_to_nav_entry ( parent_name ) # now iterate through all python entries for path in sorted ( pkg_path . glob ( \"**/*.py\" )): module_path = path . relative_to ( pkg_path . parent ) . with_suffix ( \"\" ) if module_path . name . startswith ( \"_\" ): continue else : if omit_package_name : nav_module_path = Path ( * module_path . parts [ 1 :]) else : nav_module_path = module_path # now create the new nav_entry for this page module_nav_entry = NavEntry ( tuple ( parent_name [ 0 ]) + tuple ( nav_module_path . parts ), ( parent_name [ 1 ] / nav_module_path ) . with_suffix ( \".md\" ), ) # now create a new page and add the doc-entry page = report . page ( module_nav_entry , truncate = True ) page . add ( page . md . Docstring ( \".\" . join ( module_path . parts )))","title":"docs"},{"location":"Reference/docs/#mkreports.docs.add_pkg_docs","text":"Add docstrings of the object to the report Parameters: Name Type Description Default pkg_path Path Path of the package for which to add the docs. required parent_name Union [ NavEntry , Path , str ] Name under which it should be added in the Navigation. required report Report the report to which it should be added. required omit_package_name bool Should the package-name be omitted in the nav? False Source code in mkreports/docs.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def add_pkg_docs ( pkg_path : Path , parent_name : Union [ NavEntry , Path , str ], report : Report , omit_package_name : bool = False , ): \"\"\" Add docstrings of the object to the report Args: pkg_path (Path): Path of the package for which to add the docs. parent_name (Union[NavEntry, Path, str]): Name under which it should be added in the Navigation. report (Report): the report to which it should be added. omit_package_name (bool): Should the package-name be omitted in the nav? \"\"\" # we need the parent name as a nav_entry if isinstance ( parent_name , str ): parent_name = Path ( parent_name ) if isinstance ( parent_name , Path ): parent_name = path_to_nav_entry ( parent_name ) # now iterate through all python entries for path in sorted ( pkg_path . glob ( \"**/*.py\" )): module_path = path . relative_to ( pkg_path . parent ) . with_suffix ( \"\" ) if module_path . name . startswith ( \"_\" ): continue else : if omit_package_name : nav_module_path = Path ( * module_path . parts [ 1 :]) else : nav_module_path = module_path # now create the new nav_entry for this page module_nav_entry = NavEntry ( tuple ( parent_name [ 0 ]) + tuple ( nav_module_path . parts ), ( parent_name [ 1 ] / nav_module_path ) . with_suffix ( \".md\" ), ) # now create a new page and add the doc-entry page = report . page ( module_nav_entry , truncate = True ) page . add ( page . md . Docstring ( \".\" . join ( module_path . parts )))","title":"add_pkg_docs()"},{"location":"Reference/exceptions/","text":"All Exception classes that we are using in the package. CannotTrackError Bases: Exception Tracking is not possible. Source code in mkreports/exceptions.py 54 55 56 57 class CannotTrackError ( Exception ): \"\"\"Tracking is not possible.\"\"\" pass ContextActiveError Bases: Exception The code-context is active and it should not be. Source code in mkreports/exceptions.py 66 67 68 69 class ContextActiveError ( Exception ): \"\"\"The code-context is active and it should not be.\"\"\" pass IncorrectSuffixError Bases: Exception An incorrect suffix was given. Source code in mkreports/exceptions.py 60 61 62 63 class IncorrectSuffixError ( Exception ): \"\"\"An incorrect suffix was given.\"\"\" pass PageNotExistsError Bases: Exception The page does not exist. Source code in mkreports/exceptions.py 24 25 26 27 class PageNotExistsError ( Exception ): \"\"\"The page does not exist.\"\"\" pass ReportExistsError Bases: Exception Report already exists. Source code in mkreports/exceptions.py 6 7 8 9 class ReportExistsError ( Exception ): \"\"\"Report already exists.\"\"\" pass ReportNotExistsError Bases: Exception The given path for a report does not exist. Source code in mkreports/exceptions.py 12 13 14 15 class ReportNotExistsError ( Exception ): \"\"\"The given path for a report does not exist.\"\"\" pass ReportNotValidError Bases: Exception The given path does not represent a valid report. Source code in mkreports/exceptions.py 18 19 20 21 class ReportNotValidError ( Exception ): \"\"\"The given path does not represent a valid report.\"\"\" pass TrackerActiveError Bases: Exception The tracker is active and it should not be. Source code in mkreports/exceptions.py 42 43 44 45 class TrackerActiveError ( Exception ): \"\"\"The tracker is active and it should not be.\"\"\" pass TrackerEmptyError Bases: Exception The tracker is empty. Source code in mkreports/exceptions.py 36 37 38 39 class TrackerEmptyError ( Exception ): \"\"\"The tracker is empty.\"\"\" pass TrackerIncompleteError Bases: Exception The tracker has not yet completed. Source code in mkreports/exceptions.py 30 31 32 33 class TrackerIncompleteError ( Exception ): \"\"\"The tracker has not yet completed.\"\"\" pass TrackerNotActiveError Bases: Exception The tracker is not active and it should be active. Source code in mkreports/exceptions.py 48 49 50 51 class TrackerNotActiveError ( Exception ): \"\"\"The tracker is not active and it should be active.\"\"\" pass","title":"exceptions"},{"location":"Reference/exceptions/#mkreports.exceptions.CannotTrackError","text":"Bases: Exception Tracking is not possible. Source code in mkreports/exceptions.py 54 55 56 57 class CannotTrackError ( Exception ): \"\"\"Tracking is not possible.\"\"\" pass","title":"CannotTrackError"},{"location":"Reference/exceptions/#mkreports.exceptions.ContextActiveError","text":"Bases: Exception The code-context is active and it should not be. Source code in mkreports/exceptions.py 66 67 68 69 class ContextActiveError ( Exception ): \"\"\"The code-context is active and it should not be.\"\"\" pass","title":"ContextActiveError"},{"location":"Reference/exceptions/#mkreports.exceptions.IncorrectSuffixError","text":"Bases: Exception An incorrect suffix was given. Source code in mkreports/exceptions.py 60 61 62 63 class IncorrectSuffixError ( Exception ): \"\"\"An incorrect suffix was given.\"\"\" pass","title":"IncorrectSuffixError"},{"location":"Reference/exceptions/#mkreports.exceptions.PageNotExistsError","text":"Bases: Exception The page does not exist. Source code in mkreports/exceptions.py 24 25 26 27 class PageNotExistsError ( Exception ): \"\"\"The page does not exist.\"\"\" pass","title":"PageNotExistsError"},{"location":"Reference/exceptions/#mkreports.exceptions.ReportExistsError","text":"Bases: Exception Report already exists. Source code in mkreports/exceptions.py 6 7 8 9 class ReportExistsError ( Exception ): \"\"\"Report already exists.\"\"\" pass","title":"ReportExistsError"},{"location":"Reference/exceptions/#mkreports.exceptions.ReportNotExistsError","text":"Bases: Exception The given path for a report does not exist. Source code in mkreports/exceptions.py 12 13 14 15 class ReportNotExistsError ( Exception ): \"\"\"The given path for a report does not exist.\"\"\" pass","title":"ReportNotExistsError"},{"location":"Reference/exceptions/#mkreports.exceptions.ReportNotValidError","text":"Bases: Exception The given path does not represent a valid report. Source code in mkreports/exceptions.py 18 19 20 21 class ReportNotValidError ( Exception ): \"\"\"The given path does not represent a valid report.\"\"\" pass","title":"ReportNotValidError"},{"location":"Reference/exceptions/#mkreports.exceptions.TrackerActiveError","text":"Bases: Exception The tracker is active and it should not be. Source code in mkreports/exceptions.py 42 43 44 45 class TrackerActiveError ( Exception ): \"\"\"The tracker is active and it should not be.\"\"\" pass","title":"TrackerActiveError"},{"location":"Reference/exceptions/#mkreports.exceptions.TrackerEmptyError","text":"Bases: Exception The tracker is empty. Source code in mkreports/exceptions.py 36 37 38 39 class TrackerEmptyError ( Exception ): \"\"\"The tracker is empty.\"\"\" pass","title":"TrackerEmptyError"},{"location":"Reference/exceptions/#mkreports.exceptions.TrackerIncompleteError","text":"Bases: Exception The tracker has not yet completed. Source code in mkreports/exceptions.py 30 31 32 33 class TrackerIncompleteError ( Exception ): \"\"\"The tracker has not yet completed.\"\"\" pass","title":"TrackerIncompleteError"},{"location":"Reference/exceptions/#mkreports.exceptions.TrackerNotActiveError","text":"Bases: Exception The tracker is not active and it should be active. Source code in mkreports/exceptions.py 48 49 50 51 class TrackerNotActiveError ( Exception ): \"\"\"The tracker is not active and it should be active.\"\"\" pass","title":"TrackerNotActiveError"},{"location":"Reference/ipython/","text":"ConsoleWriter Bases: Magics Class that connects IPython with mkreports using magics. Source code in mkreports/ipython.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @magics_class class ConsoleWriter ( Magics ): \"\"\" Class that connects IPython with mkreports using magics. \"\"\" handlers : List [ Handler ] console : Page def __init__ ( self , ip ): \"\"\"Initialization. Not for end-users.\"\"\" super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] # identify an mkreport self . report = Report . create ( get_mkreports_dir (), report_name = \"Mkreports console\" , exist_ok = True , ) self . _open_console () self . _set_default_handlers () def _set_default_handlers ( self ): self . handlers = create_default_handlers ( self . console . md ) def _get_handler ( self , obj : Any ) -> Optional [ Handler ]: return get_handler ( obj , self . handlers ) def _open_console ( self ) -> None : self . console = self . report . page ( Path ( \"console/active.md\" ), add_bottom = False ) # make sure the table of contents does not get shown self . console . HideToc () @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. Args: line (str): ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( str ( self . console . path ), new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . _open_console () def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . _get_handler ( result . result ) if handler is not None : content = handler . func ( result . result ) code = md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ) code_content = do_layout ( code = code , content = content , layout = self . console . code_layout , page_info = self . console . page_info , ) # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + code_content ) self . console . add ( post ) self . stored_code = [] __init__ ( ip ) Initialization. Not for end-users. Source code in mkreports/ipython.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , ip ): \"\"\"Initialization. Not for end-users.\"\"\" super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] # identify an mkreport self . report = Report . create ( get_mkreports_dir (), report_name = \"Mkreports console\" , exist_ok = True , ) self . _open_console () self . _set_default_handlers () archive_console ( line ) Function to archive the console. This is also a line magic, however the line itself will be ignored. Parameters: Name Type Description Default line str ignored. required Source code in mkreports/ipython.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. Args: line (str): ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( str ( self . console . path ), new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . _open_console () post_run_cell ( result ) Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. Source code in mkreports/ipython.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . _get_handler ( result . result ) if handler is not None : content = handler . func ( result . result ) code = md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ) code_content = do_layout ( code = code , content = content , layout = self . console . code_layout , page_info = self . console . page_info , ) # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + code_content ) self . console . add ( post ) self . stored_code = [] load_ipython_extension ( ip ) Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. Source code in mkreports/ipython.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def load_ipython_extension ( ip ): \"\"\" Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. \"\"\" cw = ConsoleWriter ( ip ) cw . shell . push ({ \"md\" : cw . console . md , \"cons\" : cw . console }) ip . events . register ( \"post_run_cell\" , cw . post_run_cell ) ip . register_magics ( cw )","title":"ipython"},{"location":"Reference/ipython/#mkreports.ipython.ConsoleWriter","text":"Bases: Magics Class that connects IPython with mkreports using magics. Source code in mkreports/ipython.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @magics_class class ConsoleWriter ( Magics ): \"\"\" Class that connects IPython with mkreports using magics. \"\"\" handlers : List [ Handler ] console : Page def __init__ ( self , ip ): \"\"\"Initialization. Not for end-users.\"\"\" super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] # identify an mkreport self . report = Report . create ( get_mkreports_dir (), report_name = \"Mkreports console\" , exist_ok = True , ) self . _open_console () self . _set_default_handlers () def _set_default_handlers ( self ): self . handlers = create_default_handlers ( self . console . md ) def _get_handler ( self , obj : Any ) -> Optional [ Handler ]: return get_handler ( obj , self . handlers ) def _open_console ( self ) -> None : self . console = self . report . page ( Path ( \"console/active.md\" ), add_bottom = False ) # make sure the table of contents does not get shown self . console . HideToc () @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. Args: line (str): ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( str ( self . console . path ), new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . _open_console () def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . _get_handler ( result . result ) if handler is not None : content = handler . func ( result . result ) code = md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ) code_content = do_layout ( code = code , content = content , layout = self . console . code_layout , page_info = self . console . page_info , ) # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + code_content ) self . console . add ( post ) self . stored_code = []","title":"ConsoleWriter"},{"location":"Reference/ipython/#mkreports.ipython.ConsoleWriter.__init__","text":"Initialization. Not for end-users. Source code in mkreports/ipython.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __init__ ( self , ip ): \"\"\"Initialization. Not for end-users.\"\"\" super () . __init__ ( ip ) self . shell = ip self . handlers = [] self . stored_code = [] # identify an mkreport self . report = Report . create ( get_mkreports_dir (), report_name = \"Mkreports console\" , exist_ok = True , ) self . _open_console () self . _set_default_handlers ()","title":"__init__()"},{"location":"Reference/ipython/#mkreports.ipython.ConsoleWriter.archive_console","text":"Function to archive the console. This is also a line magic, however the line itself will be ignored. Parameters: Name Type Description Default line str ignored. required Source code in mkreports/ipython.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @line_magic def archive_console ( self , line ): \"\"\" Function to archive the console. This is also a line magic, however the line itself will be ignored. Args: line (str): ignored. \"\"\" del line # we also need to add a navigation entry new_entry = [ \"Console\" , f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ] new_path = ( self . console . path . parent / f \" { datetime . now () . strftime ( '%Y%m %d _%H%M%S' ) } .md\" ) # we move the page out of the way shutil . move ( str ( self . console . path ), new_path , ) self . report . _add_nav_entry (( new_entry , new_path )) self . _open_console ()","title":"archive_console()"},{"location":"Reference/ipython/#mkreports.ipython.ConsoleWriter.post_run_cell","text":"Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. Source code in mkreports/ipython.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def post_run_cell ( self , result ): \"\"\" Print any results of certain classes automatically to the console. Here we set some defaults so that results of certain classes are automatically written to the console, mostly data tables and images. These will then also have the corresponding code attached to them. \"\"\" if result . success : # we store the cell content self . stored_code . append ( result . info . raw_cell ) handler = self . _get_handler ( result . result ) if handler is not None : content = handler . func ( result . result ) code = md . Code ( \" \\n \" . join ( self . stored_code ), language = \"python\" ) code_content = do_layout ( code = code , content = content , layout = self . console . code_layout , page_info = self . console . page_info , ) # and we also want a separator and a date post = ( md . H6 ( f \" { datetime . now () . strftime ( '%Y/%m/ %d %H:%M:%S' ) } \" ) + code_content ) self . console . add ( post ) self . stored_code = []","title":"post_run_cell()"},{"location":"Reference/ipython/#mkreports.ipython.load_ipython_extension","text":"Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. Source code in mkreports/ipython.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def load_ipython_extension ( ip ): \"\"\" Loading of the IPython Extension. Identify the report to use and export a page representing the console to use. Also insert handlers that automatically send appropriate results to be appended to the console. The console object should be part of the user-space, same as the markdown module for use. \"\"\" cw = ConsoleWriter ( ip ) cw . shell . push ({ \"md\" : cw . console . md , \"cons\" : cw . console }) ip . events . register ( \"post_run_cell\" , cw . post_run_cell ) ip . register_magics ( cw )","title":"load_ipython_extension()"},{"location":"Reference/page/","text":"Page Represents a single page of report. Source code in mkreports/page.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 class Page : \"\"\"Represents a single page of report.\"\"\" def __init__ ( self , path : Path , report : \"Report\" , # type: ignore code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> None : \"\"\" Initialize a page. Usually this is not used and instead a page is created using the *page* method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Args: path (Path): Path to the page (absolute or relative to cwd). report (Report): The report object to which the page belongs. code_layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. code_name_only (bool): For code files, should only the name be used instead of the path. add_bottom (bool): Should new entries be added at the bottom? At the top used for IPython. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( page_info = self . page_info , md_defaults = md_defaults ) self . code_context_stack : List [ CodeContext ] = [] def __enter__ ( self ) -> \"Page\" : if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to enter a new context self . code_context_stack . append ( CodeContext ( layout = self . code_layout , name_only = self . code_name_only , add_bottom = self . add_bottom , relative_to = self . report . project_root , ) ) else : # use the existing one that is not active yet pass # the last one on the stack is the one we activate self . code_context_stack [ - 1 ] . __enter__ () return self def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : \"\"\" Sets the next context to be used. Only counts for the next tracking context. Args: layout (Optional[Layouts]): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. name_only (Optional[bool]): In the code block, should only the name of the file be used. add_bottom (Optional[bool]): Is new output added to the bottom or top. Returns: Page: The page object, but with the new *CodeContext* object set. \"\"\" new_code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , relative_to = self . report . project_root , ) if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to add new one self . code_context_stack . append ( new_code_context ) else : # need to replace existing one self . code_context_stack [ - 1 ] = new_code_context return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : if len ( self . code_context_stack ) == 0 : raise Exception ( \"__exit__ called before __enter__\" ) active_code_context = self . code_context_stack . pop () active_code_context . __exit__ ( exc_type , exc_val , traceback ) # self.add accounts for remaining active code_context self . add ( active_code_context . md_obj ( page_info = self . page_info )) def __getattr__ ( self , name ): md_class = self . md . __getattr__ ( name ) def md_and_add ( * args , ** kwargs ): kwargs_add = {} kwargs_md = kwargs # now apply to md md_obj = md_class ( * args , ** kwargs_md ) return self . add ( md_obj , ** kwargs_add ) return md_and_add def __copy__ ( self ): cls = self . __class__ result = cls . __new__ ( cls ) result . __dict__ . update ( self . __dict__ ) return result @property def page_info ( self ): \"\"\" Returns: PageInfo: An object with info about the page used in markdown objects. \"\"\" return PageInfo ( store_path = self . store_path , report_path = self . report . path , javascript_path = self . report . javascript_path , project_root = self . report . project_root , idstore = self . _idstore , page_path = self . path , ) @property def path ( self ) -> Path : \"\"\" Returns: Path: Absolute path to the page. \"\"\" return self . _path @property def rel_path ( self ) -> Path : \"\"\" Returns: Path: Relative to the docs_dir of the report. \"\"\" return self . _path . relative_to ( self . report . docs_dir ) @property def nav_entry ( self ) -> NavEntry : \"\"\" Returns: NavEntry for this page. \"\"\" nav_entry = self . report . get_nav_entry ( self . rel_path ) # the entry cannot be none, or the page would not exist assert nav_entry is not None return nav_entry @property def store_path ( self ) -> Path : \"\"\" Returns: Path: Location of the path for object storage for the page. \"\"\" return self . path . parent / ( self . _path . stem + \"_store\" ) def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : \"\"\" Add a MdObj to the page. Args: item (Union[MdObj, Text]): Object to add to the page Returns: Page: The page itself. \"\"\" # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # search from the top for active code_context active_code_context = None for i in reversed ( range ( len ( self . code_context_stack ))): if self . code_context_stack [ i ] . active : active_code_context = self . code_context_stack [ i ] break # if a context-manager is active, pass along the object into there if active_code_context is not None : active_code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self def _add_to_page ( self , item : MdObj , ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" # call the markdown and the backmatter md_text = item . body + item . back req = item . settings if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in settings of markdown item\" ) self . report . settings . merge ( req . mkdocs ) metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , req . page ) if self . add_bottom : content = content + md_text . format_text ( content , \"\" ) else : content = md_text . format_text ( \"\" , content ) + content write_page ( self . path , metadata , content ) @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule. \"\"\" return self . _md def __getstate__ ( self ): return self . __dict__ def __setstate__ ( self , d ): self . __dict__ . update ( d ) def __eq__ ( self , other ): if type ( self ) != type ( other ): return False return self . __dict__ == other . __dict__ __init__ ( path , report , code_layout = 'tabbed' , code_name_only = False , add_bottom = True , md_defaults = None ) Initialize a page. Usually this is not used and instead a page is created using the page method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Parameters: Name Type Description Default path Path Path to the page (absolute or relative to cwd). required report Report The report object to which the page belongs. required code_layout Layouts Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. 'tabbed' code_name_only bool For code files, should only the name be used instead of the path. False add_bottom bool Should new entries be added at the bottom? At the top used for IPython. True md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None Source code in mkreports/page.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def __init__ ( self , path : Path , report : \"Report\" , # type: ignore code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> None : \"\"\" Initialize a page. Usually this is not used and instead a page is created using the *page* method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Args: path (Path): Path to the page (absolute or relative to cwd). report (Report): The report object to which the page belongs. code_layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. code_name_only (bool): For code files, should only the name be used instead of the path. add_bottom (bool): Should new entries be added at the bottom? At the top used for IPython. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( page_info = self . page_info , md_defaults = md_defaults ) self . code_context_stack : List [ CodeContext ] = [] _add_to_page ( item ) Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 Source code in mkreports/page.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def _add_to_page ( self , item : MdObj , ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" # call the markdown and the backmatter md_text = item . body + item . back req = item . settings if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in settings of markdown item\" ) self . report . settings . merge ( req . mkdocs ) metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , req . page ) if self . add_bottom : content = content + md_text . format_text ( content , \"\" ) else : content = md_text . format_text ( \"\" , content ) + content write_page ( self . path , metadata , content ) add ( item ) Add a MdObj to the page. Parameters: Name Type Description Default item Union [ MdObj , Text ] Object to add to the page required Returns: Name Type Description Page 'Page' The page itself. Source code in mkreports/page.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : \"\"\" Add a MdObj to the page. Args: item (Union[MdObj, Text]): Object to add to the page Returns: Page: The page itself. \"\"\" # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # search from the top for active code_context active_code_context = None for i in reversed ( range ( len ( self . code_context_stack ))): if self . code_context_stack [ i ] . active : active_code_context = self . code_context_stack [ i ] break # if a context-manager is active, pass along the object into there if active_code_context is not None : active_code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self clear () Clear the page markdown file and the generated assets directory. Source code in mkreports/page.py 266 267 268 269 def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () ctx ( layout = None , name_only = None , add_bottom = None ) Sets the next context to be used. Only counts for the next tracking context. Parameters: Name Type Description Default layout Optional [ Layouts ] The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. None name_only Optional [ bool ] In the code block, should only the name of the file be used. None add_bottom Optional [ bool ] Is new output added to the bottom or top. None Returns: Name Type Description Page 'Page' The page object, but with the new CodeContext object set. Source code in mkreports/page.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : \"\"\" Sets the next context to be used. Only counts for the next tracking context. Args: layout (Optional[Layouts]): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. name_only (Optional[bool]): In the code block, should only the name of the file be used. add_bottom (Optional[bool]): Is new output added to the bottom or top. Returns: Page: The page object, but with the new *CodeContext* object set. \"\"\" new_code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , relative_to = self . report . project_root , ) if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to add new one self . code_context_stack . append ( new_code_context ) else : # need to replace existing one self . code_context_stack [ - 1 ] = new_code_context return self md () A proxy for the 'md' submodule. Source code in mkreports/page.py 344 345 346 347 348 349 @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule. \"\"\" return self . _md nav_entry () Returns: Type Description NavEntry NavEntry for this page. Source code in mkreports/page.py 244 245 246 247 248 249 250 251 252 253 254 255 @property def nav_entry ( self ) -> NavEntry : \"\"\" Returns: NavEntry for this page. \"\"\" nav_entry = self . report . get_nav_entry ( self . rel_path ) # the entry cannot be none, or the page would not exist assert nav_entry is not None return nav_entry page_info () Returns: Name Type Description PageInfo An object with info about the page used in markdown objects. Source code in mkreports/page.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @property def page_info ( self ): \"\"\" Returns: PageInfo: An object with info about the page used in markdown objects. \"\"\" return PageInfo ( store_path = self . store_path , report_path = self . report . path , javascript_path = self . report . javascript_path , project_root = self . report . project_root , idstore = self . _idstore , page_path = self . path , ) path () Returns: Name Type Description Path Path Absolute path to the page. Source code in mkreports/page.py 226 227 228 229 230 231 232 233 @property def path ( self ) -> Path : \"\"\" Returns: Path: Absolute path to the page. \"\"\" return self . _path rel_path () Returns: Name Type Description Path Path Relative to the docs_dir of the report. Source code in mkreports/page.py 235 236 237 238 239 240 241 242 @property def rel_path ( self ) -> Path : \"\"\" Returns: Path: Relative to the docs_dir of the report. \"\"\" return self . _path . relative_to ( self . report . docs_dir ) store_path () Returns: Name Type Description Path Path Location of the path for object storage for the page. Source code in mkreports/page.py 257 258 259 260 261 262 263 264 @property def store_path ( self ) -> Path : \"\"\" Returns: Path: Location of the path for object storage for the page. \"\"\" return self . path . parent / ( self . _path . stem + \"_store\" )","title":"page"},{"location":"Reference/page/#mkreports.page.Page","text":"Represents a single page of report. Source code in mkreports/page.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 class Page : \"\"\"Represents a single page of report.\"\"\" def __init__ ( self , path : Path , report : \"Report\" , # type: ignore code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> None : \"\"\" Initialize a page. Usually this is not used and instead a page is created using the *page* method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Args: path (Path): Path to the page (absolute or relative to cwd). report (Report): The report object to which the page belongs. code_layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. code_name_only (bool): For code files, should only the name be used instead of the path. add_bottom (bool): Should new entries be added at the bottom? At the top used for IPython. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( page_info = self . page_info , md_defaults = md_defaults ) self . code_context_stack : List [ CodeContext ] = [] def __enter__ ( self ) -> \"Page\" : if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to enter a new context self . code_context_stack . append ( CodeContext ( layout = self . code_layout , name_only = self . code_name_only , add_bottom = self . add_bottom , relative_to = self . report . project_root , ) ) else : # use the existing one that is not active yet pass # the last one on the stack is the one we activate self . code_context_stack [ - 1 ] . __enter__ () return self def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : \"\"\" Sets the next context to be used. Only counts for the next tracking context. Args: layout (Optional[Layouts]): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. name_only (Optional[bool]): In the code block, should only the name of the file be used. add_bottom (Optional[bool]): Is new output added to the bottom or top. Returns: Page: The page object, but with the new *CodeContext* object set. \"\"\" new_code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , relative_to = self . report . project_root , ) if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to add new one self . code_context_stack . append ( new_code_context ) else : # need to replace existing one self . code_context_stack [ - 1 ] = new_code_context return self def __exit__ ( self , exc_type , exc_val , traceback ) -> None : if len ( self . code_context_stack ) == 0 : raise Exception ( \"__exit__ called before __enter__\" ) active_code_context = self . code_context_stack . pop () active_code_context . __exit__ ( exc_type , exc_val , traceback ) # self.add accounts for remaining active code_context self . add ( active_code_context . md_obj ( page_info = self . page_info )) def __getattr__ ( self , name ): md_class = self . md . __getattr__ ( name ) def md_and_add ( * args , ** kwargs ): kwargs_add = {} kwargs_md = kwargs # now apply to md md_obj = md_class ( * args , ** kwargs_md ) return self . add ( md_obj , ** kwargs_add ) return md_and_add def __copy__ ( self ): cls = self . __class__ result = cls . __new__ ( cls ) result . __dict__ . update ( self . __dict__ ) return result @property def page_info ( self ): \"\"\" Returns: PageInfo: An object with info about the page used in markdown objects. \"\"\" return PageInfo ( store_path = self . store_path , report_path = self . report . path , javascript_path = self . report . javascript_path , project_root = self . report . project_root , idstore = self . _idstore , page_path = self . path , ) @property def path ( self ) -> Path : \"\"\" Returns: Path: Absolute path to the page. \"\"\" return self . _path @property def rel_path ( self ) -> Path : \"\"\" Returns: Path: Relative to the docs_dir of the report. \"\"\" return self . _path . relative_to ( self . report . docs_dir ) @property def nav_entry ( self ) -> NavEntry : \"\"\" Returns: NavEntry for this page. \"\"\" nav_entry = self . report . get_nav_entry ( self . rel_path ) # the entry cannot be none, or the page would not exist assert nav_entry is not None return nav_entry @property def store_path ( self ) -> Path : \"\"\" Returns: Path: Location of the path for object storage for the page. \"\"\" return self . path . parent / ( self . _path . stem + \"_store\" ) def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink () def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : \"\"\" Add a MdObj to the page. Args: item (Union[MdObj, Text]): Object to add to the page Returns: Page: The page itself. \"\"\" # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # search from the top for active code_context active_code_context = None for i in reversed ( range ( len ( self . code_context_stack ))): if self . code_context_stack [ i ] . active : active_code_context = self . code_context_stack [ i ] break # if a context-manager is active, pass along the object into there if active_code_context is not None : active_code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self def _add_to_page ( self , item : MdObj , ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" # call the markdown and the backmatter md_text = item . body + item . back req = item . settings if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in settings of markdown item\" ) self . report . settings . merge ( req . mkdocs ) metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , req . page ) if self . add_bottom : content = content + md_text . format_text ( content , \"\" ) else : content = md_text . format_text ( \"\" , content ) + content write_page ( self . path , metadata , content ) @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule. \"\"\" return self . _md def __getstate__ ( self ): return self . __dict__ def __setstate__ ( self , d ): self . __dict__ . update ( d ) def __eq__ ( self , other ): if type ( self ) != type ( other ): return False return self . __dict__ == other . __dict__","title":"Page"},{"location":"Reference/page/#mkreports.page.Page.__init__","text":"Initialize a page. Usually this is not used and instead a page is created using the page method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Parameters: Name Type Description Default path Path Path to the page (absolute or relative to cwd). required report Report The report object to which the page belongs. required code_layout Layouts Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. 'tabbed' code_name_only bool For code files, should only the name be used instead of the path. False add_bottom bool Should new entries be added at the bottom? At the top used for IPython. True md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None Source code in mkreports/page.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def __init__ ( self , path : Path , report : \"Report\" , # type: ignore code_layout : Layouts = \"tabbed\" , code_name_only : bool = False , add_bottom : bool = True , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> None : \"\"\" Initialize a page. Usually this is not used and instead a page is created using the *page* method on a report. A page is also a context manager. If the context manager is active, code that is run in it is being tracked and added to the output with the specified layouts. The specified layout is used for all code tracking. Only one context-manager for a page can be active at a time. Args: path (Path): Path to the page (absolute or relative to cwd). report (Report): The report object to which the page belongs. code_layout (Layouts): Type of layout for code-tracking. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. code_name_only (bool): For code files, should only the name be used instead of the path. add_bottom (bool): Should new entries be added at the bottom? At the top used for IPython. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" self . _path = path . absolute () # check that the file exists and ends with .md if not self . path . exists (): raise FileNotFoundError ( f \"file { self . path } does not exist.\" ) if not self . path . suffix == \".md\" : raise IncorrectSuffixError ( f \"file { self . path } does not have suffix '.md'\" ) # we need to parse the file for ids self . _idstore = IDStore ( used_ids = find_comment_ids ( self . path . read_text ())) self . report = report self . add_bottom = add_bottom self . code_layout : Layouts = code_layout self . code_name_only = code_name_only self . _md = MdProxy ( page_info = self . page_info , md_defaults = md_defaults ) self . code_context_stack : List [ CodeContext ] = []","title":"__init__()"},{"location":"Reference/page/#mkreports.page.Page._add_to_page","text":"Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 Source code in mkreports/page.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def _add_to_page ( self , item : MdObj , ) -> None : \"\"\" Read the frontmatter and merge it with the additional settings. The reason that we do this separately is a minor issue in the frontmatter library, that filters the newlines at the end of the file. https://github.com/eyeseast/python-frontmatter/issues/87 \"\"\" # call the markdown and the backmatter md_text = item . body + item . back req = item . settings if len ( req . mkdocs ) > 0 : # merge these things into mkdocs # there is not allowed to be a nav here if \"nav\" in req . mkdocs : raise ValueError ( \"nav not allowed to be in settings of markdown item\" ) self . report . settings . merge ( req . mkdocs ) metadata , content = load_page ( self . path ) # we need to read the whole page anyway metadata = merge_settings ( metadata , req . page ) if self . add_bottom : content = content + md_text . format_text ( content , \"\" ) else : content = md_text . format_text ( \"\" , content ) + content write_page ( self . path , metadata , content )","title":"_add_to_page()"},{"location":"Reference/page/#mkreports.page.Page.add","text":"Add a MdObj to the page. Parameters: Name Type Description Default item Union [ MdObj , Text ] Object to add to the page required Returns: Name Type Description Page 'Page' The page itself. Source code in mkreports/page.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def add ( self , item : Union [ MdObj , Text ], ) -> \"Page\" : \"\"\" Add a MdObj to the page. Args: item (Union[MdObj, Text]): Object to add to the page Returns: Page: The page itself. \"\"\" # first ensure that item is an MdObj if isinstance ( item , str ): item = Raw ( item , dedent = True ) elif isinstance ( item , SpacedText ): item = Raw ( item ) # search from the top for active code_context active_code_context = None for i in reversed ( range ( len ( self . code_context_stack ))): if self . code_context_stack [ i ] . active : active_code_context = self . code_context_stack [ i ] break # if a context-manager is active, pass along the object into there if active_code_context is not None : active_code_context . add ( item ) else : # else pass it directly to the page self . _add_to_page ( item ) # we return a copy of the page, but with the code context not copied # the copy is therefore a shallow copy # page_copy = copy.copy(self) # page_copy.code_context = None return self","title":"add()"},{"location":"Reference/page/#mkreports.page.Page.clear","text":"Clear the page markdown file and the generated assets directory. Source code in mkreports/page.py 266 267 268 269 def clear ( self ) -> None : \"\"\"Clear the page markdown file and the generated assets directory.\"\"\" shutil . rmtree ( self . store_path ) self . path . unlink ()","title":"clear()"},{"location":"Reference/page/#mkreports.page.Page.ctx","text":"Sets the next context to be used. Only counts for the next tracking context. Parameters: Name Type Description Default layout Optional [ Layouts ] The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. None name_only Optional [ bool ] In the code block, should only the name of the file be used. None add_bottom Optional [ bool ] Is new output added to the bottom or top. None Returns: Name Type Description Page 'Page' The page object, but with the new CodeContext object set. Source code in mkreports/page.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def ctx ( self , layout : Optional [ Layouts ] = None , name_only : Optional [ bool ] = None , add_bottom : Optional [ bool ] = None , ) -> \"Page\" : \"\"\" Sets the next context to be used. Only counts for the next tracking context. Args: layout (Optional[Layouts]): The layout to use. One of 'tabbed', 'top-o', 'top-c', 'bottom-o', 'bottom-c' or 'nocode'. name_only (Optional[bool]): In the code block, should only the name of the file be used. add_bottom (Optional[bool]): Is new output added to the bottom or top. Returns: Page: The page object, but with the new *CodeContext* object set. \"\"\" new_code_context = CodeContext ( layout = layout if layout is not None else self . code_layout , name_only = name_only if name_only is not None else self . code_name_only , add_bottom = add_bottom if add_bottom is not None else self . add_bottom , relative_to = self . report . project_root , ) if len ( self . code_context_stack ) == 0 or ( len ( self . code_context_stack ) > 0 and self . code_context_stack [ - 1 ] . active ): # need to add new one self . code_context_stack . append ( new_code_context ) else : # need to replace existing one self . code_context_stack [ - 1 ] = new_code_context return self","title":"ctx()"},{"location":"Reference/page/#mkreports.page.Page.md","text":"A proxy for the 'md' submodule. Source code in mkreports/page.py 344 345 346 347 348 349 @property def md ( self ) -> MdProxy : \"\"\" A proxy for the 'md' submodule. \"\"\" return self . _md","title":"md()"},{"location":"Reference/page/#mkreports.page.Page.nav_entry","text":"Returns: Type Description NavEntry NavEntry for this page. Source code in mkreports/page.py 244 245 246 247 248 249 250 251 252 253 254 255 @property def nav_entry ( self ) -> NavEntry : \"\"\" Returns: NavEntry for this page. \"\"\" nav_entry = self . report . get_nav_entry ( self . rel_path ) # the entry cannot be none, or the page would not exist assert nav_entry is not None return nav_entry","title":"nav_entry()"},{"location":"Reference/page/#mkreports.page.Page.page_info","text":"Returns: Name Type Description PageInfo An object with info about the page used in markdown objects. Source code in mkreports/page.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 @property def page_info ( self ): \"\"\" Returns: PageInfo: An object with info about the page used in markdown objects. \"\"\" return PageInfo ( store_path = self . store_path , report_path = self . report . path , javascript_path = self . report . javascript_path , project_root = self . report . project_root , idstore = self . _idstore , page_path = self . path , )","title":"page_info()"},{"location":"Reference/page/#mkreports.page.Page.path","text":"Returns: Name Type Description Path Path Absolute path to the page. Source code in mkreports/page.py 226 227 228 229 230 231 232 233 @property def path ( self ) -> Path : \"\"\" Returns: Path: Absolute path to the page. \"\"\" return self . _path","title":"path()"},{"location":"Reference/page/#mkreports.page.Page.rel_path","text":"Returns: Name Type Description Path Path Relative to the docs_dir of the report. Source code in mkreports/page.py 235 236 237 238 239 240 241 242 @property def rel_path ( self ) -> Path : \"\"\" Returns: Path: Relative to the docs_dir of the report. \"\"\" return self . _path . relative_to ( self . report . docs_dir )","title":"rel_path()"},{"location":"Reference/page/#mkreports.page.Page.store_path","text":"Returns: Name Type Description Path Path Location of the path for object storage for the page. Source code in mkreports/page.py 257 258 259 260 261 262 263 264 @property def store_path ( self ) -> Path : \"\"\" Returns: Path: Location of the path for object storage for the page. \"\"\" return self . path . parent / ( self . _path . stem + \"_store\" )","title":"store_path()"},{"location":"Reference/parser/","text":"A simple class to provide access to full extent of statements with starting and ending lines. closest_after ( tree , lineno ) Return the closest item strictly before lineno. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional [ Interval ] Optional[Interval]: An interval representing closest statement after the line if there is a statement after. Source code in mkreports/parser.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def closest_after ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval representing closest statement after the line if there is a statement after. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line # rest by difference to current line after_list = [ x for x in tree_list if ( x . begin > lineno )] after_list . sort ( key = lambda x : x . begin - lineno ) if len ( after_list ) > 0 : return after_list [ 0 ] else : return None closest_before ( tree , lineno ) Return the closest item strictly before lineno. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional [ Interval ] Optional[Interval]: An interval representing closest statement before the line if there is a statement before. Source code in mkreports/parser.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def closest_before ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval representing closest statement before the line if there is a statement before. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line before_list = [ x for x in tree_list if ( x . begin < lineno )] before_list . sort ( key = lambda x : lineno - x . begin ) if len ( before_list ) > 0 : return before_list [ 0 ] else : return None envelope ( tree , pos ) Interval that covers the given interval (i.e. is larger). Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required pos Interval Interval to cover. required Returns: Type Description Optional [ Interval ] Optional[Interval]: The next largest interval covering the current one, if there is one, otherwise None. Source code in mkreports/parser.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def envelope ( tree : IntervalTree , pos : Interval ) -> Optional [ Interval ]: \"\"\" Interval that covers the given interval (i.e. is larger). Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. pos (Interval): Interval to cover. Returns: Optional[Interval]: The next largest interval covering the current one, if there is one, otherwise None. \"\"\" tree_list = list ( tree . envelop ( pos . begin - 1 , pos . end )) if len ( tree_list ) == 0 : return None else : tree_list . sort ( key = lambda x : x . end - x . begin ) return tree_list [ 0 ] get_neighbors ( tree , lineno ) For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Parameters: Name Type Description Default tree IntervalTree required lineno int required Returns: Type Description Optional [ Interval ], Optional [ Interval ], Optional [ Interval ] Interval of statement before the line, covering the current line and the next statement. Source code in mkreports/parser.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def get_neighbors ( tree : IntervalTree , lineno : int ) -> Tuple [ Optional [ Interval ], Optional [ Interval ], Optional [ Interval ]]: \"\"\" For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Args: tree (IntervalTree): lineno (int): Returns: (Optional[Interval], Optional[Interval], Optional[Interval]): Interval of statement before the line, covering the current line and the next statement. \"\"\" return ( closest_before ( tree , lineno ), smallest_overlap ( tree , lineno ), closest_after ( tree , lineno ), ) get_stmt_ranges ( pyfile ) Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Parameters: Name Type Description Default pyfile Path Path to the python file to analyze. required Returns: Name Type Description IntervallTree IntervalTree An object representing the hierarchical intervals of the statements in the file. Source code in mkreports/parser.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def get_stmt_ranges ( pyfile : Path ) -> IntervalTree : \"\"\" Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Args: pyfile (Path): Path to the python file to analyze. Returns: IntervallTree: An object representing the hierarchical intervals of the statements in the file. \"\"\" # first we parse the python file into an AST with pyfile . open ( \"r\" ) as f : file_ast = ast . parse ( f . read ()) inttree = IntervalTree () # now we want to walk along the tree and get the line extent of # all nodes that are statements; as data payload we attach # the parsed nodes for node in ast . walk ( file_ast ): if isinstance ( node , ast . stmt ): if node . lineno is not None and node . end_lineno is not None : inttree . add ( Interval ( begin = node . lineno , end = node . end_lineno + 1 , data = node ) ) return inttree smallest_overlap ( tree , lineno ) Find the closest match that overlaps and is shortests. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional [ Interval ] Optional[Interval]: An interval if there is a statement at the line. Source code in mkreports/parser.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def smallest_overlap ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Find the closest match that overlaps and is shortests. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval if there is a statement at the line. \"\"\" overlap_set = tree . at ( lineno ) if len ( overlap_set ) > 0 : # we take the shortest overlap_list = list ( overlap_set ) overlap_list . sort ( key = lambda x : x . end - x . begin ) return overlap_list [ 0 ] else : return None","title":"parser"},{"location":"Reference/parser/#mkreports.parser.closest_after","text":"Return the closest item strictly before lineno. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional [ Interval ] Optional[Interval]: An interval representing closest statement after the line if there is a statement after. Source code in mkreports/parser.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def closest_after ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval representing closest statement after the line if there is a statement after. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line # rest by difference to current line after_list = [ x for x in tree_list if ( x . begin > lineno )] after_list . sort ( key = lambda x : x . begin - lineno ) if len ( after_list ) > 0 : return after_list [ 0 ] else : return None","title":"closest_after()"},{"location":"Reference/parser/#mkreports.parser.closest_before","text":"Return the closest item strictly before lineno. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional [ Interval ] Optional[Interval]: An interval representing closest statement before the line if there is a statement before. Source code in mkreports/parser.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def closest_before ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Return the closest item strictly before lineno. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval representing closest statement before the line if there is a statement before. \"\"\" tree_list = list ( tree . items ()) # sort by size of element; this will be retained in later sorts tree_list . sort ( key = lambda x : x . end - x . begin ) # here we filter by those that come before and # sort by the difference to the current line before_list = [ x for x in tree_list if ( x . begin < lineno )] before_list . sort ( key = lambda x : lineno - x . begin ) if len ( before_list ) > 0 : return before_list [ 0 ] else : return None","title":"closest_before()"},{"location":"Reference/parser/#mkreports.parser.envelope","text":"Interval that covers the given interval (i.e. is larger). Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required pos Interval Interval to cover. required Returns: Type Description Optional [ Interval ] Optional[Interval]: The next largest interval covering the current one, if there is one, otherwise None. Source code in mkreports/parser.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def envelope ( tree : IntervalTree , pos : Interval ) -> Optional [ Interval ]: \"\"\" Interval that covers the given interval (i.e. is larger). Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. pos (Interval): Interval to cover. Returns: Optional[Interval]: The next largest interval covering the current one, if there is one, otherwise None. \"\"\" tree_list = list ( tree . envelop ( pos . begin - 1 , pos . end )) if len ( tree_list ) == 0 : return None else : tree_list . sort ( key = lambda x : x . end - x . begin ) return tree_list [ 0 ]","title":"envelope()"},{"location":"Reference/parser/#mkreports.parser.get_neighbors","text":"For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Parameters: Name Type Description Default tree IntervalTree required lineno int required Returns: Type Description Optional [ Interval ], Optional [ Interval ], Optional [ Interval ] Interval of statement before the line, covering the current line and the next statement. Source code in mkreports/parser.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def get_neighbors ( tree : IntervalTree , lineno : int ) -> Tuple [ Optional [ Interval ], Optional [ Interval ], Optional [ Interval ]]: \"\"\" For a given lineno, get the current statement (if there is one), as well as the previous and next statements in the tree. Args: tree (IntervalTree): lineno (int): Returns: (Optional[Interval], Optional[Interval], Optional[Interval]): Interval of statement before the line, covering the current line and the next statement. \"\"\" return ( closest_before ( tree , lineno ), smallest_overlap ( tree , lineno ), closest_after ( tree , lineno ), )","title":"get_neighbors()"},{"location":"Reference/parser/#mkreports.parser.get_stmt_ranges","text":"Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Parameters: Name Type Description Default pyfile Path Path to the python file to analyze. required Returns: Name Type Description IntervallTree IntervalTree An object representing the hierarchical intervals of the statements in the file. Source code in mkreports/parser.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def get_stmt_ranges ( pyfile : Path ) -> IntervalTree : \"\"\" Parse the python file and return the ranges of all statements. Here, we only return the range of the statements at the lowest level. This is to make it easier to find the 'previous' statement. The line numbers in the interval tree will be 1-based. Args: pyfile (Path): Path to the python file to analyze. Returns: IntervallTree: An object representing the hierarchical intervals of the statements in the file. \"\"\" # first we parse the python file into an AST with pyfile . open ( \"r\" ) as f : file_ast = ast . parse ( f . read ()) inttree = IntervalTree () # now we want to walk along the tree and get the line extent of # all nodes that are statements; as data payload we attach # the parsed nodes for node in ast . walk ( file_ast ): if isinstance ( node , ast . stmt ): if node . lineno is not None and node . end_lineno is not None : inttree . add ( Interval ( begin = node . lineno , end = node . end_lineno + 1 , data = node ) ) return inttree","title":"get_stmt_ranges()"},{"location":"Reference/parser/#mkreports.parser.smallest_overlap","text":"Find the closest match that overlaps and is shortests. Parameters: Name Type Description Default tree IntervalTree The intervals obtained from get_stmt_ranges function. required lineno int The lineno to use in the file. required Returns: Type Description Optional [ Interval ] Optional[Interval]: An interval if there is a statement at the line. Source code in mkreports/parser.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def smallest_overlap ( tree : IntervalTree , lineno : int ) -> Optional [ Interval ]: \"\"\" Find the closest match that overlaps and is shortests. Args: tree (IntervalTree): The intervals obtained from *get_stmt_ranges* function. lineno (int): The lineno to use in the file. Returns: Optional[Interval]: An interval if there is a statement at the line. \"\"\" overlap_set = tree . at ( lineno ) if len ( overlap_set ) > 0 : # we take the shortest overlap_list = list ( overlap_set ) overlap_list . sort ( key = lambda x : x . end - x . begin ) return overlap_list [ 0 ] else : return None","title":"smallest_overlap()"},{"location":"Reference/report/","text":"Base class for the whole report. This corresponds to a mkdocs project. The class is mainly responsible for creating a mkdocs project if it doesn't exist already and ensuring that the neccessary settings are all included. Report Class representing a report. Source code in mkreports/report.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class Report : \"\"\"Class representing a report.\"\"\" def __init__ ( self , path : Optional [ Union [ str , Path ]] = None , project_root : Optional [ Union [ str , Path ]] = None , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> None : \"\"\" Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the **create** class-method. Args: path (Optional[Union[str, Path]]): Path to the top-level directory of the report. project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" # need to ensure it is of type Path if path is None : path = get_mkreports_dir () self . _path = Path ( path ) . absolute () # first check if the path exists and is not empty and return error if that is not ok if not self . path . exists (): raise ReportNotExistsError ( f \" { self . path } does not exist.\" ) if not self . mkdocs_file . exists () or not self . mkdocs_file . is_file (): raise ReportNotValidError ( f \" { self . mkdocs_file } does not exist\" ) if not self . docs_dir . exists () or not self . docs_dir . is_dir (): raise ReportNotValidError ( f \" { self . docs_dir } does not exist\" ) if not self . index_file . exists () or not self . index_file . is_file (): raise ReportNotValidError ( f \" { self . index_file } does not exist\" ) if project_root is None : root = repo_root () if root is None : self . project_root = Path ( \"/\" ) else : self . project_root = root else : self . project_root = Path ( project_root ) self . md_defaults = md_defaults @property def path ( self ) -> Path : \"\"\" Returns: Path: Path object that is the top-level of the report. \"\"\" return self . _path @property def mkdocs_file ( self ) -> Path : \"\"\" Returns: Path: Location of the mkdocs file. \"\"\" return self . path / \"mkdocs.yml\" @property def docs_dir ( self ) -> Path : \"\"\" Returns: Path: Docs-folder in the report. \"\"\" return self . path / \"docs\" @property def index_file ( self ) -> Path : \"\"\" Returns: Path: Location of the index file. \"\"\" return self . docs_dir / \"index.md\" @property def javascript_path ( self ) -> Path : \"\"\" Returns: Path: Location of the javascript folder. \"\"\" return self . docs_dir / \"javascript\" @property def settings ( self ): return ReportSettings ( self . mkdocs_file ) @classmethod def create ( cls , path : Union [ str , Path ], report_name : str , project_root : Optional [ Union [ str , Path ]] = None , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , settings : Optional [ Mapping [ str , str ]] = default_settings , exist_ok : bool = False , ) -> \"Report\" : \"\"\" Create a new report. Args: path (Union[str, Path]): Top-level folder of the report. report_name (str): Name of the report (mkdocs site-name) project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. settings (Optional[Mapping[str, str]]): Settings of the report. exist_ok (bool): Is it ok if it already exists? Returns: Report: An instance of the class representing the project. \"\"\" path = Path ( path ) # create the directory try : ( path / \"docs\" ) . mkdir ( exist_ok = exist_ok , parents = True ) except FileExistsError : raise ReportExistsError ( f \" { path / 'docs' } already exists.\" ) # index.md created, but done nothing if it exists # if exist_ok=False, the previousalready failed otherwise ( path / \"docs\" / \"index.md\" ) . touch () # only do it if mkdocs_yml does not exist yet mkdocs_file = path / \"mkdocs.yml\" if not mkdocs_file . exists (): # the settings are our serialized yaml # ensure settings is regular dict settings = dict ( settings . items ()) if settings is not None else {} settings [ \"site_name\" ] = report_name with ( path / \"mkdocs.yml\" ) . open ( \"w\" ) as f : yaml . dump ( settings , f , Dumper = yaml . Dumper , default_flow_style = False ) # also create the overrides doc overrides_dir = path / \"overrides\" overrides_dir . mkdir ( exist_ok = True , parents = True ) with ( overrides_dir / \"main.html\" ) . open ( \"w\" ) as f : f . write ( main_html_override ) return cls ( path , project_root = project_root , md_defaults = md_defaults , ) def _add_nav_entry ( self , nav_entry ) -> None : # check that the nav-entry is relative; if absolute, # make it relative to the docs_dir loc = nav_entry . loc if isinstance ( loc , str ): loc = Path ( loc ) if loc . is_absolute (): # type: ignore loc = loc . relative_to ( self . docs_dir ) self . settings . append_nav_entry ( NavEntry ( nav_entry . hierarchy , loc )) def get_nav_entry ( self , path : Path ) -> Optional [ NavEntry ]: \"\"\" Get the NavEntry for a specific page. Args: path (Path): Path to the page, absolute or relative to docs_dir. Returns: The NavEntry if it exists or None. \"\"\" if path . is_absolute (): rel_path = path . relative_to ( self . docs_dir ) else : rel_path = path nav_list = self . settings . nav_list match_entries = [ nav_entry for nav_entry in nav_list if nav_entry . loc == rel_path ] if len ( match_entries ) > 0 : return match_entries [ 0 ] else : return None def page ( self , page_name : Union [ NavEntry , Path , str ], truncate : bool = False , add_bottom : bool = True , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> \"Page\" : \"\"\" Create a page in the report. Args: page_name (Union[NavEntry, Path, str]): Name of the page and path. Using a **NavEntry**, a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. truncate (bool): Should the page be truncated if it exists? Also deletes the *store_path*. add_bottom (bool): Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. Returns: Page: An object representing a new page. \"\"\" nav_entry = normalize_nav_entry ( page_name ) path = nav_entry . loc assert isinstance ( path , Path ) # if the file already exists, just return a 'Page', # else create a new nav-entry and the file and return a 'Page' if ( self . docs_dir / path ) . exists (): if truncate : # delete the existing site ( self . docs_dir / path ) . unlink () ( self . docs_dir / path ) . touch () # we do not need to add en entry into the nav else : # create the file by touching it and create a nav-entry ( self . docs_dir / path ) . parent . mkdir ( exist_ok = True , parents = True ) ( self . docs_dir / path ) . touch () # update the report settings self . _add_nav_entry ( nav_entry ) page = Page ( self . docs_dir / path , report = self , add_bottom = add_bottom , md_defaults = md_defaults , ) if truncate : if page . store_path . exists (): shutil . rmtree ( page . store_path ) return page def insert_page ( self , path_target : Union [ str , Path , NavEntry ], path_source : Path , mode : Literal [ \"S\" , \"T\" , \"ST\" , \"TS\" ] = \"TS\" , ): \"\"\" Insert a page into the report. This function can take an existing page (can also just be a markdown file) and inserts it into the page. Args: path_source (Path): The file to insert. Expected to be a markdown file. path_target (Union[Path, NavEntry]): Path or NavEntry where the page should be inserted. mode (Literal[\"S\", \"T\", \"ST\", \"TS\"]): Insertion mode. If 'S', then only the target is overwritten with the source. If 'T', then the target is left as is, if it exists. For 'ST', the source is prepended, for 'TS', the source is appended to the target. \"\"\" nav_entry = normalize_nav_entry ( path_target ) assert isinstance ( nav_entry . loc , Path ) if mode == \"T\" and not nav_entry . loc . exists (): # force source being used mode = \"S\" target_page = self . page ( path_target ) # initiating entries into the nav merge_pages ( path_source = path_source , path_target = target_page . path , mode = mode ) def __eq__ ( self , other ): if type ( self ) != type ( other ): return False return self . __dict__ == other . __dict__ __init__ ( path = None , project_root = None , md_defaults = None ) Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the create class-method. Parameters: Name Type Description Default path Optional [ Union [ str , Path ]] Path to the top-level directory of the report. None project_root Optional [ Union [ str , Path ]] Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. None md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None Source code in mkreports/report.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def __init__ ( self , path : Optional [ Union [ str , Path ]] = None , project_root : Optional [ Union [ str , Path ]] = None , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> None : \"\"\" Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the **create** class-method. Args: path (Optional[Union[str, Path]]): Path to the top-level directory of the report. project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" # need to ensure it is of type Path if path is None : path = get_mkreports_dir () self . _path = Path ( path ) . absolute () # first check if the path exists and is not empty and return error if that is not ok if not self . path . exists (): raise ReportNotExistsError ( f \" { self . path } does not exist.\" ) if not self . mkdocs_file . exists () or not self . mkdocs_file . is_file (): raise ReportNotValidError ( f \" { self . mkdocs_file } does not exist\" ) if not self . docs_dir . exists () or not self . docs_dir . is_dir (): raise ReportNotValidError ( f \" { self . docs_dir } does not exist\" ) if not self . index_file . exists () or not self . index_file . is_file (): raise ReportNotValidError ( f \" { self . index_file } does not exist\" ) if project_root is None : root = repo_root () if root is None : self . project_root = Path ( \"/\" ) else : self . project_root = root else : self . project_root = Path ( project_root ) self . md_defaults = md_defaults create ( path , report_name , project_root = None , md_defaults = None , settings = default_settings , exist_ok = False ) Create a new report. Parameters: Name Type Description Default path Union [ str , Path ] Top-level folder of the report. required report_name str Name of the report (mkdocs site-name) required project_root Optional [ Union [ str , Path ]] Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. None md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None settings Optional [ Mapping [ str , str ]] Settings of the report. default_settings exist_ok bool Is it ok if it already exists? False Returns: Name Type Description Report 'Report' An instance of the class representing the project. Source code in mkreports/report.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 @classmethod def create ( cls , path : Union [ str , Path ], report_name : str , project_root : Optional [ Union [ str , Path ]] = None , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , settings : Optional [ Mapping [ str , str ]] = default_settings , exist_ok : bool = False , ) -> \"Report\" : \"\"\" Create a new report. Args: path (Union[str, Path]): Top-level folder of the report. report_name (str): Name of the report (mkdocs site-name) project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. settings (Optional[Mapping[str, str]]): Settings of the report. exist_ok (bool): Is it ok if it already exists? Returns: Report: An instance of the class representing the project. \"\"\" path = Path ( path ) # create the directory try : ( path / \"docs\" ) . mkdir ( exist_ok = exist_ok , parents = True ) except FileExistsError : raise ReportExistsError ( f \" { path / 'docs' } already exists.\" ) # index.md created, but done nothing if it exists # if exist_ok=False, the previousalready failed otherwise ( path / \"docs\" / \"index.md\" ) . touch () # only do it if mkdocs_yml does not exist yet mkdocs_file = path / \"mkdocs.yml\" if not mkdocs_file . exists (): # the settings are our serialized yaml # ensure settings is regular dict settings = dict ( settings . items ()) if settings is not None else {} settings [ \"site_name\" ] = report_name with ( path / \"mkdocs.yml\" ) . open ( \"w\" ) as f : yaml . dump ( settings , f , Dumper = yaml . Dumper , default_flow_style = False ) # also create the overrides doc overrides_dir = path / \"overrides\" overrides_dir . mkdir ( exist_ok = True , parents = True ) with ( overrides_dir / \"main.html\" ) . open ( \"w\" ) as f : f . write ( main_html_override ) return cls ( path , project_root = project_root , md_defaults = md_defaults , ) docs_dir () Returns: Name Type Description Path Path Docs-folder in the report. Source code in mkreports/report.py 158 159 160 161 162 163 164 165 @property def docs_dir ( self ) -> Path : \"\"\" Returns: Path: Docs-folder in the report. \"\"\" return self . path / \"docs\" get_nav_entry ( path ) Get the NavEntry for a specific page. Parameters: Name Type Description Default path Path Path to the page, absolute or relative to docs_dir. required Returns: Type Description Optional [ NavEntry ] The NavEntry if it exists or None. Source code in mkreports/report.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def get_nav_entry ( self , path : Path ) -> Optional [ NavEntry ]: \"\"\" Get the NavEntry for a specific page. Args: path (Path): Path to the page, absolute or relative to docs_dir. Returns: The NavEntry if it exists or None. \"\"\" if path . is_absolute (): rel_path = path . relative_to ( self . docs_dir ) else : rel_path = path nav_list = self . settings . nav_list match_entries = [ nav_entry for nav_entry in nav_list if nav_entry . loc == rel_path ] if len ( match_entries ) > 0 : return match_entries [ 0 ] else : return None index_file () Returns: Name Type Description Path Path Location of the index file. Source code in mkreports/report.py 167 168 169 170 171 172 173 174 @property def index_file ( self ) -> Path : \"\"\" Returns: Path: Location of the index file. \"\"\" return self . docs_dir / \"index.md\" insert_page ( path_target , path_source , mode = 'TS' ) Insert a page into the report. This function can take an existing page (can also just be a markdown file) and inserts it into the page. Parameters: Name Type Description Default path_source Path The file to insert. Expected to be a markdown file. required path_target Union [ Path , NavEntry ] Path or NavEntry where the page should be inserted. required mode Literal ['S', 'T', 'ST', 'TS'] Insertion mode. If 'S', then only the target is overwritten with the source. If 'T', then the target is left as is, if it exists. For 'ST', the source is prepended, for 'TS', the source is appended to the target. 'TS' Source code in mkreports/report.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def insert_page ( self , path_target : Union [ str , Path , NavEntry ], path_source : Path , mode : Literal [ \"S\" , \"T\" , \"ST\" , \"TS\" ] = \"TS\" , ): \"\"\" Insert a page into the report. This function can take an existing page (can also just be a markdown file) and inserts it into the page. Args: path_source (Path): The file to insert. Expected to be a markdown file. path_target (Union[Path, NavEntry]): Path or NavEntry where the page should be inserted. mode (Literal[\"S\", \"T\", \"ST\", \"TS\"]): Insertion mode. If 'S', then only the target is overwritten with the source. If 'T', then the target is left as is, if it exists. For 'ST', the source is prepended, for 'TS', the source is appended to the target. \"\"\" nav_entry = normalize_nav_entry ( path_target ) assert isinstance ( nav_entry . loc , Path ) if mode == \"T\" and not nav_entry . loc . exists (): # force source being used mode = \"S\" target_page = self . page ( path_target ) # initiating entries into the nav merge_pages ( path_source = path_source , path_target = target_page . path , mode = mode ) javascript_path () Returns: Name Type Description Path Path Location of the javascript folder. Source code in mkreports/report.py 176 177 178 179 180 181 182 183 @property def javascript_path ( self ) -> Path : \"\"\" Returns: Path: Location of the javascript folder. \"\"\" return self . docs_dir / \"javascript\" mkdocs_file () Returns: Name Type Description Path Path Location of the mkdocs file. Source code in mkreports/report.py 149 150 151 152 153 154 155 156 @property def mkdocs_file ( self ) -> Path : \"\"\" Returns: Path: Location of the mkdocs file. \"\"\" return self . path / \"mkdocs.yml\" page ( page_name , truncate = False , add_bottom = True , md_defaults = None ) Create a page in the report. Parameters: Name Type Description Default page_name Union [ NavEntry , Path , str ] Name of the page and path. Using a NavEntry , a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. required truncate bool Should the page be truncated if it exists? Also deletes the store_path . False add_bottom bool Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. True md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None Returns: Name Type Description Page 'Page' An object representing a new page. Source code in mkreports/report.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def page ( self , page_name : Union [ NavEntry , Path , str ], truncate : bool = False , add_bottom : bool = True , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> \"Page\" : \"\"\" Create a page in the report. Args: page_name (Union[NavEntry, Path, str]): Name of the page and path. Using a **NavEntry**, a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. truncate (bool): Should the page be truncated if it exists? Also deletes the *store_path*. add_bottom (bool): Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. Returns: Page: An object representing a new page. \"\"\" nav_entry = normalize_nav_entry ( page_name ) path = nav_entry . loc assert isinstance ( path , Path ) # if the file already exists, just return a 'Page', # else create a new nav-entry and the file and return a 'Page' if ( self . docs_dir / path ) . exists (): if truncate : # delete the existing site ( self . docs_dir / path ) . unlink () ( self . docs_dir / path ) . touch () # we do not need to add en entry into the nav else : # create the file by touching it and create a nav-entry ( self . docs_dir / path ) . parent . mkdir ( exist_ok = True , parents = True ) ( self . docs_dir / path ) . touch () # update the report settings self . _add_nav_entry ( nav_entry ) page = Page ( self . docs_dir / path , report = self , add_bottom = add_bottom , md_defaults = md_defaults , ) if truncate : if page . store_path . exists (): shutil . rmtree ( page . store_path ) return page path () Returns: Name Type Description Path Path Path object that is the top-level of the report. Source code in mkreports/report.py 141 142 143 144 145 146 147 @property def path ( self ) -> Path : \"\"\" Returns: Path: Path object that is the top-level of the report. \"\"\" return self . _path normalize_nav_entry ( nav_entry ) Normalize a nav entry Ensures that if a string or Path is given, is turned into a NavEntry. Parameters: Name Type Description Default nav_entry Union [ str , Path , NavEntry ] The str, path or nav_entry to use. required Source code in mkreports/report.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def normalize_nav_entry ( nav_entry : Union [ str , Path , NavEntry ]) -> NavEntry : \"\"\" Normalize a nav entry Ensures that if a string or Path is given, is turned into a NavEntry. Args: nav_entry (Union[str, Path, NavEntry]): The str, path or nav_entry to use. Returns: \"\"\" if isinstance ( nav_entry , ( str , Path )): path = Path ( nav_entry ) if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) nav_entry = path_to_nav_entry ( path ) else : path = nav_entry . loc assert isinstance ( path , Path ) if path . suffix != \".md\" : raise ValueError ( f \" { path } needs to have extension '.md'\" ) return nav_entry","title":"report"},{"location":"Reference/report/#mkreports.report.Report","text":"Class representing a report. Source code in mkreports/report.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class Report : \"\"\"Class representing a report.\"\"\" def __init__ ( self , path : Optional [ Union [ str , Path ]] = None , project_root : Optional [ Union [ str , Path ]] = None , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> None : \"\"\" Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the **create** class-method. Args: path (Optional[Union[str, Path]]): Path to the top-level directory of the report. project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" # need to ensure it is of type Path if path is None : path = get_mkreports_dir () self . _path = Path ( path ) . absolute () # first check if the path exists and is not empty and return error if that is not ok if not self . path . exists (): raise ReportNotExistsError ( f \" { self . path } does not exist.\" ) if not self . mkdocs_file . exists () or not self . mkdocs_file . is_file (): raise ReportNotValidError ( f \" { self . mkdocs_file } does not exist\" ) if not self . docs_dir . exists () or not self . docs_dir . is_dir (): raise ReportNotValidError ( f \" { self . docs_dir } does not exist\" ) if not self . index_file . exists () or not self . index_file . is_file (): raise ReportNotValidError ( f \" { self . index_file } does not exist\" ) if project_root is None : root = repo_root () if root is None : self . project_root = Path ( \"/\" ) else : self . project_root = root else : self . project_root = Path ( project_root ) self . md_defaults = md_defaults @property def path ( self ) -> Path : \"\"\" Returns: Path: Path object that is the top-level of the report. \"\"\" return self . _path @property def mkdocs_file ( self ) -> Path : \"\"\" Returns: Path: Location of the mkdocs file. \"\"\" return self . path / \"mkdocs.yml\" @property def docs_dir ( self ) -> Path : \"\"\" Returns: Path: Docs-folder in the report. \"\"\" return self . path / \"docs\" @property def index_file ( self ) -> Path : \"\"\" Returns: Path: Location of the index file. \"\"\" return self . docs_dir / \"index.md\" @property def javascript_path ( self ) -> Path : \"\"\" Returns: Path: Location of the javascript folder. \"\"\" return self . docs_dir / \"javascript\" @property def settings ( self ): return ReportSettings ( self . mkdocs_file ) @classmethod def create ( cls , path : Union [ str , Path ], report_name : str , project_root : Optional [ Union [ str , Path ]] = None , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , settings : Optional [ Mapping [ str , str ]] = default_settings , exist_ok : bool = False , ) -> \"Report\" : \"\"\" Create a new report. Args: path (Union[str, Path]): Top-level folder of the report. report_name (str): Name of the report (mkdocs site-name) project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. settings (Optional[Mapping[str, str]]): Settings of the report. exist_ok (bool): Is it ok if it already exists? Returns: Report: An instance of the class representing the project. \"\"\" path = Path ( path ) # create the directory try : ( path / \"docs\" ) . mkdir ( exist_ok = exist_ok , parents = True ) except FileExistsError : raise ReportExistsError ( f \" { path / 'docs' } already exists.\" ) # index.md created, but done nothing if it exists # if exist_ok=False, the previousalready failed otherwise ( path / \"docs\" / \"index.md\" ) . touch () # only do it if mkdocs_yml does not exist yet mkdocs_file = path / \"mkdocs.yml\" if not mkdocs_file . exists (): # the settings are our serialized yaml # ensure settings is regular dict settings = dict ( settings . items ()) if settings is not None else {} settings [ \"site_name\" ] = report_name with ( path / \"mkdocs.yml\" ) . open ( \"w\" ) as f : yaml . dump ( settings , f , Dumper = yaml . Dumper , default_flow_style = False ) # also create the overrides doc overrides_dir = path / \"overrides\" overrides_dir . mkdir ( exist_ok = True , parents = True ) with ( overrides_dir / \"main.html\" ) . open ( \"w\" ) as f : f . write ( main_html_override ) return cls ( path , project_root = project_root , md_defaults = md_defaults , ) def _add_nav_entry ( self , nav_entry ) -> None : # check that the nav-entry is relative; if absolute, # make it relative to the docs_dir loc = nav_entry . loc if isinstance ( loc , str ): loc = Path ( loc ) if loc . is_absolute (): # type: ignore loc = loc . relative_to ( self . docs_dir ) self . settings . append_nav_entry ( NavEntry ( nav_entry . hierarchy , loc )) def get_nav_entry ( self , path : Path ) -> Optional [ NavEntry ]: \"\"\" Get the NavEntry for a specific page. Args: path (Path): Path to the page, absolute or relative to docs_dir. Returns: The NavEntry if it exists or None. \"\"\" if path . is_absolute (): rel_path = path . relative_to ( self . docs_dir ) else : rel_path = path nav_list = self . settings . nav_list match_entries = [ nav_entry for nav_entry in nav_list if nav_entry . loc == rel_path ] if len ( match_entries ) > 0 : return match_entries [ 0 ] else : return None def page ( self , page_name : Union [ NavEntry , Path , str ], truncate : bool = False , add_bottom : bool = True , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> \"Page\" : \"\"\" Create a page in the report. Args: page_name (Union[NavEntry, Path, str]): Name of the page and path. Using a **NavEntry**, a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. truncate (bool): Should the page be truncated if it exists? Also deletes the *store_path*. add_bottom (bool): Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. Returns: Page: An object representing a new page. \"\"\" nav_entry = normalize_nav_entry ( page_name ) path = nav_entry . loc assert isinstance ( path , Path ) # if the file already exists, just return a 'Page', # else create a new nav-entry and the file and return a 'Page' if ( self . docs_dir / path ) . exists (): if truncate : # delete the existing site ( self . docs_dir / path ) . unlink () ( self . docs_dir / path ) . touch () # we do not need to add en entry into the nav else : # create the file by touching it and create a nav-entry ( self . docs_dir / path ) . parent . mkdir ( exist_ok = True , parents = True ) ( self . docs_dir / path ) . touch () # update the report settings self . _add_nav_entry ( nav_entry ) page = Page ( self . docs_dir / path , report = self , add_bottom = add_bottom , md_defaults = md_defaults , ) if truncate : if page . store_path . exists (): shutil . rmtree ( page . store_path ) return page def insert_page ( self , path_target : Union [ str , Path , NavEntry ], path_source : Path , mode : Literal [ \"S\" , \"T\" , \"ST\" , \"TS\" ] = \"TS\" , ): \"\"\" Insert a page into the report. This function can take an existing page (can also just be a markdown file) and inserts it into the page. Args: path_source (Path): The file to insert. Expected to be a markdown file. path_target (Union[Path, NavEntry]): Path or NavEntry where the page should be inserted. mode (Literal[\"S\", \"T\", \"ST\", \"TS\"]): Insertion mode. If 'S', then only the target is overwritten with the source. If 'T', then the target is left as is, if it exists. For 'ST', the source is prepended, for 'TS', the source is appended to the target. \"\"\" nav_entry = normalize_nav_entry ( path_target ) assert isinstance ( nav_entry . loc , Path ) if mode == \"T\" and not nav_entry . loc . exists (): # force source being used mode = \"S\" target_page = self . page ( path_target ) # initiating entries into the nav merge_pages ( path_source = path_source , path_target = target_page . path , mode = mode ) def __eq__ ( self , other ): if type ( self ) != type ( other ): return False return self . __dict__ == other . __dict__","title":"Report"},{"location":"Reference/report/#mkreports.report.Report.__init__","text":"Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the create class-method. Parameters: Name Type Description Default path Optional [ Union [ str , Path ]] Path to the top-level directory of the report. None project_root Optional [ Union [ str , Path ]] Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. None md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None Source code in mkreports/report.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def __init__ ( self , path : Optional [ Union [ str , Path ]] = None , project_root : Optional [ Union [ str , Path ]] = None , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> None : \"\"\" Initialize the report object. This relies on the report folder already existing, including necessary files for mkdocs. If this is not the case, use the **create** class-method. Args: path (Optional[Union[str, Path]]): Path to the top-level directory of the report. project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" # need to ensure it is of type Path if path is None : path = get_mkreports_dir () self . _path = Path ( path ) . absolute () # first check if the path exists and is not empty and return error if that is not ok if not self . path . exists (): raise ReportNotExistsError ( f \" { self . path } does not exist.\" ) if not self . mkdocs_file . exists () or not self . mkdocs_file . is_file (): raise ReportNotValidError ( f \" { self . mkdocs_file } does not exist\" ) if not self . docs_dir . exists () or not self . docs_dir . is_dir (): raise ReportNotValidError ( f \" { self . docs_dir } does not exist\" ) if not self . index_file . exists () or not self . index_file . is_file (): raise ReportNotValidError ( f \" { self . index_file } does not exist\" ) if project_root is None : root = repo_root () if root is None : self . project_root = Path ( \"/\" ) else : self . project_root = root else : self . project_root = Path ( project_root ) self . md_defaults = md_defaults","title":"__init__()"},{"location":"Reference/report/#mkreports.report.Report.create","text":"Create a new report. Parameters: Name Type Description Default path Union [ str , Path ] Top-level folder of the report. required report_name str Name of the report (mkdocs site-name) required project_root Optional [ Union [ str , Path ]] Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. None md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None settings Optional [ Mapping [ str , str ]] Settings of the report. default_settings exist_ok bool Is it ok if it already exists? False Returns: Name Type Description Report 'Report' An instance of the class representing the project. Source code in mkreports/report.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 @classmethod def create ( cls , path : Union [ str , Path ], report_name : str , project_root : Optional [ Union [ str , Path ]] = None , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , settings : Optional [ Mapping [ str , str ]] = default_settings , exist_ok : bool = False , ) -> \"Report\" : \"\"\" Create a new report. Args: path (Union[str, Path]): Top-level folder of the report. report_name (str): Name of the report (mkdocs site-name) project_root (Optional[Union[str, Path]]): Directory that is the root of the project. If None, tries to use the root of the git-repository if there is one. Otherwise uses the root of the file-system. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. settings (Optional[Mapping[str, str]]): Settings of the report. exist_ok (bool): Is it ok if it already exists? Returns: Report: An instance of the class representing the project. \"\"\" path = Path ( path ) # create the directory try : ( path / \"docs\" ) . mkdir ( exist_ok = exist_ok , parents = True ) except FileExistsError : raise ReportExistsError ( f \" { path / 'docs' } already exists.\" ) # index.md created, but done nothing if it exists # if exist_ok=False, the previousalready failed otherwise ( path / \"docs\" / \"index.md\" ) . touch () # only do it if mkdocs_yml does not exist yet mkdocs_file = path / \"mkdocs.yml\" if not mkdocs_file . exists (): # the settings are our serialized yaml # ensure settings is regular dict settings = dict ( settings . items ()) if settings is not None else {} settings [ \"site_name\" ] = report_name with ( path / \"mkdocs.yml\" ) . open ( \"w\" ) as f : yaml . dump ( settings , f , Dumper = yaml . Dumper , default_flow_style = False ) # also create the overrides doc overrides_dir = path / \"overrides\" overrides_dir . mkdir ( exist_ok = True , parents = True ) with ( overrides_dir / \"main.html\" ) . open ( \"w\" ) as f : f . write ( main_html_override ) return cls ( path , project_root = project_root , md_defaults = md_defaults , )","title":"create()"},{"location":"Reference/report/#mkreports.report.Report.docs_dir","text":"Returns: Name Type Description Path Path Docs-folder in the report. Source code in mkreports/report.py 158 159 160 161 162 163 164 165 @property def docs_dir ( self ) -> Path : \"\"\" Returns: Path: Docs-folder in the report. \"\"\" return self . path / \"docs\"","title":"docs_dir()"},{"location":"Reference/report/#mkreports.report.Report.get_nav_entry","text":"Get the NavEntry for a specific page. Parameters: Name Type Description Default path Path Path to the page, absolute or relative to docs_dir. required Returns: Type Description Optional [ NavEntry ] The NavEntry if it exists or None. Source code in mkreports/report.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 def get_nav_entry ( self , path : Path ) -> Optional [ NavEntry ]: \"\"\" Get the NavEntry for a specific page. Args: path (Path): Path to the page, absolute or relative to docs_dir. Returns: The NavEntry if it exists or None. \"\"\" if path . is_absolute (): rel_path = path . relative_to ( self . docs_dir ) else : rel_path = path nav_list = self . settings . nav_list match_entries = [ nav_entry for nav_entry in nav_list if nav_entry . loc == rel_path ] if len ( match_entries ) > 0 : return match_entries [ 0 ] else : return None","title":"get_nav_entry()"},{"location":"Reference/report/#mkreports.report.Report.index_file","text":"Returns: Name Type Description Path Path Location of the index file. Source code in mkreports/report.py 167 168 169 170 171 172 173 174 @property def index_file ( self ) -> Path : \"\"\" Returns: Path: Location of the index file. \"\"\" return self . docs_dir / \"index.md\"","title":"index_file()"},{"location":"Reference/report/#mkreports.report.Report.insert_page","text":"Insert a page into the report. This function can take an existing page (can also just be a markdown file) and inserts it into the page. Parameters: Name Type Description Default path_source Path The file to insert. Expected to be a markdown file. required path_target Union [ Path , NavEntry ] Path or NavEntry where the page should be inserted. required mode Literal ['S', 'T', 'ST', 'TS'] Insertion mode. If 'S', then only the target is overwritten with the source. If 'T', then the target is left as is, if it exists. For 'ST', the source is prepended, for 'TS', the source is appended to the target. 'TS' Source code in mkreports/report.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 def insert_page ( self , path_target : Union [ str , Path , NavEntry ], path_source : Path , mode : Literal [ \"S\" , \"T\" , \"ST\" , \"TS\" ] = \"TS\" , ): \"\"\" Insert a page into the report. This function can take an existing page (can also just be a markdown file) and inserts it into the page. Args: path_source (Path): The file to insert. Expected to be a markdown file. path_target (Union[Path, NavEntry]): Path or NavEntry where the page should be inserted. mode (Literal[\"S\", \"T\", \"ST\", \"TS\"]): Insertion mode. If 'S', then only the target is overwritten with the source. If 'T', then the target is left as is, if it exists. For 'ST', the source is prepended, for 'TS', the source is appended to the target. \"\"\" nav_entry = normalize_nav_entry ( path_target ) assert isinstance ( nav_entry . loc , Path ) if mode == \"T\" and not nav_entry . loc . exists (): # force source being used mode = \"S\" target_page = self . page ( path_target ) # initiating entries into the nav merge_pages ( path_source = path_source , path_target = target_page . path , mode = mode )","title":"insert_page()"},{"location":"Reference/report/#mkreports.report.Report.javascript_path","text":"Returns: Name Type Description Path Path Location of the javascript folder. Source code in mkreports/report.py 176 177 178 179 180 181 182 183 @property def javascript_path ( self ) -> Path : \"\"\" Returns: Path: Location of the javascript folder. \"\"\" return self . docs_dir / \"javascript\"","title":"javascript_path()"},{"location":"Reference/report/#mkreports.report.Report.mkdocs_file","text":"Returns: Name Type Description Path Path Location of the mkdocs file. Source code in mkreports/report.py 149 150 151 152 153 154 155 156 @property def mkdocs_file ( self ) -> Path : \"\"\" Returns: Path: Location of the mkdocs file. \"\"\" return self . path / \"mkdocs.yml\"","title":"mkdocs_file()"},{"location":"Reference/report/#mkreports.report.Report.page","text":"Create a page in the report. Parameters: Name Type Description Default page_name Union [ NavEntry , Path , str ] Name of the page and path. Using a NavEntry , a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. required truncate bool Should the page be truncated if it exists? Also deletes the store_path . False add_bottom bool Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. True md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None Returns: Name Type Description Page 'Page' An object representing a new page. Source code in mkreports/report.py 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def page ( self , page_name : Union [ NavEntry , Path , str ], truncate : bool = False , add_bottom : bool = True , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ) -> \"Page\" : \"\"\" Create a page in the report. Args: page_name (Union[NavEntry, Path, str]): Name of the page and path. Using a **NavEntry**, a custom nav-entry and path can be specified. The path is always relative to the report-docs directory. truncate (bool): Should the page be truncated if it exists? Also deletes the *store_path*. add_bottom (bool): Should new entries be added at the bottom or at the top of the page. Top of the page is used for IPython. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. Returns: Page: An object representing a new page. \"\"\" nav_entry = normalize_nav_entry ( page_name ) path = nav_entry . loc assert isinstance ( path , Path ) # if the file already exists, just return a 'Page', # else create a new nav-entry and the file and return a 'Page' if ( self . docs_dir / path ) . exists (): if truncate : # delete the existing site ( self . docs_dir / path ) . unlink () ( self . docs_dir / path ) . touch () # we do not need to add en entry into the nav else : # create the file by touching it and create a nav-entry ( self . docs_dir / path ) . parent . mkdir ( exist_ok = True , parents = True ) ( self . docs_dir / path ) . touch () # update the report settings self . _add_nav_entry ( nav_entry ) page = Page ( self . docs_dir / path , report = self , add_bottom = add_bottom , md_defaults = md_defaults , ) if truncate : if page . store_path . exists (): shutil . rmtree ( page . store_path ) return page","title":"page()"},{"location":"Reference/report/#mkreports.report.Report.path","text":"Returns: Name Type Description Path Path Path object that is the top-level of the report. Source code in mkreports/report.py 141 142 143 144 145 146 147 @property def path ( self ) -> Path : \"\"\" Returns: Path: Path object that is the top-level of the report. \"\"\" return self . _path","title":"path()"},{"location":"Reference/report/#mkreports.report.normalize_nav_entry","text":"Normalize a nav entry Ensures that if a string or Path is given, is turned into a NavEntry. Parameters: Name Type Description Default nav_entry Union [ str , Path , NavEntry ] The str, path or nav_entry to use. required Source code in mkreports/report.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def normalize_nav_entry ( nav_entry : Union [ str , Path , NavEntry ]) -> NavEntry : \"\"\" Normalize a nav entry Ensures that if a string or Path is given, is turned into a NavEntry. Args: nav_entry (Union[str, Path, NavEntry]): The str, path or nav_entry to use. Returns: \"\"\" if isinstance ( nav_entry , ( str , Path )): path = Path ( nav_entry ) if path . suffix == \"\" : path = path . with_suffix ( \".md\" ) nav_entry = path_to_nav_entry ( path ) else : path = nav_entry . loc assert isinstance ( path , Path ) if path . suffix != \".md\" : raise ValueError ( f \" { path } needs to have extension '.md'\" ) return nav_entry","title":"normalize_nav_entry()"},{"location":"Reference/settings/","text":"NavEntry Bases: NamedTuple Source code in mkreports/settings.py 15 16 17 18 19 20 21 22 23 24 25 class NavEntry ( NamedTuple ): \"\"\" An entry in the navigation tab. Args: hierarchy (Sequence[str]): List of navigation entries. file (Path): Path to the page, relative to report docs folder. \"\"\" hierarchy : Sequence [ str ] loc : Union [ Path , str ] ReportSettings Bases: MutableMapping Source code in mkreports/settings.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class ReportSettings ( MutableMapping ): def __init__ ( self , file : Path ): self . _file = file self . _dict = load_yaml ( file ) def __getitem__ ( self , key : Any ) -> Any : return self . _dict [ key ] def __setitem__ ( self , key : Any , value : Any ): \"\"\"Assign key to value, but also save to yaml-file.\"\"\" self . _dict [ key ] = value save_yaml ( self . _dict , self . _file ) def __delitem__ ( self , key : Any ): del self . _dict [ key ] def __iter__ ( self ): return self . _dict . __iter__ () def __len__ ( self ): return len ( self . _dict ) @property def nav_list ( self ) -> List [ NavEntry ]: return mkdocs_to_navlist ( self . _dict [ \"nav\" ]) @nav_list . setter def nav_list ( self , nav_list : List [ NavEntry ]): self [ \"nav\" ] = navlist_to_mkdocs ( nav_list ) def append_nav_entry ( self , nav_entry : Union [ Path , NavEntry ], nav_pref : Literal [ \"S\" , \"T\" ] = \"T\" , ) -> None : if isinstance ( nav_entry , Path ): nav_entry = path_to_nav_entry ( nav_entry ) self . nav_list = _merge_nav_lists ([ nav_entry ], self . nav_list , nav_pref = nav_pref ) @property def dict ( self ): return self . _dict @dict . setter def dict ( self , value ): self . _dict = value save_yaml ( self . _dict , self . _file ) def merge ( self , source : Union [ Dict [ str , Any ], \"ReportSettings\" ], nav_pref : Literal [ \"S\" , \"T\" ] = \"T\" , ): if isinstance ( source , self . __class__ ): source = source . _dict # make a copy so we can manipulate it source = deepcopy ( source ) source_nav = source . get ( \"nav\" , None ) if \"nav\" in source : del source [ \"nav\" ] # now we want to merge the content; but nav items have to be # treated differently merged_dict = merge_settings ( self . _dict , source ) if source_nav is not None : # now we merge the navs; for this we access them as lists nav_list_target = self . nav_list nav_list_source = mkdocs_to_navlist ( source_nav ) combined_nav = _merge_nav_lists ( nav_list_source = nav_list_source , nav_list_target = nav_list_target , nav_pref = nav_pref , ) merged_dict [ \"nav\" ] = combined_nav self . dict = merged_dict __setitem__ ( key , value ) Assign key to value, but also save to yaml-file. Source code in mkreports/settings.py 226 227 228 229 def __setitem__ ( self , key : Any , value : Any ): \"\"\"Assign key to value, but also save to yaml-file.\"\"\" self . _dict [ key ] = value save_yaml ( self . _dict , self . _file ) add_nav_entry ( mkdocs_settings , nav_entry ) Add an additional entry to the Nav in mkdocs.yml Parameters: Name Type Description Default mkdocs_settings The mkdocs settings to update. required nav_entry NavEntry The NavEntry to add required Returns: Type Description Any The updated mkdocs_settings Source code in mkreports/settings.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def add_nav_entry ( mkdocs_settings , nav_entry : NavEntry ) -> Any : \"\"\" Add an additional entry to the Nav in mkdocs.yml Args: mkdocs_settings (): The mkdocs settings to update. nav_entry (NavEntry): The NavEntry to add Returns: The updated mkdocs_settings \"\"\" mkdocs_settings = deepcopy ( mkdocs_settings ) nav = mkdocs_to_navlist ( mkdocs_settings [ \"nav\" ]) + [ nav_entry ] # we need to deduplicate nav = list ( unique_everseen ( nav )) mkdocs_nav = navlist_to_mkdocs ( nav ) mkdocs_settings [ \"nav\" ] = mkdocs_nav return mkdocs_settings load_yaml ( file ) Load a yaml file, return empty dict if not exists. Parameters: Name Type Description Default file Path File to load required Returns: Type Description Any The value in the file, empty dict otherwise. Source code in mkreports/settings.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def load_yaml ( file : Path ) -> Any : \"\"\" Load a yaml file, return empty dict if not exists. Args: file (Path): File to load Returns: The value in the file, empty dict otherwise. \"\"\" if file . exists (): with file . open ( \"r\" ) as f : res = yaml . load ( f , Loader = yaml . Loader ) else : res = {} return res mkdocs_to_navlist ( mkdocs_nav ) Convert an mkdocs nav to a list of NavEntry. Parameters: Name Type Description Default mkdocs_nav MkdocsNav A python representation of the nav-entry in the mkdocs.yml file. required Source code in mkreports/settings.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def mkdocs_to_navlist ( mkdocs_nav : MkdocsNav ) -> NavList : \"\"\" Convert an mkdocs nav to a list of NavEntry. Args: mkdocs_nav: A python representation of the nav-entry in the mkdocs.yml file. \"\"\" res = [] for entry in mkdocs_nav : if isinstance ( entry , str ): res . append ( NavEntry ([], Path ( entry ))) elif isinstance ( entry , Mapping ): key , val = _check_length_one ( entry ) if isinstance ( val , str ): res . append ( NavEntry ([ key ], Path ( val ))) elif isinstance ( val , List ): res = res + [ NavEntry (( key ,) + tuple ( h ), p ) for ( h , p ) in mkdocs_to_navlist ( val ) ] else : raise Exception ( \"Not expected type\" ) else : raise Exception ( \"Not expected type\" ) return res navlist_to_mkdocs ( nav_list ) Convert a list of nav-entries into mkdocs format. Parameters: Name Type Description Default nav Nav The list of NavEntry to convert to mkdocs.yml format required Returns: Type Description MkdocsNav Python object of the mkdocs.yml nav entry. Source code in mkreports/settings.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def navlist_to_mkdocs ( nav_list : NavList ) -> MkdocsNav : \"\"\" Convert a list of nav-entries into mkdocs format. Args: nav (Nav): The list of NavEntry to convert to mkdocs.yml format Returns: Python object of the mkdocs.yml nav entry. \"\"\" split_nokey , split_keys = split_nav ( nav_list ) res : MkdocsNav = [ str ( p ) for p in split_nokey ] for key , val in split_keys . items (): mkdocs_for_key = navlist_to_mkdocs ( val ) # if it is a list of length 1 with a string, treat it special if len ( mkdocs_for_key ) == 1 and isinstance ( mkdocs_for_key [ 0 ], str ): res . append ({ key : mkdocs_for_key [ 0 ]}) else : res . append ({ key : mkdocs_for_key }) return res path_to_nav_entry ( path ) Turn a file path into a NavEntry. The path is split, each part of the path used as an element of the hierarchy. Snake-case are split into words with first letters capitalized. Parameters: Name Type Description Default path Path The path relative to the report docs folder to turn into a nav-entry. required Returns: Name Type Description NavEntry NavEntry The NavEntry object representing the path and the hierarchy of navigation entries. Source code in mkreports/settings.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def path_to_nav_entry ( path : Path ) -> NavEntry : \"\"\" Turn a file path into a NavEntry. The path is split, each part of the path used as an element of the hierarchy. Snake-case are split into words with first letters capitalized. Args: path (Path): The path relative to the report docs folder to turn into a nav-entry. Returns: NavEntry: The NavEntry object representing the path and the hierarchy of navigation entries. \"\"\" return NavEntry ( tuple ( [ snake_to_text ( x ) for x in path . parent . parts ] + [ snake_to_text ( path . stem )] ), path , ) save_yaml ( obj , file ) Save object to yaml file. Parameters: Name Type Description Default obj Any The object to save. required file Path Filename to save it into. required Source code in mkreports/settings.py 184 185 186 187 188 189 190 191 192 193 def save_yaml ( obj : Any , file : Path ) -> None : \"\"\" Save object to yaml file. Args: obj (Any): The object to save. file (Path): Filename to save it into. \"\"\" with file . open ( \"w\" ) as f : yaml . dump ( obj , f , default_flow_style = False ) split_nav ( x ) Split the navigation entry into top level list of items and dict of Navs. Given a nav-entry, each top-level item that is not a hierarchy itself is added to the return list. Every hierarchy will have its top level removed and entered into a dict, with the top-level hierarchy name as the key and the sub-nav as the value. Parameters: Name Type Description Default x Nav The list of NavEntry to process required Returns: Type Description Tuple [ List [ str ], Dict [ str , NavList ]] Tuple[List[str], Dict[str, Nav]]: Structure as explained above. Source code in mkreports/settings.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def split_nav ( x : NavList ) -> Tuple [ List [ str ], Dict [ str , NavList ]]: \"\"\" Split the navigation entry into top level list of items and dict of Navs. Given a nav-entry, each top-level item that is not a hierarchy itself is added to the return list. Every hierarchy will have its top level removed and entered into a dict, with the top-level hierarchy name as the key and the sub-nav as the value. Args: x (Nav): The list of NavEntry to process Returns: Tuple[List[str], Dict[str, Nav]]: Structure as explained above. \"\"\" res_nav = defaultdict ( list ) res_list = [] for ( h , p ) in x : if len ( h ) == 0 : res_list . append ( p ) else : res_nav [ h [ 0 ]] . append (( h [ 1 :], p )) return ( res_list , res_nav )","title":"settings"},{"location":"Reference/settings/#mkreports.settings.NavEntry","text":"Bases: NamedTuple Source code in mkreports/settings.py 15 16 17 18 19 20 21 22 23 24 25 class NavEntry ( NamedTuple ): \"\"\" An entry in the navigation tab. Args: hierarchy (Sequence[str]): List of navigation entries. file (Path): Path to the page, relative to report docs folder. \"\"\" hierarchy : Sequence [ str ] loc : Union [ Path , str ]","title":"NavEntry"},{"location":"Reference/settings/#mkreports.settings.ReportSettings","text":"Bases: MutableMapping Source code in mkreports/settings.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class ReportSettings ( MutableMapping ): def __init__ ( self , file : Path ): self . _file = file self . _dict = load_yaml ( file ) def __getitem__ ( self , key : Any ) -> Any : return self . _dict [ key ] def __setitem__ ( self , key : Any , value : Any ): \"\"\"Assign key to value, but also save to yaml-file.\"\"\" self . _dict [ key ] = value save_yaml ( self . _dict , self . _file ) def __delitem__ ( self , key : Any ): del self . _dict [ key ] def __iter__ ( self ): return self . _dict . __iter__ () def __len__ ( self ): return len ( self . _dict ) @property def nav_list ( self ) -> List [ NavEntry ]: return mkdocs_to_navlist ( self . _dict [ \"nav\" ]) @nav_list . setter def nav_list ( self , nav_list : List [ NavEntry ]): self [ \"nav\" ] = navlist_to_mkdocs ( nav_list ) def append_nav_entry ( self , nav_entry : Union [ Path , NavEntry ], nav_pref : Literal [ \"S\" , \"T\" ] = \"T\" , ) -> None : if isinstance ( nav_entry , Path ): nav_entry = path_to_nav_entry ( nav_entry ) self . nav_list = _merge_nav_lists ([ nav_entry ], self . nav_list , nav_pref = nav_pref ) @property def dict ( self ): return self . _dict @dict . setter def dict ( self , value ): self . _dict = value save_yaml ( self . _dict , self . _file ) def merge ( self , source : Union [ Dict [ str , Any ], \"ReportSettings\" ], nav_pref : Literal [ \"S\" , \"T\" ] = \"T\" , ): if isinstance ( source , self . __class__ ): source = source . _dict # make a copy so we can manipulate it source = deepcopy ( source ) source_nav = source . get ( \"nav\" , None ) if \"nav\" in source : del source [ \"nav\" ] # now we want to merge the content; but nav items have to be # treated differently merged_dict = merge_settings ( self . _dict , source ) if source_nav is not None : # now we merge the navs; for this we access them as lists nav_list_target = self . nav_list nav_list_source = mkdocs_to_navlist ( source_nav ) combined_nav = _merge_nav_lists ( nav_list_source = nav_list_source , nav_list_target = nav_list_target , nav_pref = nav_pref , ) merged_dict [ \"nav\" ] = combined_nav self . dict = merged_dict","title":"ReportSettings"},{"location":"Reference/settings/#mkreports.settings.ReportSettings.__setitem__","text":"Assign key to value, but also save to yaml-file. Source code in mkreports/settings.py 226 227 228 229 def __setitem__ ( self , key : Any , value : Any ): \"\"\"Assign key to value, but also save to yaml-file.\"\"\" self . _dict [ key ] = value save_yaml ( self . _dict , self . _file )","title":"__setitem__()"},{"location":"Reference/settings/#mkreports.settings.add_nav_entry","text":"Add an additional entry to the Nav in mkdocs.yml Parameters: Name Type Description Default mkdocs_settings The mkdocs settings to update. required nav_entry NavEntry The NavEntry to add required Returns: Type Description Any The updated mkdocs_settings Source code in mkreports/settings.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def add_nav_entry ( mkdocs_settings , nav_entry : NavEntry ) -> Any : \"\"\" Add an additional entry to the Nav in mkdocs.yml Args: mkdocs_settings (): The mkdocs settings to update. nav_entry (NavEntry): The NavEntry to add Returns: The updated mkdocs_settings \"\"\" mkdocs_settings = deepcopy ( mkdocs_settings ) nav = mkdocs_to_navlist ( mkdocs_settings [ \"nav\" ]) + [ nav_entry ] # we need to deduplicate nav = list ( unique_everseen ( nav )) mkdocs_nav = navlist_to_mkdocs ( nav ) mkdocs_settings [ \"nav\" ] = mkdocs_nav return mkdocs_settings","title":"add_nav_entry()"},{"location":"Reference/settings/#mkreports.settings.load_yaml","text":"Load a yaml file, return empty dict if not exists. Parameters: Name Type Description Default file Path File to load required Returns: Type Description Any The value in the file, empty dict otherwise. Source code in mkreports/settings.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def load_yaml ( file : Path ) -> Any : \"\"\" Load a yaml file, return empty dict if not exists. Args: file (Path): File to load Returns: The value in the file, empty dict otherwise. \"\"\" if file . exists (): with file . open ( \"r\" ) as f : res = yaml . load ( f , Loader = yaml . Loader ) else : res = {} return res","title":"load_yaml()"},{"location":"Reference/settings/#mkreports.settings.mkdocs_to_navlist","text":"Convert an mkdocs nav to a list of NavEntry. Parameters: Name Type Description Default mkdocs_nav MkdocsNav A python representation of the nav-entry in the mkdocs.yml file. required Source code in mkreports/settings.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def mkdocs_to_navlist ( mkdocs_nav : MkdocsNav ) -> NavList : \"\"\" Convert an mkdocs nav to a list of NavEntry. Args: mkdocs_nav: A python representation of the nav-entry in the mkdocs.yml file. \"\"\" res = [] for entry in mkdocs_nav : if isinstance ( entry , str ): res . append ( NavEntry ([], Path ( entry ))) elif isinstance ( entry , Mapping ): key , val = _check_length_one ( entry ) if isinstance ( val , str ): res . append ( NavEntry ([ key ], Path ( val ))) elif isinstance ( val , List ): res = res + [ NavEntry (( key ,) + tuple ( h ), p ) for ( h , p ) in mkdocs_to_navlist ( val ) ] else : raise Exception ( \"Not expected type\" ) else : raise Exception ( \"Not expected type\" ) return res","title":"mkdocs_to_navlist()"},{"location":"Reference/settings/#mkreports.settings.navlist_to_mkdocs","text":"Convert a list of nav-entries into mkdocs format. Parameters: Name Type Description Default nav Nav The list of NavEntry to convert to mkdocs.yml format required Returns: Type Description MkdocsNav Python object of the mkdocs.yml nav entry. Source code in mkreports/settings.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def navlist_to_mkdocs ( nav_list : NavList ) -> MkdocsNav : \"\"\" Convert a list of nav-entries into mkdocs format. Args: nav (Nav): The list of NavEntry to convert to mkdocs.yml format Returns: Python object of the mkdocs.yml nav entry. \"\"\" split_nokey , split_keys = split_nav ( nav_list ) res : MkdocsNav = [ str ( p ) for p in split_nokey ] for key , val in split_keys . items (): mkdocs_for_key = navlist_to_mkdocs ( val ) # if it is a list of length 1 with a string, treat it special if len ( mkdocs_for_key ) == 1 and isinstance ( mkdocs_for_key [ 0 ], str ): res . append ({ key : mkdocs_for_key [ 0 ]}) else : res . append ({ key : mkdocs_for_key }) return res","title":"navlist_to_mkdocs()"},{"location":"Reference/settings/#mkreports.settings.path_to_nav_entry","text":"Turn a file path into a NavEntry. The path is split, each part of the path used as an element of the hierarchy. Snake-case are split into words with first letters capitalized. Parameters: Name Type Description Default path Path The path relative to the report docs folder to turn into a nav-entry. required Returns: Name Type Description NavEntry NavEntry The NavEntry object representing the path and the hierarchy of navigation entries. Source code in mkreports/settings.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def path_to_nav_entry ( path : Path ) -> NavEntry : \"\"\" Turn a file path into a NavEntry. The path is split, each part of the path used as an element of the hierarchy. Snake-case are split into words with first letters capitalized. Args: path (Path): The path relative to the report docs folder to turn into a nav-entry. Returns: NavEntry: The NavEntry object representing the path and the hierarchy of navigation entries. \"\"\" return NavEntry ( tuple ( [ snake_to_text ( x ) for x in path . parent . parts ] + [ snake_to_text ( path . stem )] ), path , )","title":"path_to_nav_entry()"},{"location":"Reference/settings/#mkreports.settings.save_yaml","text":"Save object to yaml file. Parameters: Name Type Description Default obj Any The object to save. required file Path Filename to save it into. required Source code in mkreports/settings.py 184 185 186 187 188 189 190 191 192 193 def save_yaml ( obj : Any , file : Path ) -> None : \"\"\" Save object to yaml file. Args: obj (Any): The object to save. file (Path): Filename to save it into. \"\"\" with file . open ( \"w\" ) as f : yaml . dump ( obj , f , default_flow_style = False )","title":"save_yaml()"},{"location":"Reference/settings/#mkreports.settings.split_nav","text":"Split the navigation entry into top level list of items and dict of Navs. Given a nav-entry, each top-level item that is not a hierarchy itself is added to the return list. Every hierarchy will have its top level removed and entered into a dict, with the top-level hierarchy name as the key and the sub-nav as the value. Parameters: Name Type Description Default x Nav The list of NavEntry to process required Returns: Type Description Tuple [ List [ str ], Dict [ str , NavList ]] Tuple[List[str], Dict[str, Nav]]: Structure as explained above. Source code in mkreports/settings.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def split_nav ( x : NavList ) -> Tuple [ List [ str ], Dict [ str , NavList ]]: \"\"\" Split the navigation entry into top level list of items and dict of Navs. Given a nav-entry, each top-level item that is not a hierarchy itself is added to the return list. Every hierarchy will have its top level removed and entered into a dict, with the top-level hierarchy name as the key and the sub-nav as the value. Args: x (Nav): The list of NavEntry to process Returns: Tuple[List[str], Dict[str, Nav]]: Structure as explained above. \"\"\" res_nav = defaultdict ( list ) res_list = [] for ( h , p ) in x : if len ( h ) == 0 : res_list . append ( p ) else : res_nav [ h [ 0 ]] . append (( h [ 1 :], p )) return ( res_list , res_nav )","title":"split_nav()"},{"location":"Reference/tracker/","text":"CodeBlock Source code in mkreports/tracker.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @dataclass class CodeBlock : \"\"\" Structure representing information about a block of code. Args: filename (str): The name of the file with the code. co_name (str): Name of the code block line_start (int): Number of the line where the code block starts. line_end (int): Number of the line where the code block ends. \"\"\" filename : str co_name : str line_start : int line_end : int def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : \"\"\" Return a MdObj representing the code in the block. Args: relative_to (Optional[Path]): The path relative to which the title should be. name_only (bool): Should only the name of the code-file be used. Returns: Code: Code object with the code represented by the code block. \"\"\" code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , ) md_code ( relative_to = None , name_only = False ) Return a MdObj representing the code in the block. Parameters: Name Type Description Default relative_to Optional [ Path ] The path relative to which the title should be. None name_only bool Should only the name of the code-file be used. False Returns: Name Type Description Code Code Code object with the code represented by the code block. Source code in mkreports/tracker.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : \"\"\" Return a MdObj representing the code in the block. Args: relative_to (Optional[Path]): The path relative to which the title should be. name_only (bool): Should only the name of the code-file be used. Returns: Code: Code object with the code represented by the code block. \"\"\" code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , ) SimpleTracker Bases: BaseTracker Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. Source code in mkreports/tracker.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 class SimpleTracker ( BaseTracker ): \"\"\" Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. \"\"\" def __init__ ( self ): \"\"\"Initialize the tracker.\"\"\" self . _active = False self . line_start = None self . line_end = None self . co_name = None def start ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Start the tracker. Args: frame_info (inspect.FrameInfo): A FrameInfo object of where the tracking starts. \"\"\" if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True def stop ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Stop the tracker. Args: frame_info (inspect.FrameInfo): FraneInfo where the tracking ends. \"\"\" if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False def code ( self ) -> List [ CodeBlock ]: \"\"\" Return the tracked code. Returns: List[CodeBlock]: List of code blocks. Here, the list is only of length 1. \"\"\" if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ] @property def active ( self ) -> bool : \"\"\" Returns: bool: Is the tracker currently active? \"\"\" return self . _active __init__ () Initialize the tracker. Source code in mkreports/tracker.py 126 127 128 129 130 131 def __init__ ( self ): \"\"\"Initialize the tracker.\"\"\" self . _active = False self . line_start = None self . line_end = None self . co_name = None active () Returns: Name Type Description bool bool Is the tracker currently active? Source code in mkreports/tracker.py 190 191 192 193 194 195 196 197 198 @property def active ( self ) -> bool : \"\"\" Returns: bool: Is the tracker currently active? \"\"\" return self . _active code () Return the tracked code. Returns: Type Description List [ CodeBlock ] List[CodeBlock]: List of code blocks. Here, the list is only of length 1. Source code in mkreports/tracker.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def code ( self ) -> List [ CodeBlock ]: \"\"\" Return the tracked code. Returns: List[CodeBlock]: List of code blocks. Here, the list is only of length 1. \"\"\" if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ] start ( frame_info ) Start the tracker. Parameters: Name Type Description Default frame_info inspect . FrameInfo A FrameInfo object of where the tracking starts. required Source code in mkreports/tracker.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def start ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Start the tracker. Args: frame_info (inspect.FrameInfo): A FrameInfo object of where the tracking starts. \"\"\" if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True stop ( frame_info ) Stop the tracker. Parameters: Name Type Description Default frame_info inspect . FrameInfo FraneInfo where the tracking ends. required Source code in mkreports/tracker.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def stop ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Stop the tracker. Args: frame_info (inspect.FrameInfo): FraneInfo where the tracking ends. \"\"\" if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False read_file ( path , from_line = None , to_line = None ) Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Parameters: Name Type Description Default path Path Path to the code file. required from_line Optional [ int ] Starting line. None to_line Optional [ int ] Ending line. None Returns: Name Type Description Str str String representing the code. Source code in mkreports/tracker.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def read_file ( path : Path , from_line : Optional [ int ] = None , to_line : Optional [ int ] = None ) -> str : \"\"\" Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Args: path (Path): Path to the code file. from_line (Optional[int]): Starting line. to_line (Optional[int]): Ending line. Returns: Str: String representing the code. \"\"\" with path . open ( \"r\" ) as f : lines = f . readlines () # the from_line to_line are line-numbers, not indices. to_line is included return \"\" . join ( lines [ slice ( from_line - 1 if from_line is not None else None , to_line , 1 )] )","title":"tracker"},{"location":"Reference/tracker/#mkreports.tracker.CodeBlock","text":"Source code in mkreports/tracker.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @dataclass class CodeBlock : \"\"\" Structure representing information about a block of code. Args: filename (str): The name of the file with the code. co_name (str): Name of the code block line_start (int): Number of the line where the code block starts. line_end (int): Number of the line where the code block ends. \"\"\" filename : str co_name : str line_start : int line_end : int def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : \"\"\" Return a MdObj representing the code in the block. Args: relative_to (Optional[Path]): The path relative to which the title should be. name_only (bool): Should only the name of the code-file be used. Returns: Code: Code object with the code represented by the code block. \"\"\" code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , )","title":"CodeBlock"},{"location":"Reference/tracker/#mkreports.tracker.CodeBlock.md_code","text":"Return a MdObj representing the code in the block. Parameters: Name Type Description Default relative_to Optional [ Path ] The path relative to which the title should be. None name_only bool Should only the name of the code-file be used. False Returns: Name Type Description Code Code Code object with the code represented by the code block. Source code in mkreports/tracker.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def md_code ( self , relative_to : Optional [ Path ] = None , name_only : bool = False ) -> Code : \"\"\" Return a MdObj representing the code in the block. Args: relative_to (Optional[Path]): The path relative to which the title should be. name_only (bool): Should only the name of the code-file be used. Returns: Code: Code object with the code represented by the code block. \"\"\" code = dedent ( read_file ( Path ( self . filename ), from_line = self . line_start , to_line = self . line_end , ) ) try : assert relative_to is not None filename_to_use = str ( Path ( self . filename ) . relative_to ( relative_to )) except Exception : if name_only : filename_to_use = Path ( self . filename ) . name else : filename_to_use = self . filename return Code ( code = code , title = filename_to_use , first_line = self . line_start , language = \"python\" , )","title":"md_code()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker","text":"Bases: BaseTracker Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. Source code in mkreports/tracker.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 class SimpleTracker ( BaseTracker ): \"\"\" Track first and last line of a code context. When starting it records the line after the current statement, and stopping the line where the current statement ends. The first and last line are required to be in the same file. \"\"\" def __init__ ( self ): \"\"\"Initialize the tracker.\"\"\" self . _active = False self . line_start = None self . line_end = None self . co_name = None def start ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Start the tracker. Args: frame_info (inspect.FrameInfo): A FrameInfo object of where the tracking starts. \"\"\" if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True def stop ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Stop the tracker. Args: frame_info (inspect.FrameInfo): FraneInfo where the tracking ends. \"\"\" if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False def code ( self ) -> List [ CodeBlock ]: \"\"\" Return the tracked code. Returns: List[CodeBlock]: List of code blocks. Here, the list is only of length 1. \"\"\" if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ] @property def active ( self ) -> bool : \"\"\" Returns: bool: Is the tracker currently active? \"\"\" return self . _active","title":"SimpleTracker"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.__init__","text":"Initialize the tracker. Source code in mkreports/tracker.py 126 127 128 129 130 131 def __init__ ( self ): \"\"\"Initialize the tracker.\"\"\" self . _active = False self . line_start = None self . line_end = None self . co_name = None","title":"__init__()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.active","text":"Returns: Name Type Description bool bool Is the tracker currently active? Source code in mkreports/tracker.py 190 191 192 193 194 195 196 197 198 @property def active ( self ) -> bool : \"\"\" Returns: bool: Is the tracker currently active? \"\"\" return self . _active","title":"active()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.code","text":"Return the tracked code. Returns: Type Description List [ CodeBlock ] List[CodeBlock]: List of code blocks. Here, the list is only of length 1. Source code in mkreports/tracker.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def code ( self ) -> List [ CodeBlock ]: \"\"\" Return the tracked code. Returns: List[CodeBlock]: List of code blocks. Here, the list is only of length 1. \"\"\" if ( self . active or self . line_start is None or self . line_end is None or self . co_name is None ): raise TrackerEmptyError () else : return [ CodeBlock ( self . filename , self . co_name , self . line_start , self . line_end ) ]","title":"code()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.start","text":"Start the tracker. Parameters: Name Type Description Default frame_info inspect . FrameInfo A FrameInfo object of where the tracking starts. required Source code in mkreports/tracker.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def start ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Start the tracker. Args: frame_info (inspect.FrameInfo): A FrameInfo object of where the tracking starts. \"\"\" if frame_info . filename == \"<stdin>\" : raise CannotTrackError ( f \"Cannot track { frame_info . filename } \" ) self . stmt_tree = parser . get_stmt_ranges ( Path ( frame_info . filename )) stmt_after = parser . closest_after ( self . stmt_tree , frame_info . lineno ) self . filename = frame_info . filename if stmt_after is None : self . line_start = frame_info . lineno else : self . line_start = stmt_after . begin self . co_name = frame_info . frame . f_code . co_name self . _active = True","title":"start()"},{"location":"Reference/tracker/#mkreports.tracker.SimpleTracker.stop","text":"Stop the tracker. Parameters: Name Type Description Default frame_info inspect . FrameInfo FraneInfo where the tracking ends. required Source code in mkreports/tracker.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def stop ( self , frame_info : inspect . FrameInfo ) -> None : \"\"\" Stop the tracker. Args: frame_info (inspect.FrameInfo): FraneInfo where the tracking ends. \"\"\" if not self . active : raise TrackerNotActiveError ( \"SimpleTracker not active\" ) else : cur_stmt_lines = parser . smallest_overlap ( self . stmt_tree , frame_info . lineno ) if cur_stmt_lines is not None : self . line_end = cur_stmt_lines . end else : raise Exception ( \"Could not find current statement\" ) self . _active = False","title":"stop()"},{"location":"Reference/tracker/#mkreports.tracker.read_file","text":"Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Parameters: Name Type Description Default path Path Path to the code file. required from_line Optional [ int ] Starting line. None to_line Optional [ int ] Ending line. None Returns: Name Type Description Str str String representing the code. Source code in mkreports/tracker.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def read_file ( path : Path , from_line : Optional [ int ] = None , to_line : Optional [ int ] = None ) -> str : \"\"\" Read a part of a file. Reads a file from a line to a certain line. All line numbers are assumed to start with 0. Args: path (Path): Path to the code file. from_line (Optional[int]): Starting line. to_line (Optional[int]): Ending line. Returns: Str: String representing the code. \"\"\" with path . open ( \"r\" ) as f : lines = f . readlines () # the from_line to_line are line-numbers, not indices. to_line is included return \"\" . join ( lines [ slice ( from_line - 1 if from_line is not None else None , to_line , 1 )] )","title":"read_file()"},{"location":"Reference/utils/","text":"find_comment_ids ( text ) Identify ids in a file. We encode IDs used in a file in markdown comments to make them easier to find. This function retrieves them. Parameters: Name Type Description Default text str The string to search for the IDs. required Returns: Type Description Set [ str ] Set[str]: A set with all identified IDs. Source code in mkreports/utils.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def find_comment_ids ( text : str ) -> Set [ str ]: \"\"\" Identify ids in a file. We encode IDs used in a file in markdown comments to make them easier to find. This function retrieves them. Args: text (str): The string to search for the IDs. Returns: Set[str]: A set with all identified IDs. \"\"\" text_split = text . split ( \" \\n \" ) # compile the parser comment_parser = parse . compile ( \"[comment]: # (id: {type} - {value} )\" ) found_ids = [] # get all occurences of an id, identify id-type and id-value for line in text_split : res = comment_parser . parse ( line ) if res is not None : assert isinstance ( res , parse . Result ) found_ids . append ( f \" { res [ 'type' ] } - { res [ 'value' ] } \" ) return set ( found_ids ) func_ref ( x ) Encode a function reference. Parameters: Name Type Description Default x str reference to a function. required Returns: Type Description str The encoded string. Source code in mkreports/utils.py 87 88 89 90 91 92 93 94 95 96 97 98 def func_ref ( x : str ) -> str : \"\"\" Encode a function reference. Args: x (str): reference to a function. Returns: The encoded string. \"\"\" return f \"____ { x } ____\" relative_repo_root ( path ) Path relative to repo root or just the name. Parameters: Name Type Description Default path Union [ Path , str ] Path to analyze required Returns: Name Type Description str str Path relative to the repo root, just the name otherwise. Source code in mkreports/utils.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def relative_repo_root ( path : Union [ Path , str ]) -> str : \"\"\" Path relative to repo root or just the name. Args: path (Union[Path, str]): Path to analyze Returns: str: Path relative to the repo root, just the name otherwise. \"\"\" try : repo = Repo ( \".\" , search_parent_directories = True ) root_dir = repo . working_tree_dir if root_dir is not None : return str ( Path ( path ) . relative_to ( root_dir )) except Exception : pass return Path ( path ) . name repo_root ( path = Path ( '.' )) Find the root of the current repository. Parameters: Name Type Description Default path Path A path in the repository. Path('.') Returns: Type Description Optional [ Path ] Optional[Path]: The root of the repo if it is a repo, None otherwise. Source code in mkreports/utils.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def repo_root ( path : Path = Path ( \".\" )) -> Optional [ Path ]: \"\"\" Find the root of the current repository. Args: path (Path): A path in the repository. Returns: Optional[Path]: The root of the repo if it is a repo, None otherwise. \"\"\" try : repo = Repo ( path , search_parent_directories = True ) return repo . working_tree_dir except Exception : pass return None serialize_json ( obj ) Serialize an object to JSON, removing quotes for special strings. Source code in mkreports/utils.py 101 102 103 def serialize_json ( obj : Any ) -> str : \"\"\"Serialize an object to JSON, removing quotes for special strings.\"\"\" return json . dumps ( obj ) . replace ( '\"____' , \"\" ) . replace ( '____\"' , \"\" ) snake_to_text ( x ) Convert snake case to regular text, with each word capitalized. Source code in mkreports/utils.py 82 83 84 def snake_to_text ( x : str ) -> str : \"\"\"Convert snake case to regular text, with each word capitalized.\"\"\" return \" \" . join ([ w . capitalize () for w in x . split ( \"_\" )])","title":"utils"},{"location":"Reference/utils/#mkreports.utils.find_comment_ids","text":"Identify ids in a file. We encode IDs used in a file in markdown comments to make them easier to find. This function retrieves them. Parameters: Name Type Description Default text str The string to search for the IDs. required Returns: Type Description Set [ str ] Set[str]: A set with all identified IDs. Source code in mkreports/utils.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def find_comment_ids ( text : str ) -> Set [ str ]: \"\"\" Identify ids in a file. We encode IDs used in a file in markdown comments to make them easier to find. This function retrieves them. Args: text (str): The string to search for the IDs. Returns: Set[str]: A set with all identified IDs. \"\"\" text_split = text . split ( \" \\n \" ) # compile the parser comment_parser = parse . compile ( \"[comment]: # (id: {type} - {value} )\" ) found_ids = [] # get all occurences of an id, identify id-type and id-value for line in text_split : res = comment_parser . parse ( line ) if res is not None : assert isinstance ( res , parse . Result ) found_ids . append ( f \" { res [ 'type' ] } - { res [ 'value' ] } \" ) return set ( found_ids )","title":"find_comment_ids()"},{"location":"Reference/utils/#mkreports.utils.func_ref","text":"Encode a function reference. Parameters: Name Type Description Default x str reference to a function. required Returns: Type Description str The encoded string. Source code in mkreports/utils.py 87 88 89 90 91 92 93 94 95 96 97 98 def func_ref ( x : str ) -> str : \"\"\" Encode a function reference. Args: x (str): reference to a function. Returns: The encoded string. \"\"\" return f \"____ { x } ____\"","title":"func_ref()"},{"location":"Reference/utils/#mkreports.utils.relative_repo_root","text":"Path relative to repo root or just the name. Parameters: Name Type Description Default path Union [ Path , str ] Path to analyze required Returns: Name Type Description str str Path relative to the repo root, just the name otherwise. Source code in mkreports/utils.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def relative_repo_root ( path : Union [ Path , str ]) -> str : \"\"\" Path relative to repo root or just the name. Args: path (Union[Path, str]): Path to analyze Returns: str: Path relative to the repo root, just the name otherwise. \"\"\" try : repo = Repo ( \".\" , search_parent_directories = True ) root_dir = repo . working_tree_dir if root_dir is not None : return str ( Path ( path ) . relative_to ( root_dir )) except Exception : pass return Path ( path ) . name","title":"relative_repo_root()"},{"location":"Reference/utils/#mkreports.utils.repo_root","text":"Find the root of the current repository. Parameters: Name Type Description Default path Path A path in the repository. Path('.') Returns: Type Description Optional [ Path ] Optional[Path]: The root of the repo if it is a repo, None otherwise. Source code in mkreports/utils.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def repo_root ( path : Path = Path ( \".\" )) -> Optional [ Path ]: \"\"\" Find the root of the current repository. Args: path (Path): A path in the repository. Returns: Optional[Path]: The root of the repo if it is a repo, None otherwise. \"\"\" try : repo = Repo ( path , search_parent_directories = True ) return repo . working_tree_dir except Exception : pass return None","title":"repo_root()"},{"location":"Reference/utils/#mkreports.utils.serialize_json","text":"Serialize an object to JSON, removing quotes for special strings. Source code in mkreports/utils.py 101 102 103 def serialize_json ( obj : Any ) -> str : \"\"\"Serialize an object to JSON, removing quotes for special strings.\"\"\" return json . dumps ( obj ) . replace ( '\"____' , \"\" ) . replace ( '____\"' , \"\" )","title":"serialize_json()"},{"location":"Reference/utils/#mkreports.utils.snake_to_text","text":"Convert snake case to regular text, with each word capitalized. Source code in mkreports/utils.py 82 83 84 def snake_to_text ( x : str ) -> str : \"\"\"Convert snake case to regular text, with each word capitalized.\"\"\" return \" \" . join ([ w . capitalize () for w in x . split ( \"_\" )])","title":"snake_to_text()"},{"location":"Reference/md/base/","text":"Anchor Bases: MdObj Source code in mkreports/md/base.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 @register_md ( \"Anchor\" ) class Anchor ( MdObj ): \"\"\" Create an anchor object. Args: name (str): Name of the anchor. \"\"\" def __init__ ( self , name : Optional [ str ] = None , prefix : str = \"anchor\" , page_info : Optional [ PageInfo ] = None , ): if name is None : assert page_info is not None assert page_info . idstore is not None # need to create it using the IDStore name = page_info . idstore . next_id ( prefix ) self . _back = SpacedText ( comment_ids ( name ), ( 2 , 2 )) else : self . _back = None self . name = name self . _body = SpacedText ( f \"[]() {{ :name=' { name } ' }} \" , ( 0 , 0 )) self . _settings = None Link Bases: MdObj Source code in mkreports/md/base.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 @register_md ( \"Link\" ) @dataclass () class Link ( MdObj ): \"\"\" Create a link to another page. Args: text (str): The text of the link url (Optional[str]): URL to link to. \"\"\" text : str = \"\" url : str = \"\" def __post_init__ ( self ): link = self . url self . _body = SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 )) self . _back = None self . _settings = None MdObj Bases: ABC A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. It enables adding of objects, which composes them sequentially. Added them adds the body and back separately as well as merges the settings. The body is being nested inside other objects as needed. The 'back' will always be added without indentation and after adding the body (this is useful for e.g. script-tags, but also markdown references). The settings will be added at the top of the page or the entire report, depending on what was requested. End-users should never have to call this class. Source code in mkreports/md/base.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class MdObj ( ABC ): \"\"\" A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. It enables adding of objects, which composes them sequentially. Added them adds the body and back separately as well as merges the settings. The body is being nested inside other objects as needed. The 'back' will always be added without indentation and after adding the body (this is useful for e.g. script-tags, but also markdown references). The settings will be added at the top of the page or the entire report, depending on what was requested. End-users should never have to call this class. \"\"\" _body : Optional [ SpacedText ] _back : Optional [ SpacedText ] _settings : Optional [ Settings ] def __add__ ( self , other ) -> \"MdSeq\" : first = self if isinstance ( self , MdSeq ) else MdSeq ([ self ]) second = other if isinstance ( other , MdSeq ) else MdSeq ([ other ]) return first + second def __radd__ ( self , other ) -> \"MdSeq\" : first = other if isinstance ( self , MdSeq ) else MdSeq ([ other ]) second = self if isinstance ( other , MdSeq ) else MdSeq ([ self ]) return first + second @property def body ( self ) -> SpacedText : \"\"\" Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: SpacedText: A string representing the body with info on how many newlines are expected before and after. \"\"\" return self . _body if self . _body is not None else SpacedText ( \"\" ) @property def back ( self ) -> SpacedText : \"\"\" Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: SpacedText: A string representing the backmatter with info on how many newlines are expected before and after. \"\"\" return self . _back if self . _back is not None else SpacedText ( \"\" ) @property def settings ( self ) -> Settings : \"\"\" Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Settings: A settings object. \"\"\" return self . _settings if self . _settings is not None else Settings () back () Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: Name Type Description SpacedText SpacedText A string representing the backmatter with info on how many newlines are expected before and after. Source code in mkreports/md/base.py 69 70 71 72 73 74 75 76 77 78 79 80 81 @property def back ( self ) -> SpacedText : \"\"\" Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: SpacedText: A string representing the backmatter with info on how many newlines are expected before and after. \"\"\" return self . _back if self . _back is not None else SpacedText ( \"\" ) body () Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: Name Type Description SpacedText SpacedText A string representing the body with info on how many newlines are expected before and after. Source code in mkreports/md/base.py 55 56 57 58 59 60 61 62 63 64 65 66 67 @property def body ( self ) -> SpacedText : \"\"\" Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: SpacedText: A string representing the body with info on how many newlines are expected before and after. \"\"\" return self . _body if self . _body is not None else SpacedText ( \"\" ) settings () Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Name Type Description Settings Settings A settings object. Source code in mkreports/md/base.py 83 84 85 86 87 88 89 90 91 92 93 94 @property def settings ( self ) -> Settings : \"\"\" Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Settings: A settings object. \"\"\" return self . _settings if self . _settings is not None else Settings () MdSeq Bases: MdObj , Sequence Class to caputre a list of other MdObjs. Source code in mkreports/md/base.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @register_md ( \"MdSeq\" ) class MdSeq ( MdObj , Sequence ): \"\"\" Class to caputre a list of other MdObjs. \"\"\" items : Tuple [ MdObj , ... ] def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Args: items (Union[str, Iterable[Union[MdObj, str]]]): A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) def __getitem__ ( self , index : int ) -> MdObj : return self . items [ index ] def __len__ ( self ) -> int : return len ( self . items ) def __add__ ( self , other ) -> \"MdSeq\" : second_items = other . items if type ( other ) == MdSeq else ( other ,) return MdSeq ( self . items + second_items ) def __radd__ ( self , other ) -> \"MdSeq\" : second_items = other if type ( other ) == MdSeq else ( other ,) return MdSeq ( second_items + self . items ) @property def body ( self ) -> SpacedText : \"\"\" Body of the object in markdown - concatenating all individual items. Returns: SpacedText: The body as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . body for elem in self . items ] ) @property def back ( self ) -> SpacedText : \"\"\" Back of the object in markdown - concatenating all individual items. Returns: SpacedText: The back as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . back for elem in self . items ] ) @property def settings ( self ) -> Settings : \"\"\" Setting to be added to page or report. Returns: Settings: A settings object. \"\"\" if len ( self . items ) == 0 : return Settings () else : return functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in self . items ] ) __init__ ( items = ()) Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Parameters: Name Type Description Default items Union [ str , Iterable [ Union [ MdObj , str ]]] A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. () Source code in mkreports/md/base.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Args: items (Union[str, Iterable[Union[MdObj, str]]]): A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) back () Back of the object in markdown - concatenating all individual items. Returns: Name Type Description SpacedText SpacedText The back as a SpacedText object. Source code in mkreports/md/base.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 @property def back ( self ) -> SpacedText : \"\"\" Back of the object in markdown - concatenating all individual items. Returns: SpacedText: The back as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . back for elem in self . items ] ) body () Body of the object in markdown - concatenating all individual items. Returns: Name Type Description SpacedText SpacedText The body as a SpacedText object. Source code in mkreports/md/base.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @property def body ( self ) -> SpacedText : \"\"\" Body of the object in markdown - concatenating all individual items. Returns: SpacedText: The body as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . body for elem in self . items ] ) settings () Setting to be added to page or report. Returns: Name Type Description Settings Settings A settings object. Source code in mkreports/md/base.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @property def settings ( self ) -> Settings : \"\"\" Setting to be added to page or report. Returns: Settings: A settings object. \"\"\" if len ( self . items ) == 0 : return Settings () else : return functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in self . items ] ) Paragraph Bases: MdObj Wraps an object in a paragraph. Similar to 'Raw', but ensures 2 newlines before and after the text and supports adding an anchor to the paragraph. Source code in mkreports/md/base.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 @register_md ( \"P\" ) @register_md ( \"Paragraph\" ) @dataclass class Paragraph ( MdObj ): \"\"\" Wraps an object in a paragraph. Similar to 'Raw', but ensures 2 newlines before and after the text and supports adding an anchor to the paragraph. \"\"\" obj : MdObj anchor : Optional [ Union [ Anchor , str ]] def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): \"\"\" Initialize the paragraph. Args: obj (Union[str, MdObj]): Markdown object or string. String will be wrapped in 'Raw'. anchor (Optional[Union[Anchor, str]]): Anchor to add to the paragraph. \"\"\" self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = SpacedText ( self . obj . body . text , ( 0 , 1 )) + self . anchor . body else : res_body = self . obj . body self . _body = SpacedText ( res_body , ( 2 , 2 )) self . _back = None if not isinstance ( self . anchor , Anchor ) else self . anchor . back self . _settings = None __init__ ( obj , anchor = None ) Initialize the paragraph. Parameters: Name Type Description Default obj Union [ str , MdObj ] Markdown object or string. String will be wrapped in 'Raw'. required anchor Optional [ Union [ Anchor , str ]] Anchor to add to the paragraph. None Source code in mkreports/md/base.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): \"\"\" Initialize the paragraph. Args: obj (Union[str, MdObj]): Markdown object or string. String will be wrapped in 'Raw'. anchor (Optional[Union[Anchor, str]]): Anchor to add to the paragraph. \"\"\" self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = SpacedText ( self . obj . body . text , ( 0 , 1 )) + self . anchor . body else : res_body = self . obj . body self . _body = SpacedText ( res_body , ( 2 , 2 )) self . _back = None if not isinstance ( self . anchor , Anchor ) else self . anchor . back self . _settings = None Raw Bases: MdObj Class to encapsulate raw markdown. Source code in mkreports/md/base.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 @register_md ( \"Raw\" ) @dataclass () class Raw ( MdObj ): \"\"\" Class to encapsulate raw markdown. \"\"\" raw : Text page_settings : Dict [ str , Any ] mkdocs_settings : Dict [ str , Any ] def __init__ ( self , raw : Text = \"\" , dedent = True , back : Text = \"\" , page_settings = None , mkdocs_settings = None , ): \"\"\" Create the 'Raw' object. Args: raw (Text): The text to take as is to markdown. dedent (): Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. back (): The back to be added. As it has be be left-aligned, will always be dedented. page_settings (): Settings to be added for the page. mkdocs_settings (): Settings for the entire report. \"\"\" super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) if isinstance ( back , str ): back = textwrap . dedent ( back ) self . _body = SpacedText ( raw ) self . _back = SpacedText ( back ) self . _settings = Settings ( page = page_settings if page_settings is not None else {}, mkdocs = mkdocs_settings if mkdocs_settings is not None else {}, ) __init__ ( raw = '' , dedent = True , back = '' , page_settings = None , mkdocs_settings = None ) Create the 'Raw' object. Parameters: Name Type Description Default raw Text The text to take as is to markdown. '' dedent Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. True back The back to be added. As it has be be left-aligned, will always be dedented. '' page_settings Settings to be added for the page. None mkdocs_settings Settings for the entire report. None Source code in mkreports/md/base.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def __init__ ( self , raw : Text = \"\" , dedent = True , back : Text = \"\" , page_settings = None , mkdocs_settings = None , ): \"\"\" Create the 'Raw' object. Args: raw (Text): The text to take as is to markdown. dedent (): Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. back (): The back to be added. As it has be be left-aligned, will always be dedented. page_settings (): Settings to be added for the page. mkdocs_settings (): Settings for the entire report. \"\"\" super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) if isinstance ( back , str ): back = textwrap . dedent ( back ) self . _body = SpacedText ( raw ) self . _back = SpacedText ( back ) self . _settings = Settings ( page = page_settings if page_settings is not None else {}, mkdocs = mkdocs_settings if mkdocs_settings is not None else {}, ) ReportLink Bases: Link Source code in mkreports/md/base.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 @register_md ( \"ReportLink\" ) class ReportLink ( Link ): def __init__ ( self , text : str = \"\" , to_page_path : Optional [ Path ] = None , anchor : Optional [ Union [ str , Anchor ]] = None , page_info : Optional [ PageInfo ] = None , ): \"\"\" Create a link to another page in this report. Args: text (str): The text of the link page_info (Optional[PageInfo]): PageInfo object cotaining info of the page to_page_path (Optional[Path]): internal page to link to anchor (Optional[Union[str, Anchor]]): anchor to use \"\"\" assert page_info is not None assert ( page_path := page_info . page_path ) is not None if to_page_path is None : if anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \"# { anchor_id } \" else : # both are not none, do relative if anchor is None : link = f \" { relpath ( to_page_path , start = page_path . parent ) } \" else : anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \" { relpath ( to_page_path , start = page_path . parent ) } # { anchor_id } \" super () . __init__ ( text = text , url = link ) __init__ ( text = '' , to_page_path = None , anchor = None , page_info = None ) Create a link to another page in this report. Parameters: Name Type Description Default text str The text of the link '' page_info Optional [ PageInfo ] PageInfo object cotaining info of the page None to_page_path Optional [ Path ] internal page to link to None anchor Optional [ Union [ str , Anchor ]] anchor to use None Source code in mkreports/md/base.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def __init__ ( self , text : str = \"\" , to_page_path : Optional [ Path ] = None , anchor : Optional [ Union [ str , Anchor ]] = None , page_info : Optional [ PageInfo ] = None , ): \"\"\" Create a link to another page in this report. Args: text (str): The text of the link page_info (Optional[PageInfo]): PageInfo object cotaining info of the page to_page_path (Optional[Path]): internal page to link to anchor (Optional[Union[str, Anchor]]): anchor to use \"\"\" assert page_info is not None assert ( page_path := page_info . page_path ) is not None if to_page_path is None : if anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \"# { anchor_id } \" else : # both are not none, do relative if anchor is None : link = f \" { relpath ( to_page_path , start = page_path . parent ) } \" else : anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \" { relpath ( to_page_path , start = page_path . parent ) } # { anchor_id } \" super () . __init__ ( text = text , url = link ) comment ( x ) Create a comment for markdown. Parameters: Name Type Description Default x str The string to put into the comment. required Returns: Name Type Description SpacedText SpacedText The comment line to be added as backmatter. Source code in mkreports/md/base.py 359 360 361 362 363 364 365 366 367 368 369 370 def comment ( x : str ) -> SpacedText : \"\"\" Create a comment for markdown. Args: x (str): The string to put into the comment. Returns: SpacedText: The comment line to be added as backmatter. \"\"\" return SpacedText ( f \"[comment]: # ( { x } )\" , ( 2 , 1 )) comment_ids ( id ) Put an id into a comment. Parameters: Name Type Description Default id str The ID to insert. required Returns: Name Type Description SpacedText SpacedText The comment-id to be added as backmatter. Source code in mkreports/md/base.py 373 374 375 376 377 378 379 380 381 382 383 384 def comment_ids ( id : str ) -> SpacedText : \"\"\" Put an id into a comment. Args: id (str): The ID to insert. Returns: SpacedText: The comment-id to be added as backmatter. \"\"\" return comment ( f \"id: { id } \" )","title":"base"},{"location":"Reference/md/base/#mkreports.md.base.Anchor","text":"Bases: MdObj Source code in mkreports/md/base.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 @register_md ( \"Anchor\" ) class Anchor ( MdObj ): \"\"\" Create an anchor object. Args: name (str): Name of the anchor. \"\"\" def __init__ ( self , name : Optional [ str ] = None , prefix : str = \"anchor\" , page_info : Optional [ PageInfo ] = None , ): if name is None : assert page_info is not None assert page_info . idstore is not None # need to create it using the IDStore name = page_info . idstore . next_id ( prefix ) self . _back = SpacedText ( comment_ids ( name ), ( 2 , 2 )) else : self . _back = None self . name = name self . _body = SpacedText ( f \"[]() {{ :name=' { name } ' }} \" , ( 0 , 0 )) self . _settings = None","title":"Anchor"},{"location":"Reference/md/base/#mkreports.md.base.Link","text":"Bases: MdObj Source code in mkreports/md/base.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 @register_md ( \"Link\" ) @dataclass () class Link ( MdObj ): \"\"\" Create a link to another page. Args: text (str): The text of the link url (Optional[str]): URL to link to. \"\"\" text : str = \"\" url : str = \"\" def __post_init__ ( self ): link = self . url self . _body = SpacedText ( f \"[ { html . escape ( self . text ) } ]( { link } )\" , ( 0 , 0 )) self . _back = None self . _settings = None","title":"Link"},{"location":"Reference/md/base/#mkreports.md.base.MdObj","text":"Bases: ABC A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. It enables adding of objects, which composes them sequentially. Added them adds the body and back separately as well as merges the settings. The body is being nested inside other objects as needed. The 'back' will always be added without indentation and after adding the body (this is useful for e.g. script-tags, but also markdown references). The settings will be added at the top of the page or the entire report, depending on what was requested. End-users should never have to call this class. Source code in mkreports/md/base.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class MdObj ( ABC ): \"\"\" A class for representing markdown objects. Using this class we will be able to compose markdown objects in various ways. It enables adding of objects, which composes them sequentially. Added them adds the body and back separately as well as merges the settings. The body is being nested inside other objects as needed. The 'back' will always be added without indentation and after adding the body (this is useful for e.g. script-tags, but also markdown references). The settings will be added at the top of the page or the entire report, depending on what was requested. End-users should never have to call this class. \"\"\" _body : Optional [ SpacedText ] _back : Optional [ SpacedText ] _settings : Optional [ Settings ] def __add__ ( self , other ) -> \"MdSeq\" : first = self if isinstance ( self , MdSeq ) else MdSeq ([ self ]) second = other if isinstance ( other , MdSeq ) else MdSeq ([ other ]) return first + second def __radd__ ( self , other ) -> \"MdSeq\" : first = other if isinstance ( self , MdSeq ) else MdSeq ([ other ]) second = self if isinstance ( other , MdSeq ) else MdSeq ([ self ]) return first + second @property def body ( self ) -> SpacedText : \"\"\" Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: SpacedText: A string representing the body with info on how many newlines are expected before and after. \"\"\" return self . _body if self . _body is not None else SpacedText ( \"\" ) @property def back ( self ) -> SpacedText : \"\"\" Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: SpacedText: A string representing the backmatter with info on how many newlines are expected before and after. \"\"\" return self . _back if self . _back is not None else SpacedText ( \"\" ) @property def settings ( self ) -> Settings : \"\"\" Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Settings: A settings object. \"\"\" return self . _settings if self . _settings is not None else Settings ()","title":"MdObj"},{"location":"Reference/md/base/#mkreports.md.base.MdObj.back","text":"Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: Name Type Description SpacedText SpacedText A string representing the backmatter with info on how many newlines are expected before and after. Source code in mkreports/md/base.py 69 70 71 72 73 74 75 76 77 78 79 80 81 @property def back ( self ) -> SpacedText : \"\"\" Default handler returning the backmatter. For subclasses, this can be used by setting 'self._back', but can also be overriden. Returns: SpacedText: A string representing the backmatter with info on how many newlines are expected before and after. \"\"\" return self . _back if self . _back is not None else SpacedText ( \"\" )","title":"back()"},{"location":"Reference/md/base/#mkreports.md.base.MdObj.body","text":"Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: Name Type Description SpacedText SpacedText A string representing the body with info on how many newlines are expected before and after. Source code in mkreports/md/base.py 55 56 57 58 59 60 61 62 63 64 65 66 67 @property def body ( self ) -> SpacedText : \"\"\" Default handler returning the body. For subclasses, this can be used by setting 'self._body', but can also be overriden. Returns: SpacedText: A string representing the body with info on how many newlines are expected before and after. \"\"\" return self . _body if self . _body is not None else SpacedText ( \"\" )","title":"body()"},{"location":"Reference/md/base/#mkreports.md.base.MdObj.settings","text":"Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Name Type Description Settings Settings A settings object. Source code in mkreports/md/base.py 83 84 85 86 87 88 89 90 91 92 93 94 @property def settings ( self ) -> Settings : \"\"\" Default handler returning the settings. For subclasses, this can be used by setting 'self._settings', but can also be overriden. Returns: Settings: A settings object. \"\"\" return self . _settings if self . _settings is not None else Settings ()","title":"settings()"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq","text":"Bases: MdObj , Sequence Class to caputre a list of other MdObjs. Source code in mkreports/md/base.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @register_md ( \"MdSeq\" ) class MdSeq ( MdObj , Sequence ): \"\"\" Class to caputre a list of other MdObjs. \"\"\" items : Tuple [ MdObj , ... ] def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Args: items (Union[str, Iterable[Union[MdObj, str]]]): A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ]) def __getitem__ ( self , index : int ) -> MdObj : return self . items [ index ] def __len__ ( self ) -> int : return len ( self . items ) def __add__ ( self , other ) -> \"MdSeq\" : second_items = other . items if type ( other ) == MdSeq else ( other ,) return MdSeq ( self . items + second_items ) def __radd__ ( self , other ) -> \"MdSeq\" : second_items = other if type ( other ) == MdSeq else ( other ,) return MdSeq ( second_items + self . items ) @property def body ( self ) -> SpacedText : \"\"\" Body of the object in markdown - concatenating all individual items. Returns: SpacedText: The body as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . body for elem in self . items ] ) @property def back ( self ) -> SpacedText : \"\"\" Back of the object in markdown - concatenating all individual items. Returns: SpacedText: The back as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . back for elem in self . items ] ) @property def settings ( self ) -> Settings : \"\"\" Setting to be added to page or report. Returns: Settings: A settings object. \"\"\" if len ( self . items ) == 0 : return Settings () else : return functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in self . items ] )","title":"MdSeq"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq.__init__","text":"Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Parameters: Name Type Description Default items Union [ str , Iterable [ Union [ MdObj , str ]]] A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. () Source code in mkreports/md/base.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = ()): \"\"\" Create a list of markdown objects. All items are appended to list as they are. Strings are wrapped as Raw objects. Args: items (Union[str, Iterable[Union[MdObj, str]]]): A single string can be given (which will internally be wrapped as a list of length 1, or a list of strings or markdown objects. Strings will be wrapped with a 'Raw' object. \"\"\" super () . __init__ () if isinstance ( items , str ): items = [ items ] self . items = tuple ([ x if not isinstance ( x , str ) else Raw ( x ) for x in items ])","title":"__init__()"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq.back","text":"Back of the object in markdown - concatenating all individual items. Returns: Name Type Description SpacedText SpacedText The back as a SpacedText object. Source code in mkreports/md/base.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 @property def back ( self ) -> SpacedText : \"\"\" Back of the object in markdown - concatenating all individual items. Returns: SpacedText: The back as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . back for elem in self . items ] )","title":"back()"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq.body","text":"Body of the object in markdown - concatenating all individual items. Returns: Name Type Description SpacedText SpacedText The body as a SpacedText object. Source code in mkreports/md/base.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @property def body ( self ) -> SpacedText : \"\"\" Body of the object in markdown - concatenating all individual items. Returns: SpacedText: The body as a SpacedText object. \"\"\" if len ( self . items ) == 0 : return SpacedText ( \"\" ) else : return functools . reduce ( lambda x , y : x + y , [ elem . body for elem in self . items ] )","title":"body()"},{"location":"Reference/md/base/#mkreports.md.base.MdSeq.settings","text":"Setting to be added to page or report. Returns: Name Type Description Settings Settings A settings object. Source code in mkreports/md/base.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 @property def settings ( self ) -> Settings : \"\"\" Setting to be added to page or report. Returns: Settings: A settings object. \"\"\" if len ( self . items ) == 0 : return Settings () else : return functools . reduce ( lambda x , y : x + y , [ elem . settings for elem in self . items ] )","title":"settings()"},{"location":"Reference/md/base/#mkreports.md.base.Paragraph","text":"Bases: MdObj Wraps an object in a paragraph. Similar to 'Raw', but ensures 2 newlines before and after the text and supports adding an anchor to the paragraph. Source code in mkreports/md/base.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 @register_md ( \"P\" ) @register_md ( \"Paragraph\" ) @dataclass class Paragraph ( MdObj ): \"\"\" Wraps an object in a paragraph. Similar to 'Raw', but ensures 2 newlines before and after the text and supports adding an anchor to the paragraph. \"\"\" obj : MdObj anchor : Optional [ Union [ Anchor , str ]] def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): \"\"\" Initialize the paragraph. Args: obj (Union[str, MdObj]): Markdown object or string. String will be wrapped in 'Raw'. anchor (Optional[Union[Anchor, str]]): Anchor to add to the paragraph. \"\"\" self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = SpacedText ( self . obj . body . text , ( 0 , 1 )) + self . anchor . body else : res_body = self . obj . body self . _body = SpacedText ( res_body , ( 2 , 2 )) self . _back = None if not isinstance ( self . anchor , Anchor ) else self . anchor . back self . _settings = None","title":"Paragraph"},{"location":"Reference/md/base/#mkreports.md.base.Paragraph.__init__","text":"Initialize the paragraph. Parameters: Name Type Description Default obj Union [ str , MdObj ] Markdown object or string. String will be wrapped in 'Raw'. required anchor Optional [ Union [ Anchor , str ]] Anchor to add to the paragraph. None Source code in mkreports/md/base.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 def __init__ ( self , obj : Union [ str , MdObj ], anchor : Optional [ Union [ Anchor , str ]] = None ): \"\"\" Initialize the paragraph. Args: obj (Union[str, MdObj]): Markdown object or string. String will be wrapped in 'Raw'. anchor (Optional[Union[Anchor, str]]): Anchor to add to the paragraph. \"\"\" self . obj = obj if not isinstance ( obj , str ) else Raw ( obj ) self . anchor = anchor if not isinstance ( anchor , str ) else Anchor ( anchor ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init res_body = SpacedText ( self . obj . body . text , ( 0 , 1 )) + self . anchor . body else : res_body = self . obj . body self . _body = SpacedText ( res_body , ( 2 , 2 )) self . _back = None if not isinstance ( self . anchor , Anchor ) else self . anchor . back self . _settings = None","title":"__init__()"},{"location":"Reference/md/base/#mkreports.md.base.Raw","text":"Bases: MdObj Class to encapsulate raw markdown. Source code in mkreports/md/base.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 @register_md ( \"Raw\" ) @dataclass () class Raw ( MdObj ): \"\"\" Class to encapsulate raw markdown. \"\"\" raw : Text page_settings : Dict [ str , Any ] mkdocs_settings : Dict [ str , Any ] def __init__ ( self , raw : Text = \"\" , dedent = True , back : Text = \"\" , page_settings = None , mkdocs_settings = None , ): \"\"\" Create the 'Raw' object. Args: raw (Text): The text to take as is to markdown. dedent (): Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. back (): The back to be added. As it has be be left-aligned, will always be dedented. page_settings (): Settings to be added for the page. mkdocs_settings (): Settings for the entire report. \"\"\" super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) if isinstance ( back , str ): back = textwrap . dedent ( back ) self . _body = SpacedText ( raw ) self . _back = SpacedText ( back ) self . _settings = Settings ( page = page_settings if page_settings is not None else {}, mkdocs = mkdocs_settings if mkdocs_settings is not None else {}, )","title":"Raw"},{"location":"Reference/md/base/#mkreports.md.base.Raw.__init__","text":"Create the 'Raw' object. Parameters: Name Type Description Default raw Text The text to take as is to markdown. '' dedent Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. True back The back to be added. As it has be be left-aligned, will always be dedented. '' page_settings Settings to be added for the page. None mkdocs_settings Settings for the entire report. None Source code in mkreports/md/base.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def __init__ ( self , raw : Text = \"\" , dedent = True , back : Text = \"\" , page_settings = None , mkdocs_settings = None , ): \"\"\" Create the 'Raw' object. Args: raw (Text): The text to take as is to markdown. dedent (): Should the passed text be 'dedented'. Useful for strings in triple-quotes that are indented. back (): The back to be added. As it has be be left-aligned, will always be dedented. page_settings (): Settings to be added for the page. mkdocs_settings (): Settings for the entire report. \"\"\" super () . __init__ () if dedent : # we only apply dedent to raw strings if isinstance ( raw , str ): raw = textwrap . dedent ( raw ) if isinstance ( back , str ): back = textwrap . dedent ( back ) self . _body = SpacedText ( raw ) self . _back = SpacedText ( back ) self . _settings = Settings ( page = page_settings if page_settings is not None else {}, mkdocs = mkdocs_settings if mkdocs_settings is not None else {}, )","title":"__init__()"},{"location":"Reference/md/base/#mkreports.md.base.ReportLink","text":"Bases: Link Source code in mkreports/md/base.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 @register_md ( \"ReportLink\" ) class ReportLink ( Link ): def __init__ ( self , text : str = \"\" , to_page_path : Optional [ Path ] = None , anchor : Optional [ Union [ str , Anchor ]] = None , page_info : Optional [ PageInfo ] = None , ): \"\"\" Create a link to another page in this report. Args: text (str): The text of the link page_info (Optional[PageInfo]): PageInfo object cotaining info of the page to_page_path (Optional[Path]): internal page to link to anchor (Optional[Union[str, Anchor]]): anchor to use \"\"\" assert page_info is not None assert ( page_path := page_info . page_path ) is not None if to_page_path is None : if anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \"# { anchor_id } \" else : # both are not none, do relative if anchor is None : link = f \" { relpath ( to_page_path , start = page_path . parent ) } \" else : anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \" { relpath ( to_page_path , start = page_path . parent ) } # { anchor_id } \" super () . __init__ ( text = text , url = link )","title":"ReportLink"},{"location":"Reference/md/base/#mkreports.md.base.ReportLink.__init__","text":"Create a link to another page in this report. Parameters: Name Type Description Default text str The text of the link '' page_info Optional [ PageInfo ] PageInfo object cotaining info of the page None to_page_path Optional [ Path ] internal page to link to None anchor Optional [ Union [ str , Anchor ]] anchor to use None Source code in mkreports/md/base.py 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 def __init__ ( self , text : str = \"\" , to_page_path : Optional [ Path ] = None , anchor : Optional [ Union [ str , Anchor ]] = None , page_info : Optional [ PageInfo ] = None , ): \"\"\" Create a link to another page in this report. Args: text (str): The text of the link page_info (Optional[PageInfo]): PageInfo object cotaining info of the page to_page_path (Optional[Path]): internal page to link to anchor (Optional[Union[str, Anchor]]): anchor to use \"\"\" assert page_info is not None assert ( page_path := page_info . page_path ) is not None if to_page_path is None : if anchor is None : raise ValueError ( \"Either id or to_page_path and page_path have to be defined\" ) else : # assume is on the same page anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \"# { anchor_id } \" else : # both are not none, do relative if anchor is None : link = f \" { relpath ( to_page_path , start = page_path . parent ) } \" else : anchor_id = anchor if isinstance ( anchor , str ) else anchor . name link = f \" { relpath ( to_page_path , start = page_path . parent ) } # { anchor_id } \" super () . __init__ ( text = text , url = link )","title":"__init__()"},{"location":"Reference/md/base/#mkreports.md.base.comment","text":"Create a comment for markdown. Parameters: Name Type Description Default x str The string to put into the comment. required Returns: Name Type Description SpacedText SpacedText The comment line to be added as backmatter. Source code in mkreports/md/base.py 359 360 361 362 363 364 365 366 367 368 369 370 def comment ( x : str ) -> SpacedText : \"\"\" Create a comment for markdown. Args: x (str): The string to put into the comment. Returns: SpacedText: The comment line to be added as backmatter. \"\"\" return SpacedText ( f \"[comment]: # ( { x } )\" , ( 2 , 1 ))","title":"comment()"},{"location":"Reference/md/base/#mkreports.md.base.comment_ids","text":"Put an id into a comment. Parameters: Name Type Description Default id str The ID to insert. required Returns: Name Type Description SpacedText SpacedText The comment-id to be added as backmatter. Source code in mkreports/md/base.py 373 374 375 376 377 378 379 380 381 382 383 384 def comment_ids ( id : str ) -> SpacedText : \"\"\" Put an id into a comment. Args: id (str): The ID to insert. Returns: SpacedText: The comment-id to be added as backmatter. \"\"\" return comment ( f \"id: { id } \" )","title":"comment_ids()"},{"location":"Reference/md/combo/","text":"CollapsedCodeFile Bases: MdObj A code-file in a collapsed admonition. Source code in mkreports/md/combo.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @register_md ( \"CollapsedCodeFile\" ) class CollapsedCodeFile ( MdObj ): \"\"\"A code-file in a collapsed admonition.\"\"\" def __init__ ( self , file : Union [ Path , str ], page_info : PageInfo , title : str = \"Code\" ) -> None : \"\"\" Initialize the object. Args: file (Path): The file path (absolute or reltive to cwd) of the code-file. page_info (PageInfo): PageInfo about the page where it is to be added. title (str): Title on the admonition that is visible. \"\"\" file = Path ( file ) self . obj = Admonition ( CodeFile ( file , title = None , page_info = page_info , ), collapse = True , title = title , kind = \"code\" , page_info = page_info , ) self . _body = self . obj . body self . _back = self . obj . back self . _settings = self . obj . settings __init__ ( file , page_info , title = 'Code' ) Initialize the object. Parameters: Name Type Description Default file Path The file path (absolute or reltive to cwd) of the code-file. required page_info PageInfo PageInfo about the page where it is to be added. required title str Title on the admonition that is visible. 'Code' Source code in mkreports/md/combo.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , file : Union [ Path , str ], page_info : PageInfo , title : str = \"Code\" ) -> None : \"\"\" Initialize the object. Args: file (Path): The file path (absolute or reltive to cwd) of the code-file. page_info (PageInfo): PageInfo about the page where it is to be added. title (str): Title on the admonition that is visible. \"\"\" file = Path ( file ) self . obj = Admonition ( CodeFile ( file , title = None , page_info = page_info , ), collapse = True , title = title , kind = \"code\" , page_info = page_info , ) self . _body = self . obj . body self . _back = self . obj . back self . _settings = self . obj . settings HLine Bases: Raw MdObj making a horizontal line. Source code in mkreports/md/combo.py 11 12 13 14 15 16 17 @register_md ( \"HLine\" ) class HLine ( Raw ): \"\"\"MdObj making a horizontal line.\"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( SpacedText ( \"---\" , ( 2 , 2 ))) __init__ () Initialize the object. Source code in mkreports/md/combo.py 15 16 17 def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( SpacedText ( \"---\" , ( 2 , 2 ))) HideNav Bases: Raw Hide the Nav-bar on the page. Once added to a page, this can't be reversed. When the nav-bar is hidden, it can be hard to navigate. Consider added 'NavTabs', that show a header of navigation tabs. Please note that 'HideNav' affects only the current page, while adding NavTabs affects the entire report. Source code in mkreports/md/combo.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @register_md ( \"HideNav\" ) class HideNav ( Raw ): \"\"\" Hide the Nav-bar on the page. Once added to a page, this can't be reversed. When the nav-bar is hidden, it can be hard to navigate. Consider added 'NavTabs', that show a header of navigation tabs. Please note that 'HideNav' affects only the current page, while adding NavTabs affects the entire report. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"navigation\" ])) __init__ () Initialize the object. Source code in mkreports/md/combo.py 77 78 79 def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"navigation\" ])) HideToc Bases: Raw Hide the ToC on the page. Once added to a page, this can't be reversed. Source code in mkreports/md/combo.py 53 54 55 56 57 58 59 60 61 62 63 @register_md ( \"HideToc\" ) class HideToc ( Raw ): \"\"\" Hide the ToC on the page. Once added to a page, this can't be reversed. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"toc\" ])) __init__ () Initialize the object. Source code in mkreports/md/combo.py 61 62 63 def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"toc\" ])) NavTabs Bases: Raw Add a header with navigation tabs. This cannot be reversed once added. Affects the entire report. Source code in mkreports/md/combo.py 82 83 84 85 86 87 88 89 90 91 92 @register_md ( \"NavTabs\" ) class NavTabs ( Raw ): \"\"\" Add a header with navigation tabs. This cannot be reversed once added. Affects the entire report. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( mkdocs_settings = { \"theme\" : { \"features\" : [ \"navigation.tabs\" ]}}) __init__ () Initialize the object. Source code in mkreports/md/combo.py 90 91 92 def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( mkdocs_settings = { \"theme\" : { \"features\" : [ \"navigation.tabs\" ]}})","title":"combo"},{"location":"Reference/md/combo/#mkreports.md.combo.CollapsedCodeFile","text":"Bases: MdObj A code-file in a collapsed admonition. Source code in mkreports/md/combo.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @register_md ( \"CollapsedCodeFile\" ) class CollapsedCodeFile ( MdObj ): \"\"\"A code-file in a collapsed admonition.\"\"\" def __init__ ( self , file : Union [ Path , str ], page_info : PageInfo , title : str = \"Code\" ) -> None : \"\"\" Initialize the object. Args: file (Path): The file path (absolute or reltive to cwd) of the code-file. page_info (PageInfo): PageInfo about the page where it is to be added. title (str): Title on the admonition that is visible. \"\"\" file = Path ( file ) self . obj = Admonition ( CodeFile ( file , title = None , page_info = page_info , ), collapse = True , title = title , kind = \"code\" , page_info = page_info , ) self . _body = self . obj . body self . _back = self . obj . back self . _settings = self . obj . settings","title":"CollapsedCodeFile"},{"location":"Reference/md/combo/#mkreports.md.combo.CollapsedCodeFile.__init__","text":"Initialize the object. Parameters: Name Type Description Default file Path The file path (absolute or reltive to cwd) of the code-file. required page_info PageInfo PageInfo about the page where it is to be added. required title str Title on the admonition that is visible. 'Code' Source code in mkreports/md/combo.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , file : Union [ Path , str ], page_info : PageInfo , title : str = \"Code\" ) -> None : \"\"\" Initialize the object. Args: file (Path): The file path (absolute or reltive to cwd) of the code-file. page_info (PageInfo): PageInfo about the page where it is to be added. title (str): Title on the admonition that is visible. \"\"\" file = Path ( file ) self . obj = Admonition ( CodeFile ( file , title = None , page_info = page_info , ), collapse = True , title = title , kind = \"code\" , page_info = page_info , ) self . _body = self . obj . body self . _back = self . obj . back self . _settings = self . obj . settings","title":"__init__()"},{"location":"Reference/md/combo/#mkreports.md.combo.HLine","text":"Bases: Raw MdObj making a horizontal line. Source code in mkreports/md/combo.py 11 12 13 14 15 16 17 @register_md ( \"HLine\" ) class HLine ( Raw ): \"\"\"MdObj making a horizontal line.\"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( SpacedText ( \"---\" , ( 2 , 2 )))","title":"HLine"},{"location":"Reference/md/combo/#mkreports.md.combo.HLine.__init__","text":"Initialize the object. Source code in mkreports/md/combo.py 15 16 17 def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( SpacedText ( \"---\" , ( 2 , 2 )))","title":"__init__()"},{"location":"Reference/md/combo/#mkreports.md.combo.HideNav","text":"Bases: Raw Hide the Nav-bar on the page. Once added to a page, this can't be reversed. When the nav-bar is hidden, it can be hard to navigate. Consider added 'NavTabs', that show a header of navigation tabs. Please note that 'HideNav' affects only the current page, while adding NavTabs affects the entire report. Source code in mkreports/md/combo.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 @register_md ( \"HideNav\" ) class HideNav ( Raw ): \"\"\" Hide the Nav-bar on the page. Once added to a page, this can't be reversed. When the nav-bar is hidden, it can be hard to navigate. Consider added 'NavTabs', that show a header of navigation tabs. Please note that 'HideNav' affects only the current page, while adding NavTabs affects the entire report. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"navigation\" ]))","title":"HideNav"},{"location":"Reference/md/combo/#mkreports.md.combo.HideNav.__init__","text":"Initialize the object. Source code in mkreports/md/combo.py 77 78 79 def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"navigation\" ]))","title":"__init__()"},{"location":"Reference/md/combo/#mkreports.md.combo.HideToc","text":"Bases: Raw Hide the ToC on the page. Once added to a page, this can't be reversed. Source code in mkreports/md/combo.py 53 54 55 56 57 58 59 60 61 62 63 @register_md ( \"HideToc\" ) class HideToc ( Raw ): \"\"\" Hide the ToC on the page. Once added to a page, this can't be reversed. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"toc\" ]))","title":"HideToc"},{"location":"Reference/md/combo/#mkreports.md.combo.HideToc.__init__","text":"Initialize the object. Source code in mkreports/md/combo.py 61 62 63 def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( page_settings = dict ( hide = [ \"toc\" ]))","title":"__init__()"},{"location":"Reference/md/combo/#mkreports.md.combo.NavTabs","text":"Bases: Raw Add a header with navigation tabs. This cannot be reversed once added. Affects the entire report. Source code in mkreports/md/combo.py 82 83 84 85 86 87 88 89 90 91 92 @register_md ( \"NavTabs\" ) class NavTabs ( Raw ): \"\"\" Add a header with navigation tabs. This cannot be reversed once added. Affects the entire report. \"\"\" def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( mkdocs_settings = { \"theme\" : { \"features\" : [ \"navigation.tabs\" ]}})","title":"NavTabs"},{"location":"Reference/md/combo/#mkreports.md.combo.NavTabs.__init__","text":"Initialize the object. Source code in mkreports/md/combo.py 90 91 92 def __init__ ( self ): \"\"\"Initialize the object.\"\"\" super () . __init__ ( mkdocs_settings = { \"theme\" : { \"features\" : [ \"navigation.tabs\" ]}})","title":"__init__()"},{"location":"Reference/md/containers/","text":"Admonition Bases: MdObj Source code in mkreports/md/containers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @register_md ( \"Admonition\" ) @dataclass class Admonition ( MdObj ): \"\"\" An admonition to be added to a page. Can also be collapsed. For more details see also the Materials-theme for mkdocs. Args: obj (Union[MdObj, Text]): object in the admonition. Markdown object, string or SpacedText. title (Optional[str]): title shown in the admonition. If missing, defaults to 'kind'. kind (Literal[ 'note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote', 'code']): The type of admonition to be shown. See also the Materials-theme for mkdocs for more details. collapse (bool): Should the admonition be collapsed? page_info (Optional[PageInfo]): Only needed when 'kind==\"code\"'. \"\"\" obj : Union [ Text , MdObj ] title : Optional [ str ] = None kind : Literal [ \"note\" , \"abstract\" , \"info\" , \"tip\" , \"success\" , \"question\" , \"warning\" , \"failure\" , \"danger\" , \"bug\" , \"example\" , \"quote\" , \"code\" , ] = \"note\" collapse : bool = False page_info : Optional [ PageInfo ] = None def __post_init__ ( self ): assert self . page_info is not None # if code-admonition, we need to load additional css if self . kind == \"code\" : rel_css_path = store_asset_relpath ( Path ( \"code_admonition.css\" ), self . page_info ) page_settings = dict ( css = [ rel_css_path ]) else : page_settings = {} cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] }, page = page_settings , ) if isinstance ( self . obj , MdObj ): admon_text = self . obj . body back = self . obj . back settings = self . obj . settings settings = cont_settings + settings else : admon_text , back , settings = str ( self . obj ), SpacedText (), cont_settings if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' self . _body = SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ) ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )) self . _back = back self . _settings = settings Code Bases: MdObj Source code in mkreports/md/containers.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @register_md ( \"Code\" ) @dataclass class Code ( MdObj ): \"\"\" Shows a code-block. Args: code (str): The code to be shown as a string. title (Optional[str]): Optional title for the code block. first_line (Optional[int]): Number at the first line. hl_lines (Optional[Tuple[int, int]]): Line-range for highlighting. Is counted relative to 'first_line'. language (Optional[str]): Language for syntax highlighting. dedent (bool): Should the string be de-dented? \"\"\" code : str title : Optional [ str ] = None first_line : Optional [ int ] = None hl_lines : Optional [ Tuple [ int , int ]] = None language : Optional [ str ] = \"python\" dedent : bool = True def __post_init__ ( self ): annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) self . _body = SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ) self . _back = None self . _settings = settings CodeFile Bases: File Code block with the content of a file. Source code in mkreports/md/containers.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 @register_md ( \"CodeFile\" ) class CodeFile ( File ): \"\"\" Code block with the content of a file. \"\"\" def __init__ ( self , path : Union [ Path , str ], page_info : PageInfo , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Set up the code-block with file content. Args: path (Union[Path, str]): Abolute path or relative to current working dir for the code-file to be included. page_info (PageInfo): PageInfo on the page where the code is to be added. title (Optional[str]): Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. hl_lines (Optional[Tuple[int, int]]): Optional range of lines for highlighting. language (Optional[str]): Language for syntax highlighting. \"\"\" assert page_info . project_root is not None assert page_info . report_path is not None path = Path ( path ) super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) self . title = ( title if title is not None else str ( path . relative_to ( page_info . project_root )) ) self . hl_lines = hl_lines self . language = language annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) self . _body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( page_info . report_path ) } '\" , annots ), ( 2 , 2 ), ) self . _back = None self . _settings = settings __init__ ( path , page_info , title = None , hl_lines = None , language = 'python' ) Set up the code-block with file content. Parameters: Name Type Description Default path Union [ Path , str ] Abolute path or relative to current working dir for the code-file to be included. required page_info PageInfo PageInfo on the page where the code is to be added. required title Optional [ str ] Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. None hl_lines Optional [ Tuple [ int , int ]] Optional range of lines for highlighting. None language Optional [ str ] Language for syntax highlighting. 'python' Source code in mkreports/md/containers.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def __init__ ( self , path : Union [ Path , str ], page_info : PageInfo , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Set up the code-block with file content. Args: path (Union[Path, str]): Abolute path or relative to current working dir for the code-file to be included. page_info (PageInfo): PageInfo on the page where the code is to be added. title (Optional[str]): Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. hl_lines (Optional[Tuple[int, int]]): Optional range of lines for highlighting. language (Optional[str]): Language for syntax highlighting. \"\"\" assert page_info . project_root is not None assert page_info . report_path is not None path = Path ( path ) super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) self . title = ( title if title is not None else str ( path . relative_to ( page_info . project_root )) ) self . hl_lines = hl_lines self . language = language annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) self . _body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( page_info . report_path ) } '\" , annots ), ( 2 , 2 ), ) self . _back = None self . _settings = settings Tab Bases: MdObj Source code in mkreports/md/containers.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @register_md ( \"Tab\" ) @dataclass class Tab ( MdObj ): \"\"\" Tab interface Args: obj (Union[Text, MdObj]): The object to be shown in the tab. An MdObj, string or SpacedText. title (Optional[str]): Optional title for the tab. \"\"\" obj : Union [ Text , MdObj ] title : Optional [ str ] = None def __post_init__ ( self ): tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . obj , MdObj ): tab_text = self . obj . body back = self . obj . back settings = self . obj . settings settings = tab_settings + settings else : tab_text , back , settings = str ( self . obj ), SpacedText (), tab_settings if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" self . _body = SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 ) ) self . _back = back self . _settings = settings","title":"containers"},{"location":"Reference/md/containers/#mkreports.md.containers.Admonition","text":"Bases: MdObj Source code in mkreports/md/containers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @register_md ( \"Admonition\" ) @dataclass class Admonition ( MdObj ): \"\"\" An admonition to be added to a page. Can also be collapsed. For more details see also the Materials-theme for mkdocs. Args: obj (Union[MdObj, Text]): object in the admonition. Markdown object, string or SpacedText. title (Optional[str]): title shown in the admonition. If missing, defaults to 'kind'. kind (Literal[ 'note', 'abstract', 'info', 'tip', 'success', 'question', 'warning', 'failure', 'danger', 'bug', 'example', 'quote', 'code']): The type of admonition to be shown. See also the Materials-theme for mkdocs for more details. collapse (bool): Should the admonition be collapsed? page_info (Optional[PageInfo]): Only needed when 'kind==\"code\"'. \"\"\" obj : Union [ Text , MdObj ] title : Optional [ str ] = None kind : Literal [ \"note\" , \"abstract\" , \"info\" , \"tip\" , \"success\" , \"question\" , \"warning\" , \"failure\" , \"danger\" , \"bug\" , \"example\" , \"quote\" , \"code\" , ] = \"note\" collapse : bool = False page_info : Optional [ PageInfo ] = None def __post_init__ ( self ): assert self . page_info is not None # if code-admonition, we need to load additional css if self . kind == \"code\" : rel_css_path = store_asset_relpath ( Path ( \"code_admonition.css\" ), self . page_info ) page_settings = dict ( css = [ rel_css_path ]) else : page_settings = {} cont_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"admonition\" , \"pymdownx.details\" , \"pymdownx.superfences\" , ] }, page = page_settings , ) if isinstance ( self . obj , MdObj ): admon_text = self . obj . body back = self . obj . back settings = self . obj . settings settings = cont_settings + settings else : admon_text , back , settings = str ( self . obj ), SpacedText (), cont_settings if self . title is None : title_md = \"\" else : title_md = f '\" { self . title } \"' self . _body = SpacedText ( f \" { '???' if self . collapse else '!!!' } { self . kind } { title_md } \" , ( 2 , 2 ) ) + SpacedText ( indent ( str ( admon_text ), \" \" ), ( 2 , 2 )) self . _back = back self . _settings = settings","title":"Admonition"},{"location":"Reference/md/containers/#mkreports.md.containers.Code","text":"Bases: MdObj Source code in mkreports/md/containers.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @register_md ( \"Code\" ) @dataclass class Code ( MdObj ): \"\"\" Shows a code-block. Args: code (str): The code to be shown as a string. title (Optional[str]): Optional title for the code block. first_line (Optional[int]): Number at the first line. hl_lines (Optional[Tuple[int, int]]): Line-range for highlighting. Is counted relative to 'first_line'. language (Optional[str]): Language for syntax highlighting. dedent (bool): Should the string be de-dented? \"\"\" code : str title : Optional [ str ] = None first_line : Optional [ int ] = None hl_lines : Optional [ Tuple [ int , int ]] = None language : Optional [ str ] = \"python\" dedent : bool = True def __post_init__ ( self ): annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' if self . first_line is not None : # hi_lines get intrepreted relative to first_line if self . hl_lines is not None : hl_lines = ( self . hl_lines [ 0 ] - self . first_line + 1 , self . hl_lines [ 1 ] - self . first_line + 1 , ) else : hl_lines = self . hl_lines annots = annots + f ' linenums=\" { self . first_line } \"' else : hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [{ \"pymdownx.highlight\" : dict ( use_pygments = True )}] ) ) self . _body = SpacedText ( TextUtils . insert_code ( textwrap . dedent ( self . code ), annots ), ( 2 , 2 ) ) self . _back = None self . _settings = settings","title":"Code"},{"location":"Reference/md/containers/#mkreports.md.containers.CodeFile","text":"Bases: File Code block with the content of a file. Source code in mkreports/md/containers.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 @register_md ( \"CodeFile\" ) class CodeFile ( File ): \"\"\" Code block with the content of a file. \"\"\" def __init__ ( self , path : Union [ Path , str ], page_info : PageInfo , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Set up the code-block with file content. Args: path (Union[Path, str]): Abolute path or relative to current working dir for the code-file to be included. page_info (PageInfo): PageInfo on the page where the code is to be added. title (Optional[str]): Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. hl_lines (Optional[Tuple[int, int]]): Optional range of lines for highlighting. language (Optional[str]): Language for syntax highlighting. \"\"\" assert page_info . project_root is not None assert page_info . report_path is not None path = Path ( path ) super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) self . title = ( title if title is not None else str ( path . relative_to ( page_info . project_root )) ) self . hl_lines = hl_lines self . language = language annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) self . _body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( page_info . report_path ) } '\" , annots ), ( 2 , 2 ), ) self . _back = None self . _settings = settings","title":"CodeFile"},{"location":"Reference/md/containers/#mkreports.md.containers.CodeFile.__init__","text":"Set up the code-block with file content. Parameters: Name Type Description Default path Union [ Path , str ] Abolute path or relative to current working dir for the code-file to be included. required page_info PageInfo PageInfo on the page where the code is to be added. required title Optional [ str ] Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. None hl_lines Optional [ Tuple [ int , int ]] Optional range of lines for highlighting. None language Optional [ str ] Language for syntax highlighting. 'python' Source code in mkreports/md/containers.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 def __init__ ( self , path : Union [ Path , str ], page_info : PageInfo , title : Optional [ str ] = None , hl_lines : Optional [ Tuple [ int , int ]] = None , language : Optional [ str ] = \"python\" , ): \"\"\" Set up the code-block with file content. Args: path (Union[Path, str]): Abolute path or relative to current working dir for the code-file to be included. page_info (PageInfo): PageInfo on the page where the code is to be added. title (Optional[str]): Title of the code-block. If 'None', the path of the code file relative to the project root will be added. If it should be empty, set to empty string. hl_lines (Optional[Tuple[int, int]]): Optional range of lines for highlighting. language (Optional[str]): Language for syntax highlighting. \"\"\" assert page_info . project_root is not None assert page_info . report_path is not None path = Path ( path ) super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = True ) self . title = ( title if title is not None else str ( path . relative_to ( page_info . project_root )) ) self . hl_lines = hl_lines self . language = language annots = \"\" if self . language is not None : annots = annots + self . language if self . title is not None : annots = annots + f ' title=\" { html . escape ( self . title ) } \"' hl_lines = self . hl_lines if hl_lines is not None : annots = annots + f ' hl_lines=\" { hl_lines [ 0 ] } - { hl_lines [ 1 ] } \"' settings = Settings ( mkdocs = dict ( markdown_extensions = [ \"pymdownx.snippets\" , { \"pymdownx.highlight\" : dict ( use_pygments = True )}, ] ) ) self . _body = SpacedText ( TextUtils . insert_code ( f \"--8<-- ' { self . path . relative_to ( page_info . report_path ) } '\" , annots ), ( 2 , 2 ), ) self . _back = None self . _settings = settings","title":"__init__()"},{"location":"Reference/md/containers/#mkreports.md.containers.Tab","text":"Bases: MdObj Source code in mkreports/md/containers.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 @register_md ( \"Tab\" ) @dataclass class Tab ( MdObj ): \"\"\" Tab interface Args: obj (Union[Text, MdObj]): The object to be shown in the tab. An MdObj, string or SpacedText. title (Optional[str]): Optional title for the tab. \"\"\" obj : Union [ Text , MdObj ] title : Optional [ str ] = None def __post_init__ ( self ): tab_settings = Settings ( mkdocs = { \"markdown_extensions\" : [ \"pymdownx.superfences\" , { \"pymdownx.tabbed\" : { \"alternate_style\" : True }}, ] } ) if isinstance ( self . obj , MdObj ): tab_text = self . obj . body back = self . obj . back settings = self . obj . settings settings = tab_settings + settings else : tab_text , back , settings = str ( self . obj ), SpacedText (), tab_settings if self . title is not None : title_text = html . escape ( self . title ) else : title_text = \"\" self . _body = SpacedText ( f '=== \" { title_text } \"' , ( 2 , 2 )) + SpacedText ( indent ( str ( tab_text ), \" \" ), ( 2 , 2 ) ) self . _back = back self . _settings = settings","title":"Tab"},{"location":"Reference/md/docstring/","text":"Docstring Bases: MdObj Add a docstring to the page. Source code in mkreports/md/docstring.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @register_md ( \"Docstring\" ) class Docstring ( MdObj ): \"\"\"Add a docstring to the page.\"\"\" def __init__ ( self , obj_name : str ) -> None : \"\"\" Docstring for the page. Args: obj_name (str): Name of the object for which a docstring should be added. \"\"\" super () . __init__ () self . obj_name = obj_name cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) self . _body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) self . _back = None self . _settings = cont_settings __init__ ( obj_name ) Docstring for the page. Parameters: Name Type Description Default obj_name str Name of the object for which a docstring should be added. required Source code in mkreports/md/docstring.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , obj_name : str ) -> None : \"\"\" Docstring for the page. Args: obj_name (str): Name of the object for which a docstring should be added. \"\"\" super () . __init__ () self . obj_name = obj_name cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) self . _body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) self . _back = None self . _settings = cont_settings","title":"docstring"},{"location":"Reference/md/docstring/#mkreports.md.docstring.Docstring","text":"Bases: MdObj Add a docstring to the page. Source code in mkreports/md/docstring.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @register_md ( \"Docstring\" ) class Docstring ( MdObj ): \"\"\"Add a docstring to the page.\"\"\" def __init__ ( self , obj_name : str ) -> None : \"\"\" Docstring for the page. Args: obj_name (str): Name of the object for which a docstring should be added. \"\"\" super () . __init__ () self . obj_name = obj_name cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) self . _body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) self . _back = None self . _settings = cont_settings","title":"Docstring"},{"location":"Reference/md/docstring/#mkreports.md.docstring.Docstring.__init__","text":"Docstring for the page. Parameters: Name Type Description Default obj_name str Name of the object for which a docstring should be added. required Source code in mkreports/md/docstring.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , obj_name : str ) -> None : \"\"\" Docstring for the page. Args: obj_name (str): Name of the object for which a docstring should be added. \"\"\" super () . __init__ () self . obj_name = obj_name cont_settings = Settings ( mkdocs = { \"plugins\" : [ \"search\" , \"mkdocstrings\" , ] } ) self . _body = SpacedText ( f \"::: { self . obj_name } \" , ( 2 , 2 )) self . _back = None self . _settings = cont_settings","title":"__init__()"},{"location":"Reference/md/file/","text":"File Bases: MdObj A stored file. This is typically not needed by the end-user. Source code in mkreports/md/file.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @register_md ( \"File\" ) class File ( MdObj ): \"\"\" A stored file. This is typically not needed by the end-user. \"\"\" path : Path allow_copy : bool use_hash : bool _hash : Optional [ str ] = None def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , allow_copy : bool = True , use_hash : bool = False , ) -> None : \"\"\" Store a file in the page-store. Args: path (Union[str, Path]): Path to the file, relative to current directory or absolute. page_info (PageInfo): PageInfo for the page where the file should be stored. allow_copy (bool): Is the file allowed to be copied? Otherwise, original location is used. use_hash (bool): If copy is allowed, renames the file to include the file hash. \"\"\" super () . __init__ () # store path needs to be set assert page_info . store_path is not None # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = page_info . store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path # it returns nothing self . _body = None self . _back = None self . _settings = None @property def hash ( self ) -> str : \"\"\" Calculate the hash of the file. Returns: str: Md5-hash as a string. \"\"\" if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash __init__ ( path , page_info , allow_copy = True , use_hash = False ) Store a file in the page-store. Parameters: Name Type Description Default path Union [ str , Path ] Path to the file, relative to current directory or absolute. required page_info PageInfo PageInfo for the page where the file should be stored. required allow_copy bool Is the file allowed to be copied? Otherwise, original location is used. True use_hash bool If copy is allowed, renames the file to include the file hash. False Source code in mkreports/md/file.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , allow_copy : bool = True , use_hash : bool = False , ) -> None : \"\"\" Store a file in the page-store. Args: path (Union[str, Path]): Path to the file, relative to current directory or absolute. page_info (PageInfo): PageInfo for the page where the file should be stored. allow_copy (bool): Is the file allowed to be copied? Otherwise, original location is used. use_hash (bool): If copy is allowed, renames the file to include the file hash. \"\"\" super () . __init__ () # store path needs to be set assert page_info . store_path is not None # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = page_info . store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path # it returns nothing self . _body = None self . _back = None self . _settings = None hash () Calculate the hash of the file. Returns: Name Type Description str str Md5-hash as a string. Source code in mkreports/md/file.py 150 151 152 153 154 155 156 157 158 159 160 161 @property def hash ( self ) -> str : \"\"\" Calculate the hash of the file. Returns: str: Md5-hash as a string. \"\"\" if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash md5_hash_file ( path ) Get md5 hash of a file. Parameters: Name Type Description Default path Path Absolute path or relative to current directory of the file. required Returns: Name Type Description str str The md5 hash of the file. Source code in mkreports/md/file.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def md5_hash_file ( path : Path ) -> str : \"\"\" Get md5 hash of a file. Args: path (Path): Absolute path or relative to current directory of the file. Returns: str: The md5 hash of the file. \"\"\" m = hashlib . md5 () with path . open ( \"rb\" ) as f : m . update ( f . read ()) return m . hexdigest () relpath_html ( target , page_path ) Relative path as to be used for html. This is a bit more complicated, as some markdown pages are encoded as a directory (with implicit index.html being called). The paths can be relative or absolute. If relative, should be relative to same directory. Parameters: Name Type Description Default target Path The target path required page_path Path Path of the current page. required Returns: Name Type Description str str Relative path as a string. Source code in mkreports/md/file.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def relpath_html ( target : Path , page_path : Path ) -> str : \"\"\" Relative path as to be used for html. This is a bit more complicated, as some markdown pages are encoded as a directory (with implicit index.html being called). The paths can be relative or absolute. If relative, should be relative to same directory. Args: target (Path): The target path page_path (Path): Path of the current page. Returns: str: Relative path as a string. \"\"\" if page_path . stem == \"index\" : # here, for translating to html, this path is referred to as its parent return relpath ( target , page_path . parent ) else : # for translating to html, will be converted to path.parent / path.stem / index.html return relpath ( target , page_path ) store_asset_relpath ( asset_path_mkreports , page_info ) Store an asset and return relative path to it. Parameters: Name Type Description Default asset_path Path Relative asset path inside 'mkreports' required page_info PageInfo PageInfo for the page in use required Returns: Name Type Description str str Path to the asset as it should be used from html Source code in mkreports/md/file.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def store_asset_relpath ( asset_path_mkreports : Path , page_info : PageInfo ) -> str : \"\"\" Store an asset and return relative path to it. Args: asset_path (Path): Relative asset path inside 'mkreports' page_info (PageInfo): PageInfo for the page in use Returns: str: Path to the asset as it should be used from html \"\"\" assert page_info . javascript_path is not None assert page_info . page_path is not None asset_path_report_abs = ( page_info . javascript_path / \"assets\" / asset_path_mkreports . name ) asset_path_report_abs . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( imp_res . files ( \"mkreports\" ) / \"assets\" / asset_path_mkreports , asset_path_report_abs , ) return relpath_html ( asset_path_report_abs , page_info . page_path ) true_stem ( path ) True stem of a path, without all suffixes, not just last. Source code in mkreports/md/file.py 14 15 16 def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"file"},{"location":"Reference/md/file/#mkreports.md.file.File","text":"Bases: MdObj A stored file. This is typically not needed by the end-user. Source code in mkreports/md/file.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 @register_md ( \"File\" ) class File ( MdObj ): \"\"\" A stored file. This is typically not needed by the end-user. \"\"\" path : Path allow_copy : bool use_hash : bool _hash : Optional [ str ] = None def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , allow_copy : bool = True , use_hash : bool = False , ) -> None : \"\"\" Store a file in the page-store. Args: path (Union[str, Path]): Path to the file, relative to current directory or absolute. page_info (PageInfo): PageInfo for the page where the file should be stored. allow_copy (bool): Is the file allowed to be copied? Otherwise, original location is used. use_hash (bool): If copy is allowed, renames the file to include the file hash. \"\"\" super () . __init__ () # store path needs to be set assert page_info . store_path is not None # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = page_info . store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path # it returns nothing self . _body = None self . _back = None self . _settings = None @property def hash ( self ) -> str : \"\"\" Calculate the hash of the file. Returns: str: Md5-hash as a string. \"\"\" if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash","title":"File"},{"location":"Reference/md/file/#mkreports.md.file.File.__init__","text":"Store a file in the page-store. Parameters: Name Type Description Default path Union [ str , Path ] Path to the file, relative to current directory or absolute. required page_info PageInfo PageInfo for the page where the file should be stored. required allow_copy bool Is the file allowed to be copied? Otherwise, original location is used. True use_hash bool If copy is allowed, renames the file to include the file hash. False Source code in mkreports/md/file.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , allow_copy : bool = True , use_hash : bool = False , ) -> None : \"\"\" Store a file in the page-store. Args: path (Union[str, Path]): Path to the file, relative to current directory or absolute. page_info (PageInfo): PageInfo for the page where the file should be stored. allow_copy (bool): Is the file allowed to be copied? Otherwise, original location is used. use_hash (bool): If copy is allowed, renames the file to include the file hash. \"\"\" super () . __init__ () # store path needs to be set assert page_info . store_path is not None # set the existing attributes self . allow_copy = allow_copy self . use_hash = use_hash self . store_path = page_info . store_path # for the path we first have to see if they will be copied self . path = Path ( path ) . absolute () if self . allow_copy : if self . use_hash : # we calculate the hash of the file to be ingested new_path = self . store_path / ( true_stem ( self . path ) + \"-\" + self . hash + \"\" . join ( self . path . suffixes ) ) else : new_path = self . store_path / self . path . name # now see if we move or copy the file new_path . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( path , new_path ) self . path = new_path # it returns nothing self . _body = None self . _back = None self . _settings = None","title":"__init__()"},{"location":"Reference/md/file/#mkreports.md.file.File.hash","text":"Calculate the hash of the file. Returns: Name Type Description str str Md5-hash as a string. Source code in mkreports/md/file.py 150 151 152 153 154 155 156 157 158 159 160 161 @property def hash ( self ) -> str : \"\"\" Calculate the hash of the file. Returns: str: Md5-hash as a string. \"\"\" if self . _hash is None : self . _hash = md5_hash_file ( self . path ) return self . _hash","title":"hash()"},{"location":"Reference/md/file/#mkreports.md.file.md5_hash_file","text":"Get md5 hash of a file. Parameters: Name Type Description Default path Path Absolute path or relative to current directory of the file. required Returns: Name Type Description str str The md5 hash of the file. Source code in mkreports/md/file.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def md5_hash_file ( path : Path ) -> str : \"\"\" Get md5 hash of a file. Args: path (Path): Absolute path or relative to current directory of the file. Returns: str: The md5 hash of the file. \"\"\" m = hashlib . md5 () with path . open ( \"rb\" ) as f : m . update ( f . read ()) return m . hexdigest ()","title":"md5_hash_file()"},{"location":"Reference/md/file/#mkreports.md.file.relpath_html","text":"Relative path as to be used for html. This is a bit more complicated, as some markdown pages are encoded as a directory (with implicit index.html being called). The paths can be relative or absolute. If relative, should be relative to same directory. Parameters: Name Type Description Default target Path The target path required page_path Path Path of the current page. required Returns: Name Type Description str str Relative path as a string. Source code in mkreports/md/file.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def relpath_html ( target : Path , page_path : Path ) -> str : \"\"\" Relative path as to be used for html. This is a bit more complicated, as some markdown pages are encoded as a directory (with implicit index.html being called). The paths can be relative or absolute. If relative, should be relative to same directory. Args: target (Path): The target path page_path (Path): Path of the current page. Returns: str: Relative path as a string. \"\"\" if page_path . stem == \"index\" : # here, for translating to html, this path is referred to as its parent return relpath ( target , page_path . parent ) else : # for translating to html, will be converted to path.parent / path.stem / index.html return relpath ( target , page_path )","title":"relpath_html()"},{"location":"Reference/md/file/#mkreports.md.file.store_asset_relpath","text":"Store an asset and return relative path to it. Parameters: Name Type Description Default asset_path Path Relative asset path inside 'mkreports' required page_info PageInfo PageInfo for the page in use required Returns: Name Type Description str str Path to the asset as it should be used from html Source code in mkreports/md/file.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def store_asset_relpath ( asset_path_mkreports : Path , page_info : PageInfo ) -> str : \"\"\" Store an asset and return relative path to it. Args: asset_path (Path): Relative asset path inside 'mkreports' page_info (PageInfo): PageInfo for the page in use Returns: str: Path to the asset as it should be used from html \"\"\" assert page_info . javascript_path is not None assert page_info . page_path is not None asset_path_report_abs = ( page_info . javascript_path / \"assets\" / asset_path_mkreports . name ) asset_path_report_abs . parent . mkdir ( parents = True , exist_ok = True ) shutil . copy ( imp_res . files ( \"mkreports\" ) / \"assets\" / asset_path_mkreports , asset_path_report_abs , ) return relpath_html ( asset_path_report_abs , page_info . page_path )","title":"store_asset_relpath()"},{"location":"Reference/md/file/#mkreports.md.file.true_stem","text":"True stem of a path, without all suffixes, not just last. Source code in mkreports/md/file.py 14 15 16 def true_stem ( path : Path ) -> str : \"\"\"True stem of a path, without all suffixes, not just last.\"\"\" return path . name [: - ( len ( \"\" . join ( path . suffixes )))]","title":"true_stem()"},{"location":"Reference/md/handler/","text":"Handler Source code in mkreports/md/handler.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @dataclass class Handler : \"\"\" A handler for output. Args: name (str): Name of the handler. class_type (Union[type, Tuple[type, ...]]): Classes covered by the handler. func (Callable): the function to use to handle the output. \"\"\" name : str class_type : Union [ type , Tuple [ type , ... ]] func : Callable","title":"handler"},{"location":"Reference/md/handler/#mkreports.md.handler.Handler","text":"Source code in mkreports/md/handler.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @dataclass class Handler : \"\"\" A handler for output. Args: name (str): Name of the handler. class_type (Union[type, Tuple[type, ...]]): Classes covered by the handler. func (Callable): the function to use to handle the output. \"\"\" name : str class_type : Union [ type , Tuple [ type , ... ]] func : Callable","title":"Handler"},{"location":"Reference/md/header/","text":"Heading Bases: MdObj Source code in mkreports/md/header.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @register_md ( \"Heading\" ) @dataclass class Heading ( MdObj ): \"\"\" Create a heading. Pre-defined heading levels exists as exported objects 'H1' to 'H7'. Args: title (str): The heading title. level (int): Level of the heading. style (Literal[\"atx\", \"setext\"]): Style of the heading in markdown. anchor (Optional[Union[Anchor, str]]): Anchor to be added to heading. \"\"\" title : str level : int style : Literal [ \"atx\" , \"setext\" ] = \"atx\" anchor : Optional [ Union [ Anchor , str ]] = None def __post_init__ ( self ): if isinstance ( self . anchor , Anchor ): self . _back = self . anchor . back else : self . _back = None if isinstance ( self . anchor , str ): self . anchor = Anchor ( self . anchor ) heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . body . text self . _body = SpacedText ( heading , ( 2 , 2 ), ) self . _settings = None","title":"header"},{"location":"Reference/md/header/#mkreports.md.header.Heading","text":"Bases: MdObj Source code in mkreports/md/header.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @register_md ( \"Heading\" ) @dataclass class Heading ( MdObj ): \"\"\" Create a heading. Pre-defined heading levels exists as exported objects 'H1' to 'H7'. Args: title (str): The heading title. level (int): Level of the heading. style (Literal[\"atx\", \"setext\"]): Style of the heading in markdown. anchor (Optional[Union[Anchor, str]]): Anchor to be added to heading. \"\"\" title : str level : int style : Literal [ \"atx\" , \"setext\" ] = \"atx\" anchor : Optional [ Union [ Anchor , str ]] = None def __post_init__ ( self ): if isinstance ( self . anchor , Anchor ): self . _back = self . anchor . back else : self . _back = None if isinstance ( self . anchor , str ): self . anchor = Anchor ( self . anchor ) heading = mdt . Header . Header . choose_header ( self . level , self . title , self . style ) . strip ( \" \\n \" ) if isinstance ( self . anchor , Anchor ): # note, string conversion to Anchor done in post-init heading += self . anchor . body . text self . _body = SpacedText ( heading , ( 2 , 2 ), ) self . _settings = None","title":"Heading"},{"location":"Reference/md/idstore/","text":"IDStore Store for ids. Used to create unique IDs on a page. Source code in mkreports/md/idstore.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class IDStore : \"\"\" Store for ids. Used to create unique IDs on a page. \"\"\" _count : Dict [ str , int ] _used : Set [ str ] _start_with : int def __init__ ( self , start_with : int = 0 , used_ids : Set [ str ] = set ()) -> None : \"\"\" Initialize the IDStore. Args: start_with (int): First value of the counter. used_ids (set[str]): Set of IDs that have to be avoided as they are otherwise used. \"\"\" self . _count = defaultdict ( partial ( identity , start_with - 1 )) self . _used = copy ( used_ids ) self . _start_with = start_with def _increment ( self , prefix : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" self . _count [ prefix ] += 1 return self . _count [ prefix ] def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. Args: prefix (str): Prefix to be used for the ID. Returns: str: ID as a string. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id def __eq__ ( self , other ): if type ( self ) != type ( other ): return False return self . __dict__ == other . __dict__ __init__ ( start_with = 0 , used_ids = set ()) Initialize the IDStore. Parameters: Name Type Description Default start_with int First value of the counter. 0 used_ids set [ str ] Set of IDs that have to be avoided as they are otherwise used. set() Source code in mkreports/md/idstore.py 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , start_with : int = 0 , used_ids : Set [ str ] = set ()) -> None : \"\"\" Initialize the IDStore. Args: start_with (int): First value of the counter. used_ids (set[str]): Set of IDs that have to be avoided as they are otherwise used. \"\"\" self . _count = defaultdict ( partial ( identity , start_with - 1 )) self . _used = copy ( used_ids ) self . _start_with = start_with _increment ( prefix ) Returns the next value of the counter (and increments). Source code in mkreports/md/idstore.py 33 34 35 36 37 38 def _increment ( self , prefix : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" self . _count [ prefix ] += 1 return self . _count [ prefix ] next_id ( prefix ) Returns an id with a counted number at the end. Parameters: Name Type Description Default prefix str Prefix to be used for the ID. required Returns: Name Type Description str str ID as a string. Source code in mkreports/md/idstore.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. Args: prefix (str): Prefix to be used for the ID. Returns: str: ID as a string. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id","title":"idstore"},{"location":"Reference/md/idstore/#mkreports.md.idstore.IDStore","text":"Store for ids. Used to create unique IDs on a page. Source code in mkreports/md/idstore.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class IDStore : \"\"\" Store for ids. Used to create unique IDs on a page. \"\"\" _count : Dict [ str , int ] _used : Set [ str ] _start_with : int def __init__ ( self , start_with : int = 0 , used_ids : Set [ str ] = set ()) -> None : \"\"\" Initialize the IDStore. Args: start_with (int): First value of the counter. used_ids (set[str]): Set of IDs that have to be avoided as they are otherwise used. \"\"\" self . _count = defaultdict ( partial ( identity , start_with - 1 )) self . _used = copy ( used_ids ) self . _start_with = start_with def _increment ( self , prefix : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" self . _count [ prefix ] += 1 return self . _count [ prefix ] def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. Args: prefix (str): Prefix to be used for the ID. Returns: str: ID as a string. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id def __eq__ ( self , other ): if type ( self ) != type ( other ): return False return self . __dict__ == other . __dict__","title":"IDStore"},{"location":"Reference/md/idstore/#mkreports.md.idstore.IDStore.__init__","text":"Initialize the IDStore. Parameters: Name Type Description Default start_with int First value of the counter. 0 used_ids set [ str ] Set of IDs that have to be avoided as they are otherwise used. set() Source code in mkreports/md/idstore.py 20 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , start_with : int = 0 , used_ids : Set [ str ] = set ()) -> None : \"\"\" Initialize the IDStore. Args: start_with (int): First value of the counter. used_ids (set[str]): Set of IDs that have to be avoided as they are otherwise used. \"\"\" self . _count = defaultdict ( partial ( identity , start_with - 1 )) self . _used = copy ( used_ids ) self . _start_with = start_with","title":"__init__()"},{"location":"Reference/md/idstore/#mkreports.md.idstore.IDStore._increment","text":"Returns the next value of the counter (and increments). Source code in mkreports/md/idstore.py 33 34 35 36 37 38 def _increment ( self , prefix : str ) -> int : \"\"\" Returns the next value of the counter (and increments). \"\"\" self . _count [ prefix ] += 1 return self . _count [ prefix ]","title":"_increment()"},{"location":"Reference/md/idstore/#mkreports.md.idstore.IDStore.next_id","text":"Returns an id with a counted number at the end. Parameters: Name Type Description Default prefix str Prefix to be used for the ID. required Returns: Name Type Description str str ID as a string. Source code in mkreports/md/idstore.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def next_id ( self , prefix : str ) -> str : \"\"\" Returns an id with a counted number at the end. Args: prefix (str): Prefix to be used for the ID. Returns: str: ID as a string. \"\"\" # get the next id until it has not been used yet while ( next_id := f \" { prefix } - { self . _increment ( prefix ) } \" ) in self . _used : pass self . _used . add ( next_id ) return next_id","title":"next_id()"},{"location":"Reference/md/image/","text":"Altair Bases: File Include an Altair image. Source code in mkreports/md/image.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 @register_md ( \"Altair\" ) class Altair ( File ): \"\"\" Include an Altair image. \"\"\" def __init__ ( self , altair , page_info : PageInfo , csv_name : str = \"altair\" , use_hash : bool = True , ** kwargs , ): \"\"\" Create object to include an Altair image. Args: altair: An altair image. page_info (PageInfo): PageInfo to the page where it is to be included. csv_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { csv_name } .csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash , ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = page_info . idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ) self . _settings = settings __init__ ( altair , page_info , csv_name = 'altair' , use_hash = True , ** kwargs ) Create object to include an Altair image. Parameters: Name Type Description Default altair An altair image. required page_info PageInfo PageInfo to the page where it is to be included. required csv_name str Name of the saved file (before hash if hash=True) 'altair' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def __init__ ( self , altair , page_info : PageInfo , csv_name : str = \"altair\" , use_hash : bool = True , ** kwargs , ): \"\"\" Create object to include an Altair image. Args: altair: An altair image. page_info (PageInfo): PageInfo to the page where it is to be included. csv_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { csv_name } .csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash , ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = page_info . idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ) self . _settings = settings ImageFile Bases: File An image file. Source code in mkreports/md/image.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @register_md ( \"ImageFile\" ) class ImageFile ( File ): \"\"\"An image file.\"\"\" text : str tooltip : str link_type : str def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : \"\"\" Args: path (Union[str, Path]): Path to the image file. page_info (PageInfo): PageInfo object about the page. Added by page-wrapper link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Text shown if the image can't be displayed. tooltip (str): The tooltip shown when hovering over the image. allow_copy (bool): Should the image-file be copied to the store (Default: True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( path = path , page_info = page_info , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type # page_info needs to be set assert page_info . page_path is not None if self . link_type == \"inline\" : self . _body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_info . page_path . parent )), tooltip = self . tooltip , ) ) self . _back = None self . _settings = None elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" ) __init__ ( path , page_info , link_type = 'inline' , text = '' , tooltip = '' , allow_copy = True , use_hash = True ) Parameters: Name Type Description Default path Union [ str , Path ] Path to the image file. required page_info PageInfo PageInfo object about the page. Added by page-wrapper required link_type Literal ['inline', 'ref'] Link-type to use. 'inline' text str Text shown if the image can't be displayed. '' tooltip str The tooltip shown when hovering over the image. '' allow_copy bool Should the image-file be copied to the store (Default: True) True use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : \"\"\" Args: path (Union[str, Path]): Path to the image file. page_info (PageInfo): PageInfo object about the page. Added by page-wrapper link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Text shown if the image can't be displayed. tooltip (str): The tooltip shown when hovering over the image. allow_copy (bool): Should the image-file be copied to the store (Default: True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( path = path , page_info = page_info , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type # page_info needs to be set assert page_info . page_path is not None if self . link_type == \"inline\" : self . _body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_info . page_path . parent )), tooltip = self . tooltip , ) ) self . _back = None self . _settings = None elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" ) Matplotlib Bases: ImageFile Source code in mkreports/md/image.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @register_md ( \"Matplotlib\" ) class Matplotlib ( ImageFile ): def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"matplotlib_image\" , use_hash = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) # for matplotlib # first we need to convert the units if given if width is not None or height is not None : if units != \"in\" : if units == \"cm\" : factor = 1 / 2.54 elif units == \"mm\" : factor = 1 / ( 10 * 2.54 ) else : raise ValueError ( f \"unit { units } not supported. Must be one of 'in', 'cm' or 'mm'.\" ) width = width * factor if width is not None else None height = height * factor if height is not None else None # if only one of the two is set, we infer the other if width is None and height is not None : old_width = image . get_figwidth () old_height = image . get_figheight () width = old_width * ( height / old_height ) elif width is not None and height is None : old_width = image . get_figwidth () old_height = image . get_figheight () height = old_height * ( width / old_width ) # now we set the new figure height, but on a copy of the figure image = deepcopy ( image ) image . set_size_inches ( w = width , h = height ) # save it image . savefig ( path , dpi = \"figure\" if dpi is None else dpi ) super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , ) __init__ ( image , page_info , width = None , height = None , units = 'in' , dpi = None , link_type = 'inline' , text = '' , tooltip = '' , img_type = 'png' , img_name = 'matplotlib_image' , use_hash = True ) An image object for inclusion on a page. Parameters: Name Type Description Default image The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. required page_info PageInfo PageInfo for the page where the image should be included. required width Optional [ float ] width of the image None height Optional [ float ] height of the image None units Literal ['in', 'cm', 'mm'] units of the width and height 'in' dpi Optional [ float ] dpi of the image output. None link_type Literal ['inline', 'ref'] Link-type to be used. 'inline' text str The alternative text if the image is not available. '' tooltip str The tooltip to use when hovering over the image. '' img_type Literal ['jpg', 'png'] Type of the image to create during saving. 'png' img_name str Name of the saved file (before hash if hash=True) 'matplotlib_image' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"matplotlib_image\" , use_hash = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) # for matplotlib # first we need to convert the units if given if width is not None or height is not None : if units != \"in\" : if units == \"cm\" : factor = 1 / 2.54 elif units == \"mm\" : factor = 1 / ( 10 * 2.54 ) else : raise ValueError ( f \"unit { units } not supported. Must be one of 'in', 'cm' or 'mm'.\" ) width = width * factor if width is not None else None height = height * factor if height is not None else None # if only one of the two is set, we infer the other if width is None and height is not None : old_width = image . get_figwidth () old_height = image . get_figheight () width = old_width * ( height / old_height ) elif width is not None and height is None : old_width = image . get_figwidth () old_height = image . get_figheight () height = old_height * ( width / old_width ) # now we set the new figure height, but on a copy of the figure image = deepcopy ( image ) image . set_size_inches ( w = width , h = height ) # save it image . savefig ( path , dpi = \"figure\" if dpi is None else dpi ) super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , ) PIL Bases: ImageFile A PIL image for inclusion. Source code in mkreports/md/image.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 @register_md ( \"PIL\" ) class PIL ( ImageFile ): \"\"\"A PIL image for inclusion.\"\"\" def __init__ ( self , image , page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"pil_image\" , use_hash : bool = True , ) -> None : \"\"\" Create MdObj for PIL image. Args: image (PIL.Image.Image): an Image object from PIL page_info (PageInfo): PageInfo for the page where the image is to be included. link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Alternative text for the image. tooltip (str): Tooltip when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): File-type to use when saving the image. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) image . save ( path ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , ) __init__ ( image , page_info , link_type = 'inline' , text = '' , tooltip = '' , img_type = 'png' , img_name = 'pil_image' , use_hash = True ) Create MdObj for PIL image. Parameters: Name Type Description Default image PIL . Image . Image an Image object from PIL required page_info PageInfo PageInfo for the page where the image is to be included. required link_type Literal ['inline', 'ref'] Link-type to use. 'inline' text str Alternative text for the image. '' tooltip str Tooltip when hovering over the image. '' img_type Literal ['jpg', 'png'] File-type to use when saving the image. 'png' img_name str Name of the saved file (before hash if hash=True) 'pil_image' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def __init__ ( self , image , page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"pil_image\" , use_hash : bool = True , ) -> None : \"\"\" Create MdObj for PIL image. Args: image (PIL.Image.Image): an Image object from PIL page_info (PageInfo): PageInfo for the page where the image is to be included. link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Alternative text for the image. tooltip (str): Tooltip when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): File-type to use when saving the image. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) image . save ( path ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , ) Plotly Bases: File Plotly image as MdObj. Source code in mkreports/md/image.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 @register_md ( \"Plotly\" ) class Plotly ( File ): \"\"\" Plotly image as MdObj. \"\"\" def __init__ ( self , plotly , page_info : PageInfo , json_name : str = \"plotly\" , use_hash : bool = True , ** kwargs , ): \"\"\" Initialize the Plotly MdObj. Args: plotly (): The plotly graph to plot. page_info (PageInfo): PageInfo to the page where it is to be included. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = page_info . idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ) self . _settings = settings __init__ ( plotly , page_info , json_name = 'plotly' , use_hash = True , ** kwargs ) Initialize the Plotly MdObj. Parameters: Name Type Description Default plotly The plotly graph to plot. required page_info PageInfo PageInfo to the page where it is to be included. required json_name str Name of the saved file (before hash if hash=True) 'plotly' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def __init__ ( self , plotly , page_info : PageInfo , json_name : str = \"plotly\" , use_hash : bool = True , ** kwargs , ): \"\"\" Initialize the Plotly MdObj. Args: plotly (): The plotly graph to plot. page_info (PageInfo): PageInfo to the page where it is to be included. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = page_info . idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ) self . _settings = settings Plotnine Bases: ImageFile Source code in mkreports/md/image.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 @register_md ( \"Plotnine\" ) class Plotnine ( ImageFile ): def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"plotnine_image\" , use_hash : bool = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) image . save ( path , width = width , height = height , dpi = dpi , units = units , verbose = False , ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , ) __init__ ( image , page_info , width = None , height = None , units = 'in' , dpi = None , link_type = 'inline' , text = '' , tooltip = '' , img_type = 'png' , img_name = 'plotnine_image' , use_hash = True ) An image object for inclusion on a page. Parameters: Name Type Description Default image The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. required page_info PageInfo PageInfo for the page where the image should be included. required width Optional [ float ] width of the image None height Optional [ float ] height of the image None units Literal ['in', 'cm', 'mm'] units of the width and height 'in' dpi Optional [ float ] dpi of the image output. None link_type Literal ['inline', 'ref'] Link-type to be used. 'inline' text str The alternative text if the image is not available. '' tooltip str The tooltip to use when hovering over the image. '' img_type Literal ['jpg', 'png'] Type of the image to create during saving. 'png' img_name str Name of the saved file (before hash if hash=True) 'plotnine_image' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"plotnine_image\" , use_hash : bool = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) image . save ( path , width = width , height = height , dpi = dpi , units = units , verbose = False , ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , ) Seaborn Bases: Matplotlib Source code in mkreports/md/image.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 @register_md ( \"Seaborn\" ) class Seaborn ( Matplotlib ): def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"seaborn_image\" , use_hash : bool = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( image . figure , page_info = page_info , width = width , height = height , units = units , dpi = dpi , link_type = link_type , text = text , tooltip = tooltip , img_type = img_type , img_name = img_name , use_hash = use_hash , ) __init__ ( image , page_info , width = None , height = None , units = 'in' , dpi = None , link_type = 'inline' , text = '' , tooltip = '' , img_type = 'png' , img_name = 'seaborn_image' , use_hash = True ) An image object for inclusion on a page. Parameters: Name Type Description Default image The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. required page_info PageInfo PageInfo for the page where the image should be included. required width Optional [ float ] width of the image None height Optional [ float ] height of the image None units Literal ['in', 'cm', 'mm'] units of the width and height 'in' dpi Optional [ float ] dpi of the image output. None link_type Literal ['inline', 'ref'] Link-type to be used. 'inline' text str The alternative text if the image is not available. '' tooltip str The tooltip to use when hovering over the image. '' img_type Literal ['jpg', 'png'] Type of the image to create during saving. 'png' img_name str Name of the saved file (before hash if hash=True) 'seaborn_image' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"seaborn_image\" , use_hash : bool = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( image . figure , page_info = page_info , width = width , height = height , units = units , dpi = dpi , link_type = link_type , text = text , tooltip = tooltip , img_type = img_type , img_name = img_name , use_hash = use_hash , )","title":"image"},{"location":"Reference/md/image/#mkreports.md.image.Altair","text":"Bases: File Include an Altair image. Source code in mkreports/md/image.py 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 @register_md ( \"Altair\" ) class Altair ( File ): \"\"\" Include an Altair image. \"\"\" def __init__ ( self , altair , page_info : PageInfo , csv_name : str = \"altair\" , use_hash : bool = True , ** kwargs , ): \"\"\" Create object to include an Altair image. Args: altair: An altair image. page_info (PageInfo): PageInfo to the page where it is to be included. csv_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { csv_name } .csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash , ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = page_info . idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ) self . _settings = settings","title":"Altair"},{"location":"Reference/md/image/#mkreports.md.image.Altair.__init__","text":"Create object to include an Altair image. Parameters: Name Type Description Default altair An altair image. required page_info PageInfo PageInfo to the page where it is to be included. required csv_name str Name of the saved file (before hash if hash=True) 'altair' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 def __init__ ( self , altair , page_info : PageInfo , csv_name : str = \"altair\" , use_hash : bool = True , ** kwargs , ): \"\"\" Create object to include an Altair image. Args: altair: An altair image. page_info (PageInfo): PageInfo to the page where it is to be included. csv_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { csv_name } .csv\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( altair . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash , ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter altair_id = page_info . idstore . next_id ( \"altair_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { altair_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> vegaEmbed(\"# { altair_id } \", \" { rel_spec_path } \") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.jsdelivr.net/npm/vega@5\" , \"https://cdn.jsdelivr.net/npm/vega-lite@5\" , \"https://cdn.jsdelivr.net/npm/vega-embed@6\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( altair_id ) self . _settings = settings","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.ImageFile","text":"Bases: File An image file. Source code in mkreports/md/image.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @register_md ( \"ImageFile\" ) class ImageFile ( File ): \"\"\"An image file.\"\"\" text : str tooltip : str link_type : str def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : \"\"\" Args: path (Union[str, Path]): Path to the image file. page_info (PageInfo): PageInfo object about the page. Added by page-wrapper link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Text shown if the image can't be displayed. tooltip (str): The tooltip shown when hovering over the image. allow_copy (bool): Should the image-file be copied to the store (Default: True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( path = path , page_info = page_info , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type # page_info needs to be set assert page_info . page_path is not None if self . link_type == \"inline\" : self . _body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_info . page_path . parent )), tooltip = self . tooltip , ) ) self . _back = None self . _settings = None elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" )","title":"ImageFile"},{"location":"Reference/md/image/#mkreports.md.image.ImageFile.__init__","text":"Parameters: Name Type Description Default path Union [ str , Path ] Path to the image file. required page_info PageInfo PageInfo object about the page. Added by page-wrapper required link_type Literal ['inline', 'ref'] Link-type to use. 'inline' text str Text shown if the image can't be displayed. '' tooltip str The tooltip shown when hovering over the image. '' allow_copy bool Should the image-file be copied to the store (Default: True) True use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def __init__ ( self , path : Union [ str , Path ], page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , allow_copy : bool = True , use_hash : bool = True , ) -> None : \"\"\" Args: path (Union[str, Path]): Path to the image file. page_info (PageInfo): PageInfo object about the page. Added by page-wrapper link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Text shown if the image can't be displayed. tooltip (str): The tooltip shown when hovering over the image. allow_copy (bool): Should the image-file be copied to the store (Default: True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( path = path , page_info = page_info , allow_copy = allow_copy , use_hash = use_hash ) self . text = text self . tooltip = tooltip self . link_type = link_type # page_info needs to be set assert page_info . page_path is not None if self . link_type == \"inline\" : self . _body = SpacedText ( UtilsImage . new_inline_image ( text = self . text , path = str ( relpath_html ( self . path , page_info . page_path . parent )), tooltip = self . tooltip , ) ) self . _back = None self . _settings = None elif type == \"ref\" : raise NotImplementedError () else : raise ValueError ( f \"Unknown type { self . link_type } \" )","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.Matplotlib","text":"Bases: ImageFile Source code in mkreports/md/image.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @register_md ( \"Matplotlib\" ) class Matplotlib ( ImageFile ): def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"matplotlib_image\" , use_hash = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) # for matplotlib # first we need to convert the units if given if width is not None or height is not None : if units != \"in\" : if units == \"cm\" : factor = 1 / 2.54 elif units == \"mm\" : factor = 1 / ( 10 * 2.54 ) else : raise ValueError ( f \"unit { units } not supported. Must be one of 'in', 'cm' or 'mm'.\" ) width = width * factor if width is not None else None height = height * factor if height is not None else None # if only one of the two is set, we infer the other if width is None and height is not None : old_width = image . get_figwidth () old_height = image . get_figheight () width = old_width * ( height / old_height ) elif width is not None and height is None : old_width = image . get_figwidth () old_height = image . get_figheight () height = old_height * ( width / old_width ) # now we set the new figure height, but on a copy of the figure image = deepcopy ( image ) image . set_size_inches ( w = width , h = height ) # save it image . savefig ( path , dpi = \"figure\" if dpi is None else dpi ) super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , )","title":"Matplotlib"},{"location":"Reference/md/image/#mkreports.md.image.Matplotlib.__init__","text":"An image object for inclusion on a page. Parameters: Name Type Description Default image The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. required page_info PageInfo PageInfo for the page where the image should be included. required width Optional [ float ] width of the image None height Optional [ float ] height of the image None units Literal ['in', 'cm', 'mm'] units of the width and height 'in' dpi Optional [ float ] dpi of the image output. None link_type Literal ['inline', 'ref'] Link-type to be used. 'inline' text str The alternative text if the image is not available. '' tooltip str The tooltip to use when hovering over the image. '' img_type Literal ['jpg', 'png'] Type of the image to create during saving. 'png' img_name str Name of the saved file (before hash if hash=True) 'matplotlib_image' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"matplotlib_image\" , use_hash = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) # for matplotlib # first we need to convert the units if given if width is not None or height is not None : if units != \"in\" : if units == \"cm\" : factor = 1 / 2.54 elif units == \"mm\" : factor = 1 / ( 10 * 2.54 ) else : raise ValueError ( f \"unit { units } not supported. Must be one of 'in', 'cm' or 'mm'.\" ) width = width * factor if width is not None else None height = height * factor if height is not None else None # if only one of the two is set, we infer the other if width is None and height is not None : old_width = image . get_figwidth () old_height = image . get_figheight () width = old_width * ( height / old_height ) elif width is not None and height is None : old_width = image . get_figwidth () old_height = image . get_figheight () height = old_height * ( width / old_width ) # now we set the new figure height, but on a copy of the figure image = deepcopy ( image ) image . set_size_inches ( w = width , h = height ) # save it image . savefig ( path , dpi = \"figure\" if dpi is None else dpi ) super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , )","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.PIL","text":"Bases: ImageFile A PIL image for inclusion. Source code in mkreports/md/image.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 @register_md ( \"PIL\" ) class PIL ( ImageFile ): \"\"\"A PIL image for inclusion.\"\"\" def __init__ ( self , image , page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"pil_image\" , use_hash : bool = True , ) -> None : \"\"\" Create MdObj for PIL image. Args: image (PIL.Image.Image): an Image object from PIL page_info (PageInfo): PageInfo for the page where the image is to be included. link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Alternative text for the image. tooltip (str): Tooltip when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): File-type to use when saving the image. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) image . save ( path ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , )","title":"PIL"},{"location":"Reference/md/image/#mkreports.md.image.PIL.__init__","text":"Create MdObj for PIL image. Parameters: Name Type Description Default image PIL . Image . Image an Image object from PIL required page_info PageInfo PageInfo for the page where the image is to be included. required link_type Literal ['inline', 'ref'] Link-type to use. 'inline' text str Alternative text for the image. '' tooltip str Tooltip when hovering over the image. '' img_type Literal ['jpg', 'png'] File-type to use when saving the image. 'png' img_name str Name of the saved file (before hash if hash=True) 'pil_image' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 def __init__ ( self , image , page_info : PageInfo , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"pil_image\" , use_hash : bool = True , ) -> None : \"\"\" Create MdObj for PIL image. Args: image (PIL.Image.Image): an Image object from PIL page_info (PageInfo): PageInfo for the page where the image is to be included. link_type (Literal[\"inline\", \"ref\"]): Link-type to use. text (str): Alternative text for the image. tooltip (str): Tooltip when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): File-type to use when saving the image. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) image . save ( path ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , )","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.Plotly","text":"Bases: File Plotly image as MdObj. Source code in mkreports/md/image.py 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 @register_md ( \"Plotly\" ) class Plotly ( File ): \"\"\" Plotly image as MdObj. \"\"\" def __init__ ( self , plotly , page_info : PageInfo , json_name : str = \"plotly\" , use_hash : bool = True , ** kwargs , ): \"\"\" Initialize the Plotly MdObj. Args: plotly (): The plotly graph to plot. page_info (PageInfo): PageInfo to the page where it is to be included. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = page_info . idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ) self . _settings = settings","title":"Plotly"},{"location":"Reference/md/image/#mkreports.md.image.Plotly.__init__","text":"Initialize the Plotly MdObj. Parameters: Name Type Description Default plotly The plotly graph to plot. required page_info PageInfo PageInfo to the page where it is to be included. required json_name str Name of the saved file (before hash if hash=True) 'plotly' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 def __init__ ( self , plotly , page_info : PageInfo , json_name : str = \"plotly\" , use_hash : bool = True , ** kwargs , ): \"\"\" Initialize the Plotly MdObj. Args: plotly (): The plotly graph to plot. page_info (PageInfo): PageInfo to the page where it is to be included. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . page_path is not None assert page_info . idstore is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need with path . open ( \"w\" ) as f : f . write ( plotly . to_json ( ** kwargs )) # Make sure the file is moved to the rigth place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) # note; in the body we just insert the div. # The reason is that this part can be indented, e.g. # inside a tab. But then <script> content can be escaped, leading to errors for '=>' # so the script tag itself gets done in the backmatter plotly_id = page_info . idstore . next_id ( \"plotly_id\" ) body_html = inspect . cleandoc ( f \"\"\" <div id=' { plotly_id } '> </div> \"\"\" ) rel_spec_path = str ( relpath_html ( self . path , page_info . page_path )) back_html = inspect . cleandoc ( f \"\"\" <script> fetch(' { rel_spec_path } ') .then(function (response) {{ return response.json(); }} ) .then(function (data) {{ doPlotly(data); }} ) .catch(function (err) {{ console.log('error: ' + err); }} ); function doPlotly(plotlyJson) {{ Plotly.newPlot(\" { plotly_id } \", {{ \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }} ) }} </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = [ \"https://cdn.plot.ly/plotly-2.8.3.min.js\" , ], ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( plotly_id ) self . _settings = settings","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.Plotnine","text":"Bases: ImageFile Source code in mkreports/md/image.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 @register_md ( \"Plotnine\" ) class Plotnine ( ImageFile ): def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"plotnine_image\" , use_hash : bool = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) image . save ( path , width = width , height = height , dpi = dpi , units = units , verbose = False , ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , )","title":"Plotnine"},{"location":"Reference/md/image/#mkreports.md.image.Plotnine.__init__","text":"An image object for inclusion on a page. Parameters: Name Type Description Default image The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. required page_info PageInfo PageInfo for the page where the image should be included. required width Optional [ float ] width of the image None height Optional [ float ] height of the image None units Literal ['in', 'cm', 'mm'] units of the width and height 'in' dpi Optional [ float ] dpi of the image output. None link_type Literal ['inline', 'ref'] Link-type to be used. 'inline' text str The alternative text if the image is not available. '' tooltip str The tooltip to use when hovering over the image. '' img_type Literal ['jpg', 'png'] Type of the image to create during saving. 'png' img_name str Name of the saved file (before hash if hash=True) 'plotnine_image' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"plotnine_image\" , use_hash : bool = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { img_name } . { img_type } \" ) image . save ( path , width = width , height = height , dpi = dpi , units = units , verbose = False , ) # now we create the ImageFile object # which will also move it into the store super () . __init__ ( path = path , page_info = page_info , link_type = link_type , text = text , tooltip = tooltip , allow_copy = True , use_hash = use_hash , )","title":"__init__()"},{"location":"Reference/md/image/#mkreports.md.image.Seaborn","text":"Bases: Matplotlib Source code in mkreports/md/image.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 @register_md ( \"Seaborn\" ) class Seaborn ( Matplotlib ): def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"seaborn_image\" , use_hash : bool = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( image . figure , page_info = page_info , width = width , height = height , units = units , dpi = dpi , link_type = link_type , text = text , tooltip = tooltip , img_type = img_type , img_name = img_name , use_hash = use_hash , )","title":"Seaborn"},{"location":"Reference/md/image/#mkreports.md.image.Seaborn.__init__","text":"An image object for inclusion on a page. Parameters: Name Type Description Default image The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. required page_info PageInfo PageInfo for the page where the image should be included. required width Optional [ float ] width of the image None height Optional [ float ] height of the image None units Literal ['in', 'cm', 'mm'] units of the width and height 'in' dpi Optional [ float ] dpi of the image output. None link_type Literal ['inline', 'ref'] Link-type to be used. 'inline' text str The alternative text if the image is not available. '' tooltip str The tooltip to use when hovering over the image. '' img_type Literal ['jpg', 'png'] Type of the image to create during saving. 'png' img_name str Name of the saved file (before hash if hash=True) 'seaborn_image' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/image.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def __init__ ( self , image , page_info : PageInfo , width : Optional [ float ] = None , height : Optional [ float ] = None , units : Literal [ \"in\" , \"cm\" , \"mm\" ] = \"in\" , dpi : Optional [ float ] = None , link_type : Literal [ \"inline\" , \"ref\" ] = \"inline\" , text : str = \"\" , tooltip : str = \"\" , img_type : Literal [ \"jpg\" , \"png\" ] = \"png\" , img_name : str = \"seaborn_image\" , use_hash : bool = True , ) -> None : \"\"\" An image object for inclusion on a page. Args: image: The image to be included. Has to be supported by one of the handlers, which are Matplotlib, plotnine and seaborn. page_info (PageInfo): PageInfo for the page where the image should be included. width (Optional[float]): width of the image height (Optional[float]): height of the image units (Literal[\"in\", \"cm\", \"mm\"]): units of the width and height dpi (Optional[float]): dpi of the image output. link_type (Literal[\"inline\", \"ref\"]): Link-type to be used. text (str): The alternative text if the image is not available. tooltip (str): The tooltip to use when hovering over the image. img_type (Literal[\"jpg\", \"png\"]): Type of the image to create during saving. img_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" super () . __init__ ( image . figure , page_info = page_info , width = width , height = height , units = units , dpi = dpi , link_type = link_type , text = text , tooltip = tooltip , img_type = img_type , img_name = img_name , use_hash = use_hash , )","title":"__init__()"},{"location":"Reference/md/list/","text":"List Bases: MdObj Markdown list. Source code in mkreports/md/list.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @register_md ( \"List\" ) class List ( MdObj ): \"\"\" Markdown list. \"\"\" marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] list : MdSeq def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): \"\"\" Initialize the list as a markdown object. Args: items (Union[str, Iterable[Union[MdObj, str]]]): List of items in the list. marker (Literal[\"-\", \"*\", \"+\", \"1\"]): Marker to use for the list. \"\"\" super () . __init__ () self . list = MdSeq ( items ) self . marker = marker # create the markdown output for every item; indent it appropriately # and then put it all together. # create the body # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( self . num_items )] else : prefix = [ f \" { self . marker } \" ] * self . num_items md_list = [ _indent_hanging ( elem . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] self . _body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) self . _back = self . list . back self . _settings = self . list . settings def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : \"\"\" Append an item. This returns a new list, does not append to the old. Args: item (Union[Text, MdObj]): The item to append to the list. Returns: List: A list object with the new item appended. \"\"\" if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : \"\"\" Extend the list by additional items. The old list will not be updated. A new one will be created. Args: items (Sequence[Union[Text, MdObj]]): The items with which to extend the list. Returns: List: A new list object \"\"\" items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) @property def num_items ( self ) -> int : \"\"\" Number of items in the list. Returns: int: Number of items in the list. \"\"\" return len ( self . list ) __init__ ( items = (), marker = '-' ) Initialize the list as a markdown object. Parameters: Name Type Description Default items Union [ str , Iterable [ Union [ MdObj , str ]]] List of items in the list. () marker Literal ['-', '*', '+', '1'] Marker to use for the list. '-' Source code in mkreports/md/list.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): \"\"\" Initialize the list as a markdown object. Args: items (Union[str, Iterable[Union[MdObj, str]]]): List of items in the list. marker (Literal[\"-\", \"*\", \"+\", \"1\"]): Marker to use for the list. \"\"\" super () . __init__ () self . list = MdSeq ( items ) self . marker = marker # create the markdown output for every item; indent it appropriately # and then put it all together. # create the body # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( self . num_items )] else : prefix = [ f \" { self . marker } \" ] * self . num_items md_list = [ _indent_hanging ( elem . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] self . _body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) self . _back = self . list . back self . _settings = self . list . settings append ( item ) Append an item. This returns a new list, does not append to the old. Parameters: Name Type Description Default item Union [ Text , MdObj ] The item to append to the list. required Returns: Name Type Description List 'List' A list object with the new item appended. Source code in mkreports/md/list.py 63 64 65 66 67 68 69 70 71 72 73 74 75 def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : \"\"\" Append an item. This returns a new list, does not append to the old. Args: item (Union[Text, MdObj]): The item to append to the list. Returns: List: A list object with the new item appended. \"\"\" if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) extend ( items ) Extend the list by additional items. The old list will not be updated. A new one will be created. Parameters: Name Type Description Default items Sequence [ Union [ Text , MdObj ]] The items with which to extend the list. required Returns: Name Type Description List 'List' A new list object Source code in mkreports/md/list.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : \"\"\" Extend the list by additional items. The old list will not be updated. A new one will be created. Args: items (Sequence[Union[Text, MdObj]]): The items with which to extend the list. Returns: List: A new list object \"\"\" items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) num_items () Number of items in the list. Returns: Name Type Description int int Number of items in the list. Source code in mkreports/md/list.py 98 99 100 101 102 103 104 105 106 @property def num_items ( self ) -> int : \"\"\" Number of items in the list. Returns: int: Number of items in the list. \"\"\" return len ( self . list )","title":"list"},{"location":"Reference/md/list/#mkreports.md.list.List","text":"Bases: MdObj Markdown list. Source code in mkreports/md/list.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 @register_md ( \"List\" ) class List ( MdObj ): \"\"\" Markdown list. \"\"\" marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] list : MdSeq def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): \"\"\" Initialize the list as a markdown object. Args: items (Union[str, Iterable[Union[MdObj, str]]]): List of items in the list. marker (Literal[\"-\", \"*\", \"+\", \"1\"]): Marker to use for the list. \"\"\" super () . __init__ () self . list = MdSeq ( items ) self . marker = marker # create the markdown output for every item; indent it appropriately # and then put it all together. # create the body # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( self . num_items )] else : prefix = [ f \" { self . marker } \" ] * self . num_items md_list = [ _indent_hanging ( elem . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] self . _body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) self . _back = self . list . back self . _settings = self . list . settings def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : \"\"\" Append an item. This returns a new list, does not append to the old. Args: item (Union[Text, MdObj]): The item to append to the list. Returns: List: A list object with the new item appended. \"\"\" if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker ) def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : \"\"\" Extend the list by additional items. The old list will not be updated. A new one will be created. Args: items (Sequence[Union[Text, MdObj]]): The items with which to extend the list. Returns: List: A new list object \"\"\" items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker ) @property def num_items ( self ) -> int : \"\"\" Number of items in the list. Returns: int: Number of items in the list. \"\"\" return len ( self . list )","title":"List"},{"location":"Reference/md/list/#mkreports.md.list.List.__init__","text":"Initialize the list as a markdown object. Parameters: Name Type Description Default items Union [ str , Iterable [ Union [ MdObj , str ]]] List of items in the list. () marker Literal ['-', '*', '+', '1'] Marker to use for the list. '-' Source code in mkreports/md/list.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , items : Union [ str , Iterable [ Union [ MdObj , str ]]] = (), marker : Literal [ \"-\" , \"*\" , \"+\" , \"1\" ] = \"-\" , ): \"\"\" Initialize the list as a markdown object. Args: items (Union[str, Iterable[Union[MdObj, str]]]): List of items in the list. marker (Literal[\"-\", \"*\", \"+\", \"1\"]): Marker to use for the list. \"\"\" super () . __init__ () self . list = MdSeq ( items ) self . marker = marker # create the markdown output for every item; indent it appropriately # and then put it all together. # create the body # now we need to attach the right element at the beginning if self . marker == \"1\" : prefix = [ f \" { i } . \" for i in range ( self . num_items )] else : prefix = [ f \" { self . marker } \" ] * self . num_items md_list = [ _indent_hanging ( elem . body . text , hanging = prefix ) for elem , prefix in zip ( self . list . items , prefix ) ] self . _body = SpacedText ( \" \\n \" . join ( md_list ), ( 2 , 2 )) self . _back = self . list . back self . _settings = self . list . settings","title":"__init__()"},{"location":"Reference/md/list/#mkreports.md.list.List.append","text":"Append an item. This returns a new list, does not append to the old. Parameters: Name Type Description Default item Union [ Text , MdObj ] The item to append to the list. required Returns: Name Type Description List 'List' A list object with the new item appended. Source code in mkreports/md/list.py 63 64 65 66 67 68 69 70 71 72 73 74 75 def append ( self , item : Union [ Text , MdObj ]) -> \"List\" : \"\"\" Append an item. This returns a new list, does not append to the old. Args: item (Union[Text, MdObj]): The item to append to the list. Returns: List: A list object with the new item appended. \"\"\" if isinstance ( item , ( str , SpacedText )): item = Raw ( item ) return List ( self . list . items + ( item ,), marker = self . marker )","title":"append()"},{"location":"Reference/md/list/#mkreports.md.list.List.extend","text":"Extend the list by additional items. The old list will not be updated. A new one will be created. Parameters: Name Type Description Default items Sequence [ Union [ Text , MdObj ]] The items with which to extend the list. required Returns: Name Type Description List 'List' A new list object Source code in mkreports/md/list.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def extend ( self , items : Sequence [ Union [ Text , MdObj ]]) -> \"List\" : \"\"\" Extend the list by additional items. The old list will not be updated. A new one will be created. Args: items (Sequence[Union[Text, MdObj]]): The items with which to extend the list. Returns: List: A new list object \"\"\" items = tuple ( [ Raw ( item ) if isinstance ( item , ( str , SpacedText )) else item for item in items ] ) return List ( self . list . items + items , marker = self . marker )","title":"extend()"},{"location":"Reference/md/list/#mkreports.md.list.List.num_items","text":"Number of items in the list. Returns: Name Type Description int int Number of items in the list. Source code in mkreports/md/list.py 98 99 100 101 102 103 104 105 106 @property def num_items ( self ) -> int : \"\"\" Number of items in the list. Returns: int: Number of items in the list. \"\"\" return len ( self . list )","title":"num_items()"},{"location":"Reference/md/md_proxy/","text":"MdProxy Proxies the MdObj objects Makes the MdObj available with PageInfo prefilled. Source code in mkreports/md/md_proxy.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class MdProxy : \"\"\" Proxies the MdObj objects Makes the MdObj available with PageInfo prefilled. \"\"\" _proxied_classes : Dict [ str , Any ] = dict () def __init__ ( self , page_info : PageInfo , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ): \"\"\" Initialize the proxy. Args: page_info (PageInfo): The info of the page for which the proxy works. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" self . page_info = page_info self . md_defaults = md_defaults if md_defaults is not None else {} def __getattr__ ( self , name ): # we are not checking if it is included; if not, should raise error if name in self . _proxied_classes : obj = self . _proxied_classes [ name ] else : raise AttributeError ( f \"No MdObj of name ' { name } ' registered\" ) # if is a class; try to fix the init method if inspect . isclass ( obj ): # check the init method signature partial_kwargs = {} obj_sig = inspect . signature ( obj ) if \"page_info\" in obj_sig . parameters : partial_kwargs [ \"page_info\" ] = self . page_info # check if there are defaults for the md-object if name in self . md_defaults : partial_kwargs . update ( self . md_defaults [ name ]) if len ( partial_kwargs ) > 0 : partial_obj = partial ( obj , ** partial_kwargs ) update_wrapper ( partial_obj , obj ) partial_obj . __doc__ = obj . __init__ . __doc__ return partial_obj else : return obj else : return obj @property def proxied_classes ( self ) -> Dict [ str , Any ]: \"\"\" Returns: Dict[str, Any]: A dict with the registered items under their name. \"\"\" return self . _proxied_classes def __eq__ ( self , other ): if type ( self ) != type ( other ): return False return self . __dict__ == other . __dict__ __init__ ( page_info , md_defaults = None ) Initialize the proxy. Parameters: Name Type Description Default page_info PageInfo The info of the page for which the proxy works. required md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None Source code in mkreports/md/md_proxy.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , page_info : PageInfo , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ): \"\"\" Initialize the proxy. Args: page_info (PageInfo): The info of the page for which the proxy works. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" self . page_info = page_info self . md_defaults = md_defaults if md_defaults is not None else {} proxied_classes () Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dict with the registered items under their name. Source code in mkreports/md/md_proxy.py 72 73 74 75 76 77 78 @property def proxied_classes ( self ) -> Dict [ str , Any ]: \"\"\" Returns: Dict[str, Any]: A dict with the registered items under their name. \"\"\" return self . _proxied_classes","title":"md_proxy"},{"location":"Reference/md/md_proxy/#mkreports.md.md_proxy.MdProxy","text":"Proxies the MdObj objects Makes the MdObj available with PageInfo prefilled. Source code in mkreports/md/md_proxy.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class MdProxy : \"\"\" Proxies the MdObj objects Makes the MdObj available with PageInfo prefilled. \"\"\" _proxied_classes : Dict [ str , Any ] = dict () def __init__ ( self , page_info : PageInfo , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ): \"\"\" Initialize the proxy. Args: page_info (PageInfo): The info of the page for which the proxy works. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" self . page_info = page_info self . md_defaults = md_defaults if md_defaults is not None else {} def __getattr__ ( self , name ): # we are not checking if it is included; if not, should raise error if name in self . _proxied_classes : obj = self . _proxied_classes [ name ] else : raise AttributeError ( f \"No MdObj of name ' { name } ' registered\" ) # if is a class; try to fix the init method if inspect . isclass ( obj ): # check the init method signature partial_kwargs = {} obj_sig = inspect . signature ( obj ) if \"page_info\" in obj_sig . parameters : partial_kwargs [ \"page_info\" ] = self . page_info # check if there are defaults for the md-object if name in self . md_defaults : partial_kwargs . update ( self . md_defaults [ name ]) if len ( partial_kwargs ) > 0 : partial_obj = partial ( obj , ** partial_kwargs ) update_wrapper ( partial_obj , obj ) partial_obj . __doc__ = obj . __init__ . __doc__ return partial_obj else : return obj else : return obj @property def proxied_classes ( self ) -> Dict [ str , Any ]: \"\"\" Returns: Dict[str, Any]: A dict with the registered items under their name. \"\"\" return self . _proxied_classes def __eq__ ( self , other ): if type ( self ) != type ( other ): return False return self . __dict__ == other . __dict__","title":"MdProxy"},{"location":"Reference/md/md_proxy/#mkreports.md.md_proxy.MdProxy.__init__","text":"Initialize the proxy. Parameters: Name Type Description Default page_info PageInfo The info of the page for which the proxy works. required md_defaults Optional[Dict[str, Dict[str, Any]] A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. None Source code in mkreports/md/md_proxy.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , page_info : PageInfo , md_defaults : Optional [ Dict [ str , Dict [ str , Any ]]] = None , ): \"\"\" Initialize the proxy. Args: page_info (PageInfo): The info of the page for which the proxy works. md_defaults (Optional[Dict[str, Dict[str, Any]]): A dictionary mapping the names md objects (accessed from the proxy) to default keywords included when they are being called. \"\"\" self . page_info = page_info self . md_defaults = md_defaults if md_defaults is not None else {}","title":"__init__()"},{"location":"Reference/md/md_proxy/#mkreports.md.md_proxy.MdProxy.proxied_classes","text":"Returns: Type Description Dict [ str , Any ] Dict[str, Any]: A dict with the registered items under their name. Source code in mkreports/md/md_proxy.py 72 73 74 75 76 77 78 @property def proxied_classes ( self ) -> Dict [ str , Any ]: \"\"\" Returns: Dict[str, Any]: A dict with the registered items under their name. \"\"\" return self . _proxied_classes","title":"proxied_classes()"},{"location":"Reference/md/settings/","text":"Settings Source code in mkreports/md/settings.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @dataclass class Settings : mkdocs : Dict [ str , Any ] = field ( default_factory = dict ) page : Dict [ str , Any ] = field ( default_factory = dict ) def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), ) __add__ ( other ) Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. Source code in mkreports/md/settings.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), ) strategy_append_new ( config , path , base , nxt ) prepend nxt to base. Source code in mkreports/md/settings.py 41 42 43 44 def strategy_append_new ( config , path , base , nxt ): \"\"\"prepend nxt to base.\"\"\" del config , path return base + [ x for x in nxt if x not in base ]","title":"settings"},{"location":"Reference/md/settings/#mkreports.md.settings.Settings","text":"Source code in mkreports/md/settings.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @dataclass class Settings : mkdocs : Dict [ str , Any ] = field ( default_factory = dict ) page : Dict [ str , Any ] = field ( default_factory = dict ) def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), )","title":"Settings"},{"location":"Reference/md/settings/#mkreports.md.settings.Settings.__add__","text":"Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. Source code in mkreports/md/settings.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def __add__ ( self , other : \"Settings\" ): \"\"\" Merges mkdocs and mkreports. For mkdocs, nav will never be merged and an error thrown if attempted. \"\"\" if \"nav\" in self . mkdocs and \"nav\" in other . mkdocs : raise ValueError ( \"Merging of Requirements with 'nav' in mkdocs not supported.\" ) return Settings ( mkdocs = merge_settings ( self . mkdocs , other . mkdocs ), page = merge_settings ( self . page , other . page ), )","title":"__add__()"},{"location":"Reference/md/settings/#mkreports.md.settings.strategy_append_new","text":"prepend nxt to base. Source code in mkreports/md/settings.py 41 42 43 44 def strategy_append_new ( config , path , base , nxt ): \"\"\"prepend nxt to base.\"\"\" del config , path return base + [ x for x in nxt if x not in base ]","title":"strategy_append_new()"},{"location":"Reference/md/table/","text":"DataTable Bases: File Table using DataTable javascript library. Source code in mkreports/md/table.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @register_md ( \"DataTable\" ) class DataTable ( File ): \"\"\"Table using DataTable javascript library.\"\"\" def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , column_settings : Optional [ dict ] = None , prettify_colnames : bool = True , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , table_kwargs : Optional [ dict ] = None , downloads : bool = False , table_settings : Optional [ dict ] = None , json_name : str = \"datatable\" , use_hash : bool = True , ): \"\"\" Initialize the table using the DataTable javascript library. Args: table (pd.DataFrame): The table in pandas.DataFrame format. page_info (PageInfo): PageInfo object for the page where the table should be located. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. column_settings (Optional[dict]): Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. prettify_colnames (bool): Run colnames through 'snake_to_text' function. add_header_filters (bool): Should header filters be added. yadcf_settings (Optional[dict]): Settings for the *yadcf* header filter plugin. Overrides any automatic settings. table_kwargs (Optional[dict]): Keyword args for the table when serializing to json. downloads (bool): Should download buttons be shown? table_settings (Optional[dict]): Dictionary with the DataTable settings. Anything set here will overwrite existing ones. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** ( table_kwargs if table_kwargs is not None else {}), ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) javascript_settings = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ] css_settings = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ] # prepare the table settings if prettify_colnames : col_set = { col : { \"title\" : snake_to_text ( col ) if isinstance ( col , str ) else col } for col in table . columns } else : col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = _create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } if downloads : self . table_settings [ \"buttons\" ] = [ \"copy\" , \"csv\" , \"excel\" , \"pdf\" , \"print\" ] # self.table_settings[\"dom\"] = \"Bfrtlp\" self . table_settings [ \"dom\" ] = \"<lfr>t<Bp>\" css_settings . append ( \"https://cdn.datatables.net/buttons/2.2.2/css/buttons.dataTables.min.css\" ) javascript_settings . extend ( [ \"https://cdn.datatables.net/buttons/2.2.2/js/dataTables.buttons.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.3/jszip.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/pdfmake.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/vfs_fonts.js\" , \"https://cdn.datatables.net/buttons/2.2.2/js/buttons.html5.min.js\" , \"https://cdn.datatables.net/buttons/2.2.2/js/buttons.print.min.js\" , ] ) datatable_id = page_info . idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) self . table_settings [ \"ajax\" ] = str ( rel_table_path ) # overwrite with given settigns if necessary self . table_settings . update ( table_settings if table_settings is not None else {}) settings_str = serialize_json ( self . table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = javascript_settings , css = css_settings , ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ) self . _settings = settings __init__ ( table , page_info , max_rows = 1000 , column_settings = None , prettify_colnames = True , add_header_filters = False , yadcf_settings = None , table_kwargs = None , downloads = False , table_settings = None , json_name = 'datatable' , use_hash = True ) Initialize the table using the DataTable javascript library. Parameters: Name Type Description Default table pd . DataFrame The table in pandas.DataFrame format. required page_info PageInfo PageInfo object for the page where the table should be located. required max_rows Optional [ int ] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 1000 column_settings Optional [ dict ] Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. None prettify_colnames bool Run colnames through 'snake_to_text' function. True add_header_filters bool Should header filters be added. False yadcf_settings Optional [ dict ] Settings for the yadcf header filter plugin. Overrides any automatic settings. None table_kwargs Optional [ dict ] Keyword args for the table when serializing to json. None downloads bool Should download buttons be shown? False table_settings Optional [ dict ] Dictionary with the DataTable settings. Anything set here will overwrite existing ones. None json_name str Name of the saved file (before hash if hash=True) 'datatable' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/table.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , column_settings : Optional [ dict ] = None , prettify_colnames : bool = True , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , table_kwargs : Optional [ dict ] = None , downloads : bool = False , table_settings : Optional [ dict ] = None , json_name : str = \"datatable\" , use_hash : bool = True , ): \"\"\" Initialize the table using the DataTable javascript library. Args: table (pd.DataFrame): The table in pandas.DataFrame format. page_info (PageInfo): PageInfo object for the page where the table should be located. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. column_settings (Optional[dict]): Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. prettify_colnames (bool): Run colnames through 'snake_to_text' function. add_header_filters (bool): Should header filters be added. yadcf_settings (Optional[dict]): Settings for the *yadcf* header filter plugin. Overrides any automatic settings. table_kwargs (Optional[dict]): Keyword args for the table when serializing to json. downloads (bool): Should download buttons be shown? table_settings (Optional[dict]): Dictionary with the DataTable settings. Anything set here will overwrite existing ones. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** ( table_kwargs if table_kwargs is not None else {}), ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) javascript_settings = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ] css_settings = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ] # prepare the table settings if prettify_colnames : col_set = { col : { \"title\" : snake_to_text ( col ) if isinstance ( col , str ) else col } for col in table . columns } else : col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = _create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } if downloads : self . table_settings [ \"buttons\" ] = [ \"copy\" , \"csv\" , \"excel\" , \"pdf\" , \"print\" ] # self.table_settings[\"dom\"] = \"Bfrtlp\" self . table_settings [ \"dom\" ] = \"<lfr>t<Bp>\" css_settings . append ( \"https://cdn.datatables.net/buttons/2.2.2/css/buttons.dataTables.min.css\" ) javascript_settings . extend ( [ \"https://cdn.datatables.net/buttons/2.2.2/js/dataTables.buttons.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.3/jszip.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/pdfmake.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/vfs_fonts.js\" , \"https://cdn.datatables.net/buttons/2.2.2/js/buttons.html5.min.js\" , \"https://cdn.datatables.net/buttons/2.2.2/js/buttons.print.min.js\" , ] ) datatable_id = page_info . idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) self . table_settings [ \"ajax\" ] = str ( rel_table_path ) # overwrite with given settigns if necessary self . table_settings . update ( table_settings if table_settings is not None else {}) settings_str = serialize_json ( self . table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = javascript_settings , css = css_settings , ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ) self . _settings = settings Table Bases: MdObj Standard markdown table. Source code in mkreports/md/table.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @register_md ( \"Table\" ) class Table ( MdObj ): \"\"\"Standard markdown table.\"\"\" table : pd . DataFrame kwargs : Dict [ str , Any ] def __init__ ( self , table : pd . DataFrame , max_rows : Optional [ int ] = 100 , ** kwargs ): \"\"\" Initialize the table object. Args: table (pd.DataFrame): The table to include in pandas format. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. \"\"\" super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) # check if the table has too many rows if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) self . table = self . table . iloc [ 0 : max_rows ] table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" self . _body = SpacedText ( table_md , ( 2 , 2 )) self . _back = None self . _settings = None __init__ ( table , max_rows = 100 , ** kwargs ) Initialize the table object. Parameters: Name Type Description Default table pd . DataFrame The table to include in pandas format. required max_rows Optional [ int ] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 100 Source code in mkreports/md/table.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , table : pd . DataFrame , max_rows : Optional [ int ] = 100 , ** kwargs ): \"\"\" Initialize the table object. Args: table (pd.DataFrame): The table to include in pandas format. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. \"\"\" super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) # check if the table has too many rows if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) self . table = self . table . iloc [ 0 : max_rows ] table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" self . _body = SpacedText ( table_md , ( 2 , 2 )) self . _back = None self . _settings = None Tabulator Bases: File A table using the Tabulator javascript library. Source code in mkreports/md/table.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 @register_md ( \"Tabulator\" ) class Tabulator ( File ): \"\"\"A table using the Tabulator javascript library.\"\"\" def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , downloads : bool = False , table_kwargs : Optional [ dict ] = None , json_name : str = \"tabulator\" , use_hash : bool = True , ): \"\"\" Args: table (pd.DataFrame): The table to be added. page_info (PageInfo): PageInfo for the page where the table should be added. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. table_settings (Optional[dict]): Settings passed to Tabulator as json. Overrides any internal settings created by this function. add_header_filters (bool): Should header-filters be added. prettify_colnames (bool): Run column names through *snake_to_text*. col_settings (Optional[dict]): Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. downloads (bool): Add download options. table_kwargs (Optional[dict]): Keyword args for the table when serializing to json. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None assert page_info . javascript_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] table . to_json ( path , orient = \"records\" , default_handler = str , ** ( table_kwargs if table_kwargs is not None else {}), ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) # produce the column settings col_list = _create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list used_ids = [] used_ids . append ( tabulator_id := page_info . idstore . next_id ( \"tabulator_id\" )) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) javascript_settings = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , ] css_settings = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ] if add_header_filters : javascript_settings . append ( store_asset_relpath ( Path ( \"min_max_filter.js\" ), page_info ) ) if downloads : # add the necessary things to enable downloads # to the body used_ids . append ( csv_down_id := page_info . idstore . next_id ( \"csv_down_id\" )) used_ids . append ( json_down_id := page_info . idstore . next_id ( \"json_down_id\" )) used_ids . append ( xlsx_down_id := page_info . idstore . next_id ( \"xslx_down_id\" )) body_html = body_html + inspect . cleandoc ( f \"\"\" <div> <button class=\"tabulator-btn-dwn\", id=\" { csv_down_id } \">to CSV</button> <button class=\"tabulator-btn-dwn\", id=\" { json_down_id } \">to JSON</button> <button class=\"tabulator-btn-dwn\", id=\" { xlsx_down_id } \">to XLSX</button> </div> \"\"\" ) # to the back_html split_back_html = back_html . split ( \" \\n \" ) split_back_html . insert ( - 1 , inspect . cleandoc ( f \"\"\" //trigger download of data.csv file $(\"# { csv_down_id } \").click(function() {{ table.download(\"csv\", \"data.csv\"); }} ); //trigger download of data.json file $(\"# { json_down_id } \").click(function() {{ table.download(\"json\", \"data.json\"); }} ); //trigger download of data.xlsx file $(\"# { xlsx_down_id } \").click(function() {{ table.download(\"xlsx\", \"data.xlsx\", {{ sheetName:\"data\" }} ); }} ); \"\"\" ), ) back_html = \" \\n \" . join ( split_back_html ) # to the settings javascript_settings . append ( \"https://oss.sheetjs.com/sheetjs/xlsx.full.min.js\" ) css_settings . append ( store_asset_relpath ( Path ( \"download_buttons.css\" ), page_info ) ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = javascript_settings , css = css_settings , ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + \" \\n \" . join ( [ str ( comment_ids ( this_id )) for this_id in used_ids ] ) self . _settings = settings __init__ ( table , page_info , max_rows = 1000 , table_settings = None , add_header_filters = True , prettify_colnames = True , col_settings = None , downloads = False , table_kwargs = None , json_name = 'tabulator' , use_hash = True ) Parameters: Name Type Description Default table pd . DataFrame The table to be added. required page_info PageInfo PageInfo for the page where the table should be added. required max_rows Optional [ int ] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 1000 table_settings Optional [ dict ] Settings passed to Tabulator as json. Overrides any internal settings created by this function. None add_header_filters bool Should header-filters be added. True prettify_colnames bool Run column names through snake_to_text . True col_settings Optional [ dict ] Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. None downloads bool Add download options. False table_kwargs Optional [ dict ] Keyword args for the table when serializing to json. None json_name str Name of the saved file (before hash if hash=True) 'tabulator' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/table.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , downloads : bool = False , table_kwargs : Optional [ dict ] = None , json_name : str = \"tabulator\" , use_hash : bool = True , ): \"\"\" Args: table (pd.DataFrame): The table to be added. page_info (PageInfo): PageInfo for the page where the table should be added. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. table_settings (Optional[dict]): Settings passed to Tabulator as json. Overrides any internal settings created by this function. add_header_filters (bool): Should header-filters be added. prettify_colnames (bool): Run column names through *snake_to_text*. col_settings (Optional[dict]): Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. downloads (bool): Add download options. table_kwargs (Optional[dict]): Keyword args for the table when serializing to json. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None assert page_info . javascript_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] table . to_json ( path , orient = \"records\" , default_handler = str , ** ( table_kwargs if table_kwargs is not None else {}), ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) # produce the column settings col_list = _create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list used_ids = [] used_ids . append ( tabulator_id := page_info . idstore . next_id ( \"tabulator_id\" )) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) javascript_settings = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , ] css_settings = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ] if add_header_filters : javascript_settings . append ( store_asset_relpath ( Path ( \"min_max_filter.js\" ), page_info ) ) if downloads : # add the necessary things to enable downloads # to the body used_ids . append ( csv_down_id := page_info . idstore . next_id ( \"csv_down_id\" )) used_ids . append ( json_down_id := page_info . idstore . next_id ( \"json_down_id\" )) used_ids . append ( xlsx_down_id := page_info . idstore . next_id ( \"xslx_down_id\" )) body_html = body_html + inspect . cleandoc ( f \"\"\" <div> <button class=\"tabulator-btn-dwn\", id=\" { csv_down_id } \">to CSV</button> <button class=\"tabulator-btn-dwn\", id=\" { json_down_id } \">to JSON</button> <button class=\"tabulator-btn-dwn\", id=\" { xlsx_down_id } \">to XLSX</button> </div> \"\"\" ) # to the back_html split_back_html = back_html . split ( \" \\n \" ) split_back_html . insert ( - 1 , inspect . cleandoc ( f \"\"\" //trigger download of data.csv file $(\"# { csv_down_id } \").click(function() {{ table.download(\"csv\", \"data.csv\"); }} ); //trigger download of data.json file $(\"# { json_down_id } \").click(function() {{ table.download(\"json\", \"data.json\"); }} ); //trigger download of data.xlsx file $(\"# { xlsx_down_id } \").click(function() {{ table.download(\"xlsx\", \"data.xlsx\", {{ sheetName:\"data\" }} ); }} ); \"\"\" ), ) back_html = \" \\n \" . join ( split_back_html ) # to the settings javascript_settings . append ( \"https://oss.sheetjs.com/sheetjs/xlsx.full.min.js\" ) css_settings . append ( store_asset_relpath ( Path ( \"download_buttons.css\" ), page_info ) ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = javascript_settings , css = css_settings , ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + \" \\n \" . join ( [ str ( comment_ids ( this_id )) for this_id in used_ids ] ) self . _settings = settings","title":"table"},{"location":"Reference/md/table/#mkreports.md.table.DataTable","text":"Bases: File Table using DataTable javascript library. Source code in mkreports/md/table.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 @register_md ( \"DataTable\" ) class DataTable ( File ): \"\"\"Table using DataTable javascript library.\"\"\" def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , column_settings : Optional [ dict ] = None , prettify_colnames : bool = True , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , table_kwargs : Optional [ dict ] = None , downloads : bool = False , table_settings : Optional [ dict ] = None , json_name : str = \"datatable\" , use_hash : bool = True , ): \"\"\" Initialize the table using the DataTable javascript library. Args: table (pd.DataFrame): The table in pandas.DataFrame format. page_info (PageInfo): PageInfo object for the page where the table should be located. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. column_settings (Optional[dict]): Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. prettify_colnames (bool): Run colnames through 'snake_to_text' function. add_header_filters (bool): Should header filters be added. yadcf_settings (Optional[dict]): Settings for the *yadcf* header filter plugin. Overrides any automatic settings. table_kwargs (Optional[dict]): Keyword args for the table when serializing to json. downloads (bool): Should download buttons be shown? table_settings (Optional[dict]): Dictionary with the DataTable settings. Anything set here will overwrite existing ones. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** ( table_kwargs if table_kwargs is not None else {}), ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) javascript_settings = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ] css_settings = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ] # prepare the table settings if prettify_colnames : col_set = { col : { \"title\" : snake_to_text ( col ) if isinstance ( col , str ) else col } for col in table . columns } else : col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = _create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } if downloads : self . table_settings [ \"buttons\" ] = [ \"copy\" , \"csv\" , \"excel\" , \"pdf\" , \"print\" ] # self.table_settings[\"dom\"] = \"Bfrtlp\" self . table_settings [ \"dom\" ] = \"<lfr>t<Bp>\" css_settings . append ( \"https://cdn.datatables.net/buttons/2.2.2/css/buttons.dataTables.min.css\" ) javascript_settings . extend ( [ \"https://cdn.datatables.net/buttons/2.2.2/js/dataTables.buttons.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.3/jszip.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/pdfmake.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/vfs_fonts.js\" , \"https://cdn.datatables.net/buttons/2.2.2/js/buttons.html5.min.js\" , \"https://cdn.datatables.net/buttons/2.2.2/js/buttons.print.min.js\" , ] ) datatable_id = page_info . idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) self . table_settings [ \"ajax\" ] = str ( rel_table_path ) # overwrite with given settigns if necessary self . table_settings . update ( table_settings if table_settings is not None else {}) settings_str = serialize_json ( self . table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = javascript_settings , css = css_settings , ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ) self . _settings = settings","title":"DataTable"},{"location":"Reference/md/table/#mkreports.md.table.DataTable.__init__","text":"Initialize the table using the DataTable javascript library. Parameters: Name Type Description Default table pd . DataFrame The table in pandas.DataFrame format. required page_info PageInfo PageInfo object for the page where the table should be located. required max_rows Optional [ int ] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 1000 column_settings Optional [ dict ] Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. None prettify_colnames bool Run colnames through 'snake_to_text' function. True add_header_filters bool Should header filters be added. False yadcf_settings Optional [ dict ] Settings for the yadcf header filter plugin. Overrides any automatic settings. None table_kwargs Optional [ dict ] Keyword args for the table when serializing to json. None downloads bool Should download buttons be shown? False table_settings Optional [ dict ] Dictionary with the DataTable settings. Anything set here will overwrite existing ones. None json_name str Name of the saved file (before hash if hash=True) 'datatable' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/table.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , column_settings : Optional [ dict ] = None , prettify_colnames : bool = True , add_header_filters : bool = False , yadcf_settings : Optional [ dict ] = None , table_kwargs : Optional [ dict ] = None , downloads : bool = False , table_settings : Optional [ dict ] = None , json_name : str = \"datatable\" , use_hash : bool = True , ): \"\"\" Initialize the table using the DataTable javascript library. Args: table (pd.DataFrame): The table in pandas.DataFrame format. page_info (PageInfo): PageInfo object for the page where the table should be located. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. column_settings (Optional[dict]): Dict of settings for the columns. Will be passed as json to the DataTable library. Overrides any automatic settings. prettify_colnames (bool): Run colnames through 'snake_to_text' function. add_header_filters (bool): Should header filters be added. yadcf_settings (Optional[dict]): Settings for the *yadcf* header filter plugin. Overrides any automatic settings. table_kwargs (Optional[dict]): Keyword args for the table when serializing to json. downloads (bool): Should download buttons be shown? table_settings (Optional[dict]): Dictionary with the DataTable settings. Anything set here will overwrite existing ones. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] # are not useful, but the rest gets set as 'data', which we need table . to_json ( path , orient = \"split\" , default_handler = str , ** ( table_kwargs if table_kwargs is not None else {}), ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) javascript_settings = [ \"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\" , \"https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.js\" , ] css_settings = [ \"https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css\" , \"https://cdn.jsdelivr.net/gh/vedmack/yadcf@332407eeacbda299e6253530e24c15041b270227/dist/jquery.dataTables.yadcf.css\" , ] # prepare the table settings if prettify_colnames : col_set = { col : { \"title\" : snake_to_text ( col ) if isinstance ( col , str ) else col } for col in table . columns } else : col_set = { col : { \"title\" : col } for col in table . columns } if column_settings is not None : # only pick out settings for columns that occur in the table col_set . update ({ col : column_settings [ col ] for col in table . columns }) self . add_header_filters = add_header_filters if add_header_filters : self . yadcf_settings = _create_yadcf_settings_datatable ( table , yadcf_settings if yadcf_settings is not None else {} ) # put together the settings for the table # there, the columns are a list in the correct order self . table_settings = { \"scrollX\" : \"true\" , \"columns\" : [ col_set [ col ] for col in table . columns ], } if downloads : self . table_settings [ \"buttons\" ] = [ \"copy\" , \"csv\" , \"excel\" , \"pdf\" , \"print\" ] # self.table_settings[\"dom\"] = \"Bfrtlp\" self . table_settings [ \"dom\" ] = \"<lfr>t<Bp>\" css_settings . append ( \"https://cdn.datatables.net/buttons/2.2.2/css/buttons.dataTables.min.css\" ) javascript_settings . extend ( [ \"https://cdn.datatables.net/buttons/2.2.2/js/dataTables.buttons.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.3/jszip.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/pdfmake.min.js\" , \"https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/vfs_fonts.js\" , \"https://cdn.datatables.net/buttons/2.2.2/js/buttons.html5.min.js\" , \"https://cdn.datatables.net/buttons/2.2.2/js/buttons.print.min.js\" , ] ) datatable_id = page_info . idstore . next_id ( \"datatable_id\" ) body_html = inspect . cleandoc ( f \"\"\" <table id=' { datatable_id } ' class='display' style='width:100%'> </table> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) self . table_settings [ \"ajax\" ] = str ( rel_table_path ) # overwrite with given settigns if necessary self . table_settings . update ( table_settings if table_settings is not None else {}) settings_str = serialize_json ( self . table_settings ) # prepare the header script if necessary if self . add_header_filters : yadcf_settings_str = serialize_json ( self . yadcf_settings ) yadcf_script = inspect . cleandoc ( f \"\"\" yadcf.init(myTable, { yadcf_settings_str } ); \"\"\" ) else : yadcf_script = \"\" back_html = inspect . cleandoc ( f \"\"\" <script> $(document).ready( function () {{ var myTable = $('# { datatable_id } ').DataTable( { settings_str } ); { yadcf_script } }} ); </script> \"\"\" ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = javascript_settings , css = css_settings , ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + comment_ids ( datatable_id ) self . _settings = settings","title":"__init__()"},{"location":"Reference/md/table/#mkreports.md.table.Table","text":"Bases: MdObj Standard markdown table. Source code in mkreports/md/table.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @register_md ( \"Table\" ) class Table ( MdObj ): \"\"\"Standard markdown table.\"\"\" table : pd . DataFrame kwargs : Dict [ str , Any ] def __init__ ( self , table : pd . DataFrame , max_rows : Optional [ int ] = 100 , ** kwargs ): \"\"\" Initialize the table object. Args: table (pd.DataFrame): The table to include in pandas format. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. \"\"\" super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) # check if the table has too many rows if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) self . table = self . table . iloc [ 0 : max_rows ] table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" self . _body = SpacedText ( table_md , ( 2 , 2 )) self . _back = None self . _settings = None","title":"Table"},{"location":"Reference/md/table/#mkreports.md.table.Table.__init__","text":"Initialize the table object. Parameters: Name Type Description Default table pd . DataFrame The table to include in pandas format. required max_rows Optional [ int ] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 100 Source code in mkreports/md/table.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , table : pd . DataFrame , max_rows : Optional [ int ] = 100 , ** kwargs ): \"\"\" Initialize the table object. Args: table (pd.DataFrame): The table to include in pandas format. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. \"\"\" super () . __init__ () self . kwargs = kwargs # think about making this a static-frame self . table = deepcopy ( table ) # check if the table has too many rows if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) self . table = self . table . iloc [ 0 : max_rows ] table_md = self . table . to_markdown ( ** self . kwargs ) table_md = table_md if table_md is not None else \"\" self . _body = SpacedText ( table_md , ( 2 , 2 )) self . _back = None self . _settings = None","title":"__init__()"},{"location":"Reference/md/table/#mkreports.md.table.Tabulator","text":"Bases: File A table using the Tabulator javascript library. Source code in mkreports/md/table.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 @register_md ( \"Tabulator\" ) class Tabulator ( File ): \"\"\"A table using the Tabulator javascript library.\"\"\" def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , downloads : bool = False , table_kwargs : Optional [ dict ] = None , json_name : str = \"tabulator\" , use_hash : bool = True , ): \"\"\" Args: table (pd.DataFrame): The table to be added. page_info (PageInfo): PageInfo for the page where the table should be added. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. table_settings (Optional[dict]): Settings passed to Tabulator as json. Overrides any internal settings created by this function. add_header_filters (bool): Should header-filters be added. prettify_colnames (bool): Run column names through *snake_to_text*. col_settings (Optional[dict]): Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. downloads (bool): Add download options. table_kwargs (Optional[dict]): Keyword args for the table when serializing to json. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None assert page_info . javascript_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] table . to_json ( path , orient = \"records\" , default_handler = str , ** ( table_kwargs if table_kwargs is not None else {}), ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) # produce the column settings col_list = _create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list used_ids = [] used_ids . append ( tabulator_id := page_info . idstore . next_id ( \"tabulator_id\" )) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) javascript_settings = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , ] css_settings = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ] if add_header_filters : javascript_settings . append ( store_asset_relpath ( Path ( \"min_max_filter.js\" ), page_info ) ) if downloads : # add the necessary things to enable downloads # to the body used_ids . append ( csv_down_id := page_info . idstore . next_id ( \"csv_down_id\" )) used_ids . append ( json_down_id := page_info . idstore . next_id ( \"json_down_id\" )) used_ids . append ( xlsx_down_id := page_info . idstore . next_id ( \"xslx_down_id\" )) body_html = body_html + inspect . cleandoc ( f \"\"\" <div> <button class=\"tabulator-btn-dwn\", id=\" { csv_down_id } \">to CSV</button> <button class=\"tabulator-btn-dwn\", id=\" { json_down_id } \">to JSON</button> <button class=\"tabulator-btn-dwn\", id=\" { xlsx_down_id } \">to XLSX</button> </div> \"\"\" ) # to the back_html split_back_html = back_html . split ( \" \\n \" ) split_back_html . insert ( - 1 , inspect . cleandoc ( f \"\"\" //trigger download of data.csv file $(\"# { csv_down_id } \").click(function() {{ table.download(\"csv\", \"data.csv\"); }} ); //trigger download of data.json file $(\"# { json_down_id } \").click(function() {{ table.download(\"json\", \"data.json\"); }} ); //trigger download of data.xlsx file $(\"# { xlsx_down_id } \").click(function() {{ table.download(\"xlsx\", \"data.xlsx\", {{ sheetName:\"data\" }} ); }} ); \"\"\" ), ) back_html = \" \\n \" . join ( split_back_html ) # to the settings javascript_settings . append ( \"https://oss.sheetjs.com/sheetjs/xlsx.full.min.js\" ) css_settings . append ( store_asset_relpath ( Path ( \"download_buttons.css\" ), page_info ) ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = javascript_settings , css = css_settings , ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + \" \\n \" . join ( [ str ( comment_ids ( this_id )) for this_id in used_ids ] ) self . _settings = settings","title":"Tabulator"},{"location":"Reference/md/table/#mkreports.md.table.Tabulator.__init__","text":"Parameters: Name Type Description Default table pd . DataFrame The table to be added. required page_info PageInfo PageInfo for the page where the table should be added. required max_rows Optional [ int ] Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first max_rows will be included. 1000 table_settings Optional [ dict ] Settings passed to Tabulator as json. Overrides any internal settings created by this function. None add_header_filters bool Should header-filters be added. True prettify_colnames bool Run column names through snake_to_text . True col_settings Optional [ dict ] Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. None downloads bool Add download options. False table_kwargs Optional [ dict ] Keyword args for the table when serializing to json. None json_name str Name of the saved file (before hash if hash=True) 'tabulator' use_hash bool Should the name of the copied image be updated with a hash (Default: True) True Source code in mkreports/md/table.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 def __init__ ( self , table : pd . DataFrame , page_info : PageInfo , max_rows : Optional [ int ] = 1000 , table_settings : Optional [ dict ] = None , add_header_filters : bool = True , prettify_colnames : bool = True , col_settings : Optional [ dict ] = None , downloads : bool = False , table_kwargs : Optional [ dict ] = None , json_name : str = \"tabulator\" , use_hash : bool = True , ): \"\"\" Args: table (pd.DataFrame): The table to be added. page_info (PageInfo): PageInfo for the page where the table should be added. max_rows (Optional[int]): Maximum number of rows. If None, all will be included. If longer, a warning will be logged and the first `max_rows` will be included. table_settings (Optional[dict]): Settings passed to Tabulator as json. Overrides any internal settings created by this function. add_header_filters (bool): Should header-filters be added. prettify_colnames (bool): Run column names through *snake_to_text*. col_settings (Optional[dict]): Column settings for tabulator, passed as json to the Tabulator library. Overrides any internal settings created. downloads (bool): Add download options. table_kwargs (Optional[dict]): Keyword args for the table when serializing to json. json_name (str): Name of the saved file (before hash if hash=True) use_hash (bool): Should the name of the copied image be updated with a hash (Default: True) \"\"\" assert page_info . idstore is not None assert page_info . page_path is not None assert page_info . javascript_path is not None with tempfile . TemporaryDirectory () as dir : path = Path ( dir ) / ( f \" { json_name } .json\" ) # here we use the split method; the index and columns # are not useful, but the rest gets set as 'data', which we need if max_rows is not None and table . shape [ 0 ] > max_rows : logger . warning ( f \"Table has { table . shape [ 0 ] } rows, but only { max_rows } allowed. Truncating.\" ) table = table . iloc [ 0 : max_rows ] table . to_json ( path , orient = \"records\" , default_handler = str , ** ( table_kwargs if table_kwargs is not None else {}), ) # Make sure the file is moved to the right place super () . __init__ ( path = path , page_info = page_info , allow_copy = True , use_hash = use_hash ) # produce the column settings col_list = _create_col_settings_tabulator ( table , add_header_filters = add_header_filters , prettify_colnames = prettify_colnames , col_settings = col_settings if col_settings is not None else {}, ) # put the other settings together self . table_settings : Dict [ str , Any ] = merge_settings ( dict ( layout = \"fitDataTable\" , pagination = True , paginationSize = 10 , paginationSizeSelector = True , ), table_settings if table_settings is not None else {}, ) self . table_settings [ \"columns\" ] = col_list used_ids = [] used_ids . append ( tabulator_id := page_info . idstore . next_id ( \"tabulator_id\" )) body_html = inspect . cleandoc ( f \"\"\" <div id=' { tabulator_id } ' class='display'> </div> \"\"\" ) rel_table_path = relpath_html ( self . path , page_info . page_path ) table_settings = copy . deepcopy ( self . table_settings ) table_settings [ \"ajaxURL\" ] = str ( rel_table_path ) # here we have to be careful to remove the '' around # the minMaxFilter function reference settings_str = serialize_json ( table_settings ) back_html = inspect . cleandoc ( f \"\"\" <script> var table = new Tabulator('# { tabulator_id } ', { settings_str } ); </script> \"\"\" ) javascript_settings = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/js/tabulator.min.js\" , ] css_settings = [ \"https://unpkg.com/tabulator-tables@5.1.0/dist/css/tabulator.min.css\" ] if add_header_filters : javascript_settings . append ( store_asset_relpath ( Path ( \"min_max_filter.js\" ), page_info ) ) if downloads : # add the necessary things to enable downloads # to the body used_ids . append ( csv_down_id := page_info . idstore . next_id ( \"csv_down_id\" )) used_ids . append ( json_down_id := page_info . idstore . next_id ( \"json_down_id\" )) used_ids . append ( xlsx_down_id := page_info . idstore . next_id ( \"xslx_down_id\" )) body_html = body_html + inspect . cleandoc ( f \"\"\" <div> <button class=\"tabulator-btn-dwn\", id=\" { csv_down_id } \">to CSV</button> <button class=\"tabulator-btn-dwn\", id=\" { json_down_id } \">to JSON</button> <button class=\"tabulator-btn-dwn\", id=\" { xlsx_down_id } \">to XLSX</button> </div> \"\"\" ) # to the back_html split_back_html = back_html . split ( \" \\n \" ) split_back_html . insert ( - 1 , inspect . cleandoc ( f \"\"\" //trigger download of data.csv file $(\"# { csv_down_id } \").click(function() {{ table.download(\"csv\", \"data.csv\"); }} ); //trigger download of data.json file $(\"# { json_down_id } \").click(function() {{ table.download(\"json\", \"data.json\"); }} ); //trigger download of data.xlsx file $(\"# { xlsx_down_id } \").click(function() {{ table.download(\"xlsx\", \"data.xlsx\", {{ sheetName:\"data\" }} ); }} ); \"\"\" ), ) back_html = \" \\n \" . join ( split_back_html ) # to the settings javascript_settings . append ( \"https://oss.sheetjs.com/sheetjs/xlsx.full.min.js\" ) css_settings . append ( store_asset_relpath ( Path ( \"download_buttons.css\" ), page_info ) ) settings = Settings ( page = dict ( # the following needs to be loaded in the header of the page, not the footer # this enables activating the tables in the body javascript = javascript_settings , css = css_settings , ) ) self . _body = SpacedText ( body_html , ( 2 , 2 )) self . _back = SpacedText ( back_html , ( 2 , 2 )) + \" \\n \" . join ( [ str ( comment_ids ( this_id )) for this_id in used_ids ] ) self . _settings = settings","title":"__init__()"},{"location":"Reference/md/text/","text":"SpacedText Representation of text with newlines before or after. Source code in mkreports/md/text.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class SpacedText : \"\"\"Representation of text with newlines before or after.\"\"\" text : str req_nl : Tuple [ int , int ] def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : \"\"\" Initialize the object. Args: text (Text): The text to print. req_nl (Tuple[int, int]): Number of newlines before and after to ensure. \"\"\" if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) def __eq__ ( self , other : Any ) -> bool : if type ( self ) != type ( other ): return False return self . text == other . text and self . req_nl == other . req_nl def __add__ ( self , follow : Text ) -> \"SpacedText\" : return _add_text ( self , SpacedText ( follow )) def __radd__ ( self , precede : Text ) -> \"SpacedText\" : return _add_text ( SpacedText ( precede ), self ) def format_text ( self , precede : Text = \"\" , follow : Text = \"\" ) -> str : add_before = _needed_nl_between ( SpacedText ( precede ), self ) add_after = _needed_nl_between ( self , SpacedText ( follow )) # return with the required additional newlines return ( \" \\n \" * add_before ) + self . text + ( \" \\n \" * add_after ) __init__ ( text = '' , req_nl = ( 0 , 0 )) Initialize the object. Parameters: Name Type Description Default text Text The text to print. '' req_nl Tuple [ int , int ] Number of newlines before and after to ensure. (0, 0) Source code in mkreports/md/text.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : \"\"\" Initialize the object. Args: text (Text): The text to print. req_nl (Tuple[int, int]): Number of newlines before and after to ensure. \"\"\" if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl __str__ () Return a formatted str. We assume that 3 newlines are before and after. That should be enough. Source code in mkreports/md/text.py 55 56 57 58 59 60 61 def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) _needed_nl_between ( first , second ) Calculates the number of newlines needed between two text objects. Source code in mkreports/md/text.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def _needed_nl_between ( first : SpacedText , second : SpacedText ) -> int : \"\"\" Calculates the number of newlines needed between two text objects. \"\"\" if first . text == \"\" or second . text == \"\" : return 0 req_first_after = first . req_nl [ 1 ] num_first_after = count_newlines ( first . text , before = False ) req_second_before = second . req_nl [ 0 ] num_second_before = count_newlines ( second . text , before = True ) add_between = max ( max ( req_first_after , req_second_before ) - num_second_before - num_first_after , 0 , ) return add_between count_newlines ( x , before = True ) Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. Source code in mkreports/md/text.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def count_newlines ( x : str , before = True ) -> int : \"\"\" Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. \"\"\" num_nl = 0 whitespace = [ \" \" , \" \\r \" , \" \\t \" ] y = x if before else reversed ( x ) for ch in y : if ch == \" \\n \" : num_nl += 1 elif ch in whitespace : continue else : return num_nl return num_nl","title":"text"},{"location":"Reference/md/text/#mkreports.md.text.SpacedText","text":"Representation of text with newlines before or after. Source code in mkreports/md/text.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class SpacedText : \"\"\"Representation of text with newlines before or after.\"\"\" text : str req_nl : Tuple [ int , int ] def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : \"\"\" Initialize the object. Args: text (Text): The text to print. req_nl (Tuple[int, int]): Number of newlines before and after to ensure. \"\"\" if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" ) def __eq__ ( self , other : Any ) -> bool : if type ( self ) != type ( other ): return False return self . text == other . text and self . req_nl == other . req_nl def __add__ ( self , follow : Text ) -> \"SpacedText\" : return _add_text ( self , SpacedText ( follow )) def __radd__ ( self , precede : Text ) -> \"SpacedText\" : return _add_text ( SpacedText ( precede ), self ) def format_text ( self , precede : Text = \"\" , follow : Text = \"\" ) -> str : add_before = _needed_nl_between ( SpacedText ( precede ), self ) add_after = _needed_nl_between ( self , SpacedText ( follow )) # return with the required additional newlines return ( \" \\n \" * add_before ) + self . text + ( \" \\n \" * add_after )","title":"SpacedText"},{"location":"Reference/md/text/#mkreports.md.text.SpacedText.__init__","text":"Initialize the object. Parameters: Name Type Description Default text Text The text to print. '' req_nl Tuple [ int , int ] Number of newlines before and after to ensure. (0, 0) Source code in mkreports/md/text.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , text : Text = \"\" , req_nl : Tuple [ int , int ] = ( 0 , 0 )) -> None : \"\"\" Initialize the object. Args: text (Text): The text to print. req_nl (Tuple[int, int]): Number of newlines before and after to ensure. \"\"\" if isinstance ( text , str ): my_text = text my_req_nl = req_nl else : my_text = text . text my_req_nl = ( max ( req_nl [ 0 ], text . req_nl [ 0 ]), max ( req_nl [ 1 ], text . req_nl [ 1 ]), ) self . text = my_text self . req_nl = my_req_nl","title":"__init__()"},{"location":"Reference/md/text/#mkreports.md.text.SpacedText.__str__","text":"Return a formatted str. We assume that 3 newlines are before and after. That should be enough. Source code in mkreports/md/text.py 55 56 57 58 59 60 61 def __str__ ( self ) -> str : \"\"\" Return a formatted str. We assume that 3 newlines are before and after. That should be enough. \"\"\" return self . format_text ( \" \\n\\n\\n \" , \" \\n\\n\\n \" )","title":"__str__()"},{"location":"Reference/md/text/#mkreports.md.text._needed_nl_between","text":"Calculates the number of newlines needed between two text objects. Source code in mkreports/md/text.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 def _needed_nl_between ( first : SpacedText , second : SpacedText ) -> int : \"\"\" Calculates the number of newlines needed between two text objects. \"\"\" if first . text == \"\" or second . text == \"\" : return 0 req_first_after = first . req_nl [ 1 ] num_first_after = count_newlines ( first . text , before = False ) req_second_before = second . req_nl [ 0 ] num_second_before = count_newlines ( second . text , before = True ) add_between = max ( max ( req_first_after , req_second_before ) - num_second_before - num_first_after , 0 , ) return add_between","title":"_needed_nl_between()"},{"location":"Reference/md/text/#mkreports.md.text.count_newlines","text":"Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. Source code in mkreports/md/text.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def count_newlines ( x : str , before = True ) -> int : \"\"\" Count the number of newlines from front or back. Here all newlines are counted while ignoring whitespace. Stop at first character that is not newline or whitespace. If there are no non-newline or whitespace characters, return infinite number of newlines. \"\"\" num_nl = 0 whitespace = [ \" \" , \" \\r \" , \" \\t \" ] y = x if before else reversed ( x ) for ch in y : if ch == \" \\n \" : num_nl += 1 elif ch in whitespace : continue else : return num_nl return num_nl","title":"count_newlines()"},{"location":"site_code/__init__/","text":"__init__.py","title":"  Init  "},{"location":"site_code/basic/","text":"basic.py from mkreports import Report , md def use_basic ( report : Report ) -> None : p = report . page ( \"usage/basic.md\" , truncate = True ) p . H1 ( \"Basic formatting elements\" ) p . CollapsedCodeFile ( __file__ ) with p . H2 ( \"Headings\" , anchor = ( heading_anchor := p . md . Anchor ())): p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) with p . H2 ( \"Lists\" ) as p2 : numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) with p . H2 ( \"Links\" ) as p2 : p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Basic"},{"location":"site_code/code_blocks/","text":"code_blocks.py from mkreports import Report def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" p = report . page ( \"usage/code_blocks.md\" , truncate = True ) with p . H1 ( \"Code blocks\" ) . ctx ( \"top-c\" ): p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" )","title":"Code Blocks"},{"location":"site_code/images/","text":"images.py import matplotlib.pyplot as plt import numpy as np import seaborn as sns from mkreports import Report from PIL import Image from plotnine import aes , facet_wrap , geom_point , ggplot , stat_smooth from plotnine.data import mtcars def use_images ( report : Report ) -> None : \"\"\" Show all different ways on how we can include images. \"\"\" p = report . page ( \"usage/images.md\" , truncate = True ) # we don't need an indentation for everything if we don't want p . H1 ( \"Images\" ) p . CollapsedCodeFile ( __file__ ) p . H2 ( \"Supported formats\" ) p . Raw ( \"\"\" Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an `ImageFile` object. \"\"\" ) with p . H3 ( \"PIL\" ): p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) with p . H3 ( \"Matplotlib\" ): p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Matplotlib ( fig ) with p . H3 ( \"Plotnine\" ): p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) with p . H3 ( \"Seaborn\" ): p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Seaborn ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) with p . H3 ( \"Altair\" ): import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) with p . H3 ( \"Plotly\" ): import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) p . H2 ( \"Different image sizes\" ) p . P ( \"\"\" In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change. \"\"\" ) with p . H3 ( \"Plotnine\" ): p . H4 ( \"Larger\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , ) p . H2 ( \"Images next to each other\" ) p . P ( \"\"\" Images can also be placed next to each other, if there is enough space. Just specify them directly one after the other and if there is enough space, they will be placed next to each other. \"\"\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 2 , height = 1.5 , ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 2 , height = 1.5 , )","title":"Images"},{"location":"site_code/main/","text":"main.py import inspect import shutil from pathlib import Path import mkreports import typer from mkreports import Report , add_pkg_docs from .basic import use_basic from .code_blocks import use_code_blocks from .images import use_images from .quickstart import do_quickstart from .sidebar import use_sidebar from .tables import use_tables def add_md_pages ( report : Report ): \"\"\" Add pages written in pure markdown format. \"\"\" # open the page, and copy the other one over it report . insert_page ( \"index.md\" , Path ( __file__ ) . parent / \"index.md\" , mode = \"S\" ) report . insert_page ( \"usage/markdown.md\" , Path ( __file__ ) . parent / \"markdown.md\" , mode = \"S\" ) report . insert_page ( \"usage/plugins.md\" , Path ( __file__ ) . parent / \"plugins.md\" , mode = \"S\" ) report . insert_page ( \"usage/ipython.md\" , Path ( __file__ ) . parent / \"ipython.md\" , mode = \"S\" ) def add_code_pages ( report : Report , code_dir : Path ): code_files = list ( code_dir . glob ( \"**/*.py\" )) code_files . sort () for code_file in code_files : rel_code_file = code_file . relative_to ( code_dir ) site_file_name = \"site_code\" / rel_code_file . with_suffix ( \".md\" ) p = report . page ( site_file_name , truncate = True ) with code_file . open ( \"r\" ) as f : p . Code ( f . read (), language = \"python\" , title = str ( rel_code_file )) def run_all ( report : Report ): do_quickstart ( report ) add_md_pages ( report ) use_basic ( report ) # documentation for images use_images ( report ) # documentation for tables use_tables ( report ) # documentation for code blocks use_code_blocks ( report ) # sidebar use_sidebar ( report ) # add the docstrings add_pkg_docs ( Path ( inspect . getfile ( mkreports )) . parent , parent_name = \"Reference\" , report = report , omit_package_name = True , ) add_code_pages ( report , Path ( __file__ ) . parent ) def main ( report_dir : Path ): report = Report . create ( report_dir , report_name = \"Mkreports documentations\" , exist_ok = True ) run_all ( report ) if __name__ == \"__main__\" : typer . run ( main )","title":"Main"},{"location":"site_code/quickstart/","text":"quickstart.py import plotnine as p9 from mkreports import Report from plotnine.data import mtcars def do_quickstart ( report : Report ) -> None : p = report . page ( \"quickstart\" , truncate = True ) p . H1 ( \"Quickstart\" ) p . P ( \"\"\" First, below the code that was used to create this page. It is a very brief example of an page with a table and an image as well as some text, like here. \"\"\" ) p . CodeFile ( __file__ ) p . P ( \"\"\" We are quickly analyzing the mtcars dataset that is included with plotnine. \"\"\" ) with p . H2 ( \"Data as a table\" ): p . Tabulator ( mtcars , add_header_filters = True , prettify_colnames = True ) with p . H2 ( \"Some simple plots\" ): p . Plotnine ( ( p9 . ggplot ( mtcars , p9 . aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + p9 . geom_point () + p9 . stat_smooth ( method = \"lm\" ) + p9 . facet_wrap ( \"~gear\" ) ) ) if __name__ == \"__main__\" : report = Report . create ( \"mkreports_docs\" , report_name = \"Mkreports documentations\" ) do_quickstart ( report )","title":"Quickstart"},{"location":"site_code/sidebar/","text":"sidebar.py from mkreports import Report def use_sidebar ( report : Report ) -> None : p = report . page ( \"usage/sidebar\" , truncate = True ) p . CollapsedCodeFile ( __file__ ) p . H1 ( \"Sidebars\" ) p . P ( \"\"\" We can hide the table of contents sidebar as well as the navigation bar. On this page, we only hide the ToC. When hiding the navigation bar, you should think about setting navigation tabs as well (otherwise there is no direct navigation option. Below a code block showing how to hide the ToC, Nav and set the navigations tabs. \"\"\" ) p . HideToc () p . Code ( \"\"\" p.HideToc() p.HideNav() p.NavTabs() \"\"\" )","title":"Sidebar"},{"location":"site_code/tables/","text":"tables.py import pandas as pd from mkreports import Report , md from plotnine.data import mtcars def use_tables ( report : Report ) -> None : \"\"\" Show all the different ways on how we can work with tables. \"\"\" ex_table = pd . DataFrame ( [ { \"name\" : \"Alfred\" , \"age\" : 30 , \"hair\" : \"red\" , \"married\" : True }, { \"name\" : \"Beate\" , \"age\" : 50 , \"hair\" : \"brown\" , \"married\" : False }, { \"name\" : \"Caro\" , \"age\" : 7 , \"hair\" : \"green\" , \"married\" : False , }, ] ) ex_table [ \"hair\" ] = pd . Categorical ( ex_table . hair ) p = report . page ( \"usage/tables.md\" , truncate = True ) p . H1 ( \"Different ways of handling tables\" ) p . CollapsedCodeFile ( __file__ ) p . Raw ( \"\"\" Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. \"\"\" ) with p . H2 ( \"Markdown tables\" ): p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) with p . H2 ( \"DataTable javascript library\" ): p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" An example with buttons for downloading and printing of the table. \"\"\" ) p . DataTable ( ex_table , downloads = True ) with p . H2 ( \"Tabulator javascript library\" ): p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . P ( \"\"\" An example showing download buttons for export to csv, json or excel. \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True , downloads = True , ) with p . H2 ( \"Notes\" ): p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" )","title":"Tables"},{"location":"usage/basic/","text":"Basic formatting elements Code docs/staging/basic.py from mkreports import Report , md def use_basic ( report : Report ) -> None : p = report . page ( \"usage/basic.md\" , truncate = True ) p . H1 ( \"Basic formatting elements\" ) p . CollapsedCodeFile ( __file__ ) with p . H2 ( \"Headings\" , anchor = ( heading_anchor := p . md . Anchor ())): p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) with p . H2 ( \"Lists\" ) as p2 : numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) with p . H2 ( \"Links\" ) as p2 : p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" ) Headings Content Code Available headings md . H1 ( \"Header type 1\" ) md . H2 ( \"Header type 2\" ) md . H3 ( \"Header type 3\" ) md . H4 ( \"Header type 4\" ) md . H5 ( \"Header type 5\" ) md . H6 ( \"Header type 6\" ) md . H7 ( \"Header type 7\" ) docs/staging/basic.py 12 13 14 15 16 17 18 19 20 21 22 23 p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) Lists Content Code First item Second item Third item Some fruit: apples pears strawberry A code block: Hello world print ( \"Hello world\" ) docs/staging/basic.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) Links Content Code A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) A link back to the first heading A link to another page Images Or just to any page Google Or of course also just straight markdown Google docs/staging/basic.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Basic"},{"location":"usage/basic/#basic-formatting-elements","text":"Code docs/staging/basic.py from mkreports import Report , md def use_basic ( report : Report ) -> None : p = report . page ( \"usage/basic.md\" , truncate = True ) p . H1 ( \"Basic formatting elements\" ) p . CollapsedCodeFile ( __file__ ) with p . H2 ( \"Headings\" , anchor = ( heading_anchor := p . md . Anchor ())): p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , ) with p . H2 ( \"Lists\" ) as p2 : numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list ) with p . H2 ( \"Links\" ) as p2 : p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Basic formatting elements"},{"location":"usage/basic/#headings","text":"Content Code Available headings md . H1 ( \"Header type 1\" ) md . H2 ( \"Header type 2\" ) md . H3 ( \"Header type 3\" ) md . H4 ( \"Header type 4\" ) md . H5 ( \"Header type 5\" ) md . H6 ( \"Header type 6\" ) md . H7 ( \"Header type 7\" ) docs/staging/basic.py 12 13 14 15 16 17 18 19 20 21 22 23 p . Code ( \"\"\" md.H1(\"Header type 1\") md.H2(\"Header type 2\") md.H3(\"Header type 3\") md.H4(\"Header type 4\") md.H5(\"Header type 5\") md.H6(\"Header type 6\") md.H7(\"Header type 7\") \"\"\" , title = \"Available headings\" , )","title":"Headings"},{"location":"usage/basic/#lists","text":"Content Code First item Second item Third item Some fruit: apples pears strawberry A code block: Hello world print ( \"Hello world\" ) docs/staging/basic.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 numbered_list = ( md . List ( marker = \"1\" ) . append ( \"First item\" ) . append ( \"Second item\" ) . append ( \"Third item\" ) ) unordered_list = md . List (( \"apples\" , \"pears\" , \"strawberry\" ), marker = \"*\" ) numbered_list = numbered_list . append ( md . Raw ( \"Some fruit:\" ) + unordered_list ) . append ( md . Raw ( \"A code block:\" ) + md . Code ( \"\"\" print(\"Hello world\") \"\"\" , title = \"Hello world\" , language = \"python\" , ), ) p2 . add ( numbered_list )","title":"Lists"},{"location":"usage/basic/#links","text":"Content Code A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) A link back to the first heading A link to another page Images Or just to any page Google Or of course also just straight markdown Google docs/staging/basic.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 p2 . Raw ( \"\"\" A number of different types of links are possible. Those within a page to an anchor or to another page (with or without anchor) \"\"\" ) p2 . P ( \"A link back to the \" + p . md . ReportLink ( anchor = heading_anchor , text = \"first heading\" ) ) p2 . P ( \"A link to another page \" + p . md . ReportLink ( \"Images\" , to_page_path = report . page ( \"usage/images.md\" ) . path ) ) p2 . P ( \"Or just to any page \" + p . md . Link ( \"Google\" , url = \"https://google.com\" )) p2 . P ( \"Or of course also just straight markdown [Google](https://google.com)\" )","title":"Links"},{"location":"usage/code_blocks/","text":"Code blocks Code docs/staging/code_blocks.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. Tracking code (tabbed) Content Code One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. fib(3) = 2 By default, the tabbed version will be used, but there are also the options top-c : Collapsed code block at the top top-o : Open code block at the top bottom-c : Collapsed code block at the bottom bottom-o : Open code block at the bottom The default style can be set when creating the page using the code_layout parameter, but can also be set one at a time later using the ctx method on a page. docs/staging/code_blocks.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) Tracking code (top-c) Code docs/staging/code_blocks.py 61 62 63 64 65 p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as a collapsed admonition before the output. fib(4) = 3 Tracking code (top-o) docs/staging/code_blocks.py 68 69 70 71 72 p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as an open code block before the output. fib(5) = 5 Tracking code (bottom-c) The code as a collapsed admoniton after the output. fib(6) = 8 Code docs/staging/code_blocks.py 75 76 77 78 79 p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) Tracking code (bottom-o) The code as an open code block after the output. fib(7) = 13 docs/staging/code_blocks.py 82 83 84 85 86 p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) Adding code files Content Code In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. Code docs/staging/code_blocks.py from mkreports import Report def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" p = report . page ( \"usage/code_blocks.md\" , truncate = True ) with p . H1 ( \"Code blocks\" ) . ctx ( \"top-c\" ): p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) docs/staging/code_blocks.py 89 90 91 92 93 94 95 96 97 98 p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) And at the end will add another copy of the code-file, but automatically when ending the page context manager.","title":"Code Blocks"},{"location":"usage/code_blocks/#code-blocks","text":"Code docs/staging/code_blocks.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one.","title":"Code blocks"},{"location":"usage/code_blocks/#tracking-code-tabbed","text":"Content Code One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. fib(3) = 2 By default, the tabbed version will be used, but there are also the options top-c : Collapsed code block at the top top-o : Open code block at the top bottom-c : Collapsed code block at the bottom bottom-o : Open code block at the bottom The default style can be set when creating the page using the code_layout parameter, but can also be set one at a time later using the ctx method on a page. docs/staging/code_blocks.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" )","title":"Tracking code (tabbed)"},{"location":"usage/code_blocks/#tracking-code-top-c","text":"Code docs/staging/code_blocks.py 61 62 63 64 65 p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as a collapsed admonition before the output. fib(4) = 3","title":"Tracking code (top-c)"},{"location":"usage/code_blocks/#tracking-code-top-o","text":"docs/staging/code_blocks.py 68 69 70 71 72 p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) The code as an open code block before the output. fib(5) = 5","title":"Tracking code (top-o)"},{"location":"usage/code_blocks/#tracking-code-bottom-c","text":"The code as a collapsed admoniton after the output. fib(6) = 8 Code docs/staging/code_blocks.py 75 76 77 78 79 p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" )","title":"Tracking code (bottom-c)"},{"location":"usage/code_blocks/#tracking-code-bottom-o","text":"The code as an open code block after the output. fib(7) = 13 docs/staging/code_blocks.py 82 83 84 85 86 p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" )","title":"Tracking code (bottom-o)"},{"location":"usage/code_blocks/#adding-code-files","text":"Content Code In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. Code docs/staging/code_blocks.py from mkreports import Report def fib ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fib ( n - 1 ) + fib ( n - 2 ) def use_code_blocks ( report : Report ) -> None : \"\"\" Show different ways on how code blacks can be included. \"\"\" p = report . page ( \"usage/code_blocks.md\" , truncate = True ) with p . H1 ( \"Code blocks\" ) . ctx ( \"top-c\" ): p . P ( \"\"\" Here we use nested trackers. The outer tracker uses a 'top-c' layout, so the code is a collapsed admonition at the top right above this paragraph. The other blocks below are nested inside this one. \"\"\" ) with p . H2 ( \"Tracking code (tabbed)\" ): p . Raw ( \"\"\" One of the features of mkreports is that we can include code right from the script into the output. This is done by starting a context manager and all code in the scope of the context manager will be recorded. \"\"\" ) x = 3 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) p . P ( \"\"\" By default, the **tabbed** version will be used, but there are also the options - **top-c**: Collapsed code block at the top - **top-o**: Open code block at the top - **bottom-c**: Collapsed code block at the bottom - **bottom-o**: Open code block at the bottom The default style can be set when creating the page using the `code_layout` parameter, but can also be set one at a time later using the `ctx` method on a page. \"\"\" ) with p . H2 ( \"Tracking code (top-c)\" ) . ctx ( layout = \"top-c\" ): p . P ( \"The code as a collapsed admonition before the output.\" ) x = 4 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (top-o)\" ) . ctx ( layout = \"top-o\" ): p . P ( \"The code as an open code block before the output.\" ) x = 5 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-c)\" ) . ctx ( layout = \"bottom-c\" ): p . P ( \"The code as a collapsed admoniton after the output.\" ) x = 6 a = fib ( x ) p . Raw ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Tracking code (bottom-o)\" ) . ctx ( layout = \"bottom-o\" ): p . P ( \"The code as an open code block after the output.\" ) x = 7 a = fib ( x ) p . P ( f \"fib( { x } ) = { a } \" ) with p . H2 ( \"Adding code files\" ): p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) p . P ( \"\"\" And at the end will add another copy of the code-file, but automatically when ending the page context manager. \"\"\" ) docs/staging/code_blocks.py 89 90 91 92 93 94 95 96 97 98 p . P ( \"\"\" In addtion we can also add entire code files, for example at the end of a page the file or files that created a page. This can be wrapped into a collapsed admonition so that the file is hidden. \"\"\" ) p . CollapsedCodeFile ( __file__ ) And at the end will add another copy of the code-file, but automatically when ending the page context manager.","title":"Adding code files"},{"location":"usage/images/","text":"Images Code docs/staging/images.py import matplotlib.pyplot as plt import numpy as np import seaborn as sns from mkreports import Report from PIL import Image from plotnine import aes , facet_wrap , geom_point , ggplot , stat_smooth from plotnine.data import mtcars def use_images ( report : Report ) -> None : \"\"\" Show all different ways on how we can include images. \"\"\" p = report . page ( \"usage/images.md\" , truncate = True ) # we don't need an indentation for everything if we don't want p . H1 ( \"Images\" ) p . CollapsedCodeFile ( __file__ ) p . H2 ( \"Supported formats\" ) p . Raw ( \"\"\" Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an `ImageFile` object. \"\"\" ) with p . H3 ( \"PIL\" ): p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) with p . H3 ( \"Matplotlib\" ): p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Matplotlib ( fig ) with p . H3 ( \"Plotnine\" ): p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) with p . H3 ( \"Seaborn\" ): p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Seaborn ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) with p . H3 ( \"Altair\" ): import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) with p . H3 ( \"Plotly\" ): import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) p . H2 ( \"Different image sizes\" ) p . P ( \"\"\" In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change. \"\"\" ) with p . H3 ( \"Plotnine\" ): p . H4 ( \"Larger\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , ) p . H2 ( \"Images next to each other\" ) p . P ( \"\"\" Images can also be placed next to each other, if there is enough space. Just specify them directly one after the other and if there is enough space, they will be placed next to each other. \"\"\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 2 , height = 1.5 , ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 2 , height = 1.5 , ) Supported formats Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an ImageFile object. PIL Content Code PIL is the standard python image library. Image objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. docs/staging/images.py 33 34 35 36 37 38 39 40 41 42 43 44 45 p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) Matplotlib Content Code For many scientific graphing purposes, matplotlib is either the direct choice or the backend being used for plotting. docs/staging/images.py 49 50 51 52 53 54 55 56 57 58 p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Matplotlib ( fig ) Plotnine Content Code Any plots created by plotnine can be included directly. The code below is from the beginner example of the library. docs/staging/images.py 61 62 63 64 65 66 67 68 69 70 71 72 73 p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) Seaborn Content Code Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the figure attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. docs/staging/images.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Seaborn ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) Altair Content Code docs/staging/images.py 106 107 108 109 110 111 112 113 114 115 116 117 118 import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) vegaEmbed(\"#altair_id-0\", \"../images_store/altair-a7a2eb773c7d9454c694b490a77e5a7e.csv\") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn); Plotly Content Code docs/staging/images.py 121 122 123 124 import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) fetch('../images_store/plotly-920e2f4c0fce23ec31200a1619f50e95.json') .then(function (response) { return response.json(); }) .then(function (data) { doPlotly(data); }) .catch(function (err) { console.log('error: ' + err); }); function doPlotly(plotlyJson) { Plotly.newPlot(\"plotly_id-0\", { \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }) } Different image sizes In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change. Plotnine Content Code Larger Smaller docs/staging/images.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 p . H4 ( \"Larger\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , ) Images next to each other Images can also be placed next to each other, if there is enough space. Just specify them directly one after the other and if there is enough space, they will be placed next to each other.","title":"Images"},{"location":"usage/images/#images","text":"Code docs/staging/images.py import matplotlib.pyplot as plt import numpy as np import seaborn as sns from mkreports import Report from PIL import Image from plotnine import aes , facet_wrap , geom_point , ggplot , stat_smooth from plotnine.data import mtcars def use_images ( report : Report ) -> None : \"\"\" Show all different ways on how we can include images. \"\"\" p = report . page ( \"usage/images.md\" , truncate = True ) # we don't need an indentation for everything if we don't want p . H1 ( \"Images\" ) p . CollapsedCodeFile ( __file__ ) p . H2 ( \"Supported formats\" ) p . Raw ( \"\"\" Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an `ImageFile` object. \"\"\" ) with p . H3 ( \"PIL\" ): p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img ) with p . H3 ( \"Matplotlib\" ): p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Matplotlib ( fig ) with p . H3 ( \"Plotnine\" ): p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), ) with p . H3 ( \"Seaborn\" ): p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Seaborn ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), ) with p . H3 ( \"Altair\" ): import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) with p . H3 ( \"Plotly\" ): import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) p . H2 ( \"Different image sizes\" ) p . P ( \"\"\" In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change. \"\"\" ) with p . H3 ( \"Plotnine\" ): p . H4 ( \"Larger\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , ) p . H2 ( \"Images next to each other\" ) p . P ( \"\"\" Images can also be placed next to each other, if there is enough space. Just specify them directly one after the other and if there is enough space, they will be placed next to each other. \"\"\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 2 , height = 1.5 , ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 2 , height = 1.5 , )","title":"Images"},{"location":"usage/images/#supported-formats","text":"Mkreports supports inclusion out of the box of a number of different imaging libraries. For each supported library, an example is show below. For any not supported library, it is still possible to write out the image manually and then include it as an ImageFile object.","title":"Supported formats"},{"location":"usage/images/#pil","text":"Content Code PIL is the standard python image library. Image objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. docs/staging/images.py 33 34 35 36 37 38 39 40 41 42 43 44 45 p . Raw ( \"\"\" PIL is the standard python image library. `Image` objects are written out to files and included in the markdown. Here as an example we simply have a black and white image of a black and grey square. \"\"\" ) img_np = np . zeros (( 200 , 400 ), dtype = np . uint8 ) img_np [:, 200 : 400 ] = 128 img = Image . fromarray ( img_np ) p . PIL ( img )","title":"PIL"},{"location":"usage/images/#matplotlib","text":"Content Code For many scientific graphing purposes, matplotlib is either the direct choice or the backend being used for plotting. docs/staging/images.py 49 50 51 52 53 54 55 56 57 58 p . Raw ( \"\"\" For many scientific graphing purposes, `matplotlib` is either the direct choice or the backend being used for plotting. \"\"\" ) fig , ax = plt . subplots () ax . plot ([ 1 , 2 , 3 , 4 ], [ 1 , 4 , 2 , 3 ]) p . Matplotlib ( fig )","title":"Matplotlib"},{"location":"usage/images/#plotnine","text":"Content Code Any plots created by plotnine can be included directly. The code below is from the beginner example of the library. docs/staging/images.py 61 62 63 64 65 66 67 68 69 70 71 72 73 p . Raw ( \"\"\" Any plots created by `plotnine` can be included directly. The code below is from the beginner example of the library. \"\"\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), )","title":"Plotnine"},{"location":"usage/images/#seaborn","text":"Content Code Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the figure attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. docs/staging/images.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 p . add ( \"\"\" Another well known option is Seaborn. The interface is similar to the ones before. Under the hood, the `figure` attribute of the seaborn plot is accessed and saved in the same fashion as for matplotlib. \"\"\" ) sns . set_theme ( style = \"ticks\" ) # Load the example dataset for Anscombe's quartet df = sns . load_dataset ( \"anscombe\" ) # Show the results of a linear regression within each dataset p . Seaborn ( sns . lmplot ( x = \"x\" , y = \"y\" , col = \"dataset\" , hue = \"dataset\" , data = df , col_wrap = 2 , ci = None , palette = \"muted\" , height = 4 , scatter_kws = { \"s\" : 50 , \"alpha\" : 1 }, ), )","title":"Seaborn"},{"location":"usage/images/#altair","text":"Content Code docs/staging/images.py 106 107 108 109 110 111 112 113 114 115 116 117 118 import altair as alt import pandas as pd source = pd . DataFrame ( { \"a\" : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" , \"G\" , \"H\" , \"I\" ], \"b\" : [ 28 , 55 , 43 , 91 , 81 , 53 , 19 , 87 , 52 ], } ) p . Altair ( alt . Chart ( source ) . mark_bar () . encode ( x = \"a\" , y = \"b\" ) . properties ( width = 600 ) ) vegaEmbed(\"#altair_id-0\", \"../images_store/altair-a7a2eb773c7d9454c694b490a77e5a7e.csv\") // result.view provides access to the Vega View API .then(result => console.log(result)) .catch(console.warn);","title":"Altair"},{"location":"usage/images/#plotly","text":"Content Code docs/staging/images.py 121 122 123 124 import plotly.express as px fig = px . scatter ( x = [ 0 , 1 , 2 , 3 , 4 ], y = [ 0 , 1 , 4 , 9 , 16 ]) p . Plotly ( fig ) fetch('../images_store/plotly-920e2f4c0fce23ec31200a1619f50e95.json') .then(function (response) { return response.json(); }) .then(function (data) { doPlotly(data); }) .catch(function (err) { console.log('error: ' + err); }); function doPlotly(plotlyJson) { Plotly.newPlot(\"plotly_id-0\", { \"data\": plotlyJson[\"data\"], \"layout\": plotlyJson[\"layout\"] }) }","title":"Plotly"},{"location":"usage/images/#different-image-sizes","text":"In order to change the size of the image, use the width and height parameters. But please note that ultimately, the number of pixels determines the size - i.e. doubling height and width while halfing dpi does not change the size, but internally how it is rendered may change.","title":"Different image sizes"},{"location":"usage/images/#plotnine_1","text":"Content Code","title":"Plotnine"},{"location":"usage/images/#larger","text":"","title":"Larger"},{"location":"usage/images/#smaller","text":"docs/staging/images.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 p . H4 ( \"Larger\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 10 , height = 6 , ) p . H4 ( \"Smaller\" ) p . Plotnine ( ggplot ( mtcars , aes ( \"wt\" , \"mpg\" , color = \"factor(gear)\" )) + geom_point () + stat_smooth ( method = \"lm\" ) + facet_wrap ( \"~gear\" ), width = 5 , height = 3 , )","title":"Smaller"},{"location":"usage/images/#images-next-to-each-other","text":"Images can also be placed next to each other, if there is enough space. Just specify them directly one after the other and if there is enough space, they will be placed next to each other.","title":"Images next to each other"},{"location":"usage/ipython/","text":"Using IPython The extension The mkreports package also has an extension for IPython. Here, we are referring to the console-application IPython, not a Jupyter notebook (which were in the past also referred to as IPython notebooks). IPython here is just a replacement for the python console, similar to for example bpython . The reason we are using IPython is that it provides a plugin interface that allows us to extend its functionality. The key ability here is to have tables and images that are the results of commands in the IPython console to be automatically piped to a Console page in the mkdocs report. How to use it In order to use the IPython extension, we have to set the MKREPORTS_DIR environment variable to the folder in which the mkdocs report will be stored. Then we can start the IPython console and execute % load_ext mkreports Then in a separate shell, we go the directory that is referred to in MKREPORTS_DIR and run mkdocs serve and start a browser. Then we visit the Console subpage. Now, for every table or image that we create in the console, it will also be added to the Console page. Each entry will have a timestamp and end with a horizontal line. The code executed in the console since the last item was added will also be added as a tab. New entries will be added to the top of the page (at the bottom, there are problems with inadvertent scrolling). In addition, there are variables cons and md added to the console. The cons variable refers to the Console page and can be used just like any other report page in mkreports . The md object is the same as cons.md , just added for convenience, and can be used to create MdObj instances. An MdObj instance that is the result of a code-block will also automatically be added to the Console page. Layout By default, content and code will be presented as tabs. However, it also possible to choose other layouts. For the options, look to the section on code-blocks. In order to set a different layout, do cons.code_layout = 'top-o' in the IPython console. This, for example, will create visible code-blocks above the content. Archiving Once the Console page gets too long and becomes slower on reload, run % archive_console This will push the old Console page to a page with a time-stamp and create a new empty page to use for new additions.","title":"Ipython"},{"location":"usage/ipython/#using-ipython","text":"","title":"Using IPython"},{"location":"usage/ipython/#the-extension","text":"The mkreports package also has an extension for IPython. Here, we are referring to the console-application IPython, not a Jupyter notebook (which were in the past also referred to as IPython notebooks). IPython here is just a replacement for the python console, similar to for example bpython . The reason we are using IPython is that it provides a plugin interface that allows us to extend its functionality. The key ability here is to have tables and images that are the results of commands in the IPython console to be automatically piped to a Console page in the mkdocs report.","title":"The extension"},{"location":"usage/ipython/#how-to-use-it","text":"In order to use the IPython extension, we have to set the MKREPORTS_DIR environment variable to the folder in which the mkdocs report will be stored. Then we can start the IPython console and execute % load_ext mkreports Then in a separate shell, we go the directory that is referred to in MKREPORTS_DIR and run mkdocs serve and start a browser. Then we visit the Console subpage. Now, for every table or image that we create in the console, it will also be added to the Console page. Each entry will have a timestamp and end with a horizontal line. The code executed in the console since the last item was added will also be added as a tab. New entries will be added to the top of the page (at the bottom, there are problems with inadvertent scrolling). In addition, there are variables cons and md added to the console. The cons variable refers to the Console page and can be used just like any other report page in mkreports . The md object is the same as cons.md , just added for convenience, and can be used to create MdObj instances. An MdObj instance that is the result of a code-block will also automatically be added to the Console page.","title":"How to use it"},{"location":"usage/ipython/#layout","text":"By default, content and code will be presented as tabs. However, it also possible to choose other layouts. For the options, look to the section on code-blocks. In order to set a different layout, do cons.code_layout = 'top-o' in the IPython console. This, for example, will create visible code-blocks above the content.","title":"Layout"},{"location":"usage/ipython/#archiving","text":"Once the Console page gets too long and becomes slower on reload, run % archive_console This will push the old Console page to a page with a time-stamp and create a new empty page to use for new additions.","title":"Archiving"},{"location":"usage/markdown/","text":"Adding markdown elements to a page Opening pages The first step is to define a report directory and open a page in it. There is always at least the 'index.md' page included in any report, which is listed in the navigation under Home . from mkreports import Report report = Report () page = report . page ( 'index.md' ) Adding markdown There are overall 3 ways to use and add markdown elements to a page. Each of these provides a different level of convenient. As a summary for the user: If you want to add an element immediately to a page, use the markdown classes directly available as attributes in the page itself. These preset certain parameters and add the markdown object directly to the page after it is instantiated. If you need to build up more complicated markdown objects before adding it to a page (e.g. in the case of nested objects), use the Page.md attribute to get the markdown object that pre-populates certain parameters to sensible defaults In some special circumstances it may be necessary to get the raw markdown with full control. In this case the mkreports.md module can be used. Markdown attributes of a page All markdown objects are available under their name directory for a Page object (created from a Report ). For these, all parameters related to a page and project are captured in a single parameter page_info that expects and object of type PageInfo with names: store_path page_path report_path project_root javascript_path idstore When requesting a markdown object from a page, this is automatically added. The object is immediately added to the page. A list of all available object can be obtained with page . md . proxied_classes where page is a Page and the returned object is a dict of all registered markdown objects. The key of the dict is the name under which it is available as an attribute from the page. md attribute of a Page Each Page instance also has a md attribute. These expose the markdown object same as explained above, except that they will not be added to the page. This would have to be done manually. This is sometimes useful if more complex nested objects need to be created (e.g. for lists). md module Also available is the mkreports.md module. These are the base objects with no parameters pre-filled. This is only intended for experts that need special behavior that is not covered by the regular Page object.","title":"Markdown"},{"location":"usage/markdown/#adding-markdown-elements-to-a-page","text":"","title":"Adding markdown elements to a page"},{"location":"usage/markdown/#opening-pages","text":"The first step is to define a report directory and open a page in it. There is always at least the 'index.md' page included in any report, which is listed in the navigation under Home . from mkreports import Report report = Report () page = report . page ( 'index.md' )","title":"Opening pages"},{"location":"usage/markdown/#adding-markdown","text":"There are overall 3 ways to use and add markdown elements to a page. Each of these provides a different level of convenient. As a summary for the user: If you want to add an element immediately to a page, use the markdown classes directly available as attributes in the page itself. These preset certain parameters and add the markdown object directly to the page after it is instantiated. If you need to build up more complicated markdown objects before adding it to a page (e.g. in the case of nested objects), use the Page.md attribute to get the markdown object that pre-populates certain parameters to sensible defaults In some special circumstances it may be necessary to get the raw markdown with full control. In this case the mkreports.md module can be used.","title":"Adding markdown"},{"location":"usage/markdown/#markdown-attributes-of-a-page","text":"All markdown objects are available under their name directory for a Page object (created from a Report ). For these, all parameters related to a page and project are captured in a single parameter page_info that expects and object of type PageInfo with names: store_path page_path report_path project_root javascript_path idstore When requesting a markdown object from a page, this is automatically added. The object is immediately added to the page. A list of all available object can be obtained with page . md . proxied_classes where page is a Page and the returned object is a dict of all registered markdown objects. The key of the dict is the name under which it is available as an attribute from the page.","title":"Markdown attributes of a page"},{"location":"usage/markdown/#md-attribute-of-a-page","text":"Each Page instance also has a md attribute. These expose the markdown object same as explained above, except that they will not be added to the page. This would have to be done manually. This is sometimes useful if more complex nested objects need to be created (e.g. for lists).","title":"md attribute of a Page"},{"location":"usage/markdown/#md-module","text":"Also available is the mkreports.md module. These are the base objects with no parameters pre-filled. This is only intended for experts that need special behavior that is not covered by the regular Page object.","title":"md module"},{"location":"usage/plugins/","text":"Creating custom plugins All objects in this package that are used to add markdown (or html) to a page are all created using a plugin system. This enables other people to easily create their own MdObj objects and register them with mkreports so that they behave exactly as all other objects shipped with this package. Essentially, only 2 steps are needed: Create a new class that inherits from MdObj . There are many examples available in this package on how to do that. Especially interesting examples are the tables as well as images, but also HideNav , HideToc and NavTabs as they show how to use settings. Register the new class. This is easily done using the register_md decorator, which takes as its only argument the name under which the new class should be registered. After this is done, all classes are available as attributes on a Page as well as in Page.md with page_info parameters pre-set with the appropriate PageInfo object.","title":"Plugins"},{"location":"usage/plugins/#creating-custom-plugins","text":"All objects in this package that are used to add markdown (or html) to a page are all created using a plugin system. This enables other people to easily create their own MdObj objects and register them with mkreports so that they behave exactly as all other objects shipped with this package. Essentially, only 2 steps are needed: Create a new class that inherits from MdObj . There are many examples available in this package on how to do that. Especially interesting examples are the tables as well as images, but also HideNav , HideToc and NavTabs as they show how to use settings. Register the new class. This is easily done using the register_md decorator, which takes as its only argument the name under which the new class should be registered. After this is done, all classes are available as attributes on a Page as well as in Page.md with page_info parameters pre-set with the appropriate PageInfo object.","title":"Creating custom plugins"},{"location":"usage/sidebar/","text":"Code docs/staging/sidebar.py from mkreports import Report def use_sidebar ( report : Report ) -> None : p = report . page ( \"usage/sidebar\" , truncate = True ) p . CollapsedCodeFile ( __file__ ) p . H1 ( \"Sidebars\" ) p . P ( \"\"\" We can hide the table of contents sidebar as well as the navigation bar. On this page, we only hide the ToC. When hiding the navigation bar, you should think about setting navigation tabs as well (otherwise there is no direct navigation option. Below a code block showing how to hide the ToC, Nav and set the navigations tabs. \"\"\" ) p . HideToc () p . Code ( \"\"\" p.HideToc() p.HideNav() p.NavTabs() \"\"\" ) Sidebars We can hide the table of contents sidebar as well as the navigation bar. On this page, we only hide the ToC. When hiding the navigation bar, you should think about setting navigation tabs as well (otherwise there is no direct navigation option. Below a code block showing how to hide the ToC, Nav and set the navigations tabs. p . HideToc () p . HideNav () p . NavTabs ()","title":"Sidebar"},{"location":"usage/sidebar/#sidebars","text":"We can hide the table of contents sidebar as well as the navigation bar. On this page, we only hide the ToC. When hiding the navigation bar, you should think about setting navigation tabs as well (otherwise there is no direct navigation option. Below a code block showing how to hide the ToC, Nav and set the navigations tabs. p . HideToc () p . HideNav () p . NavTabs ()","title":"Sidebars"},{"location":"usage/tables/","text":"Different ways of handling tables Code docs/staging/tables.py import pandas as pd from mkreports import Report , md from plotnine.data import mtcars def use_tables ( report : Report ) -> None : \"\"\" Show all the different ways on how we can work with tables. \"\"\" ex_table = pd . DataFrame ( [ { \"name\" : \"Alfred\" , \"age\" : 30 , \"hair\" : \"red\" , \"married\" : True }, { \"name\" : \"Beate\" , \"age\" : 50 , \"hair\" : \"brown\" , \"married\" : False }, { \"name\" : \"Caro\" , \"age\" : 7 , \"hair\" : \"green\" , \"married\" : False , }, ] ) ex_table [ \"hair\" ] = pd . Categorical ( ex_table . hair ) p = report . page ( \"usage/tables.md\" , truncate = True ) p . H1 ( \"Different ways of handling tables\" ) p . CollapsedCodeFile ( __file__ ) p . Raw ( \"\"\" Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. \"\"\" ) with p . H2 ( \"Markdown tables\" ): p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) with p . H2 ( \"DataTable javascript library\" ): p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" An example with buttons for downloading and printing of the table. \"\"\" ) p . DataTable ( ex_table , downloads = True ) with p . H2 ( \"Tabulator javascript library\" ): p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . P ( \"\"\" An example showing download buttons for export to csv, json or excel. \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True , downloads = True , ) with p . H2 ( \"Notes\" ): p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" ) Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. Markdown tables Content Code Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. name mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 docs/staging/tables.py 39 40 41 42 43 44 45 46 p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) DataTable javascript library Content Code Here the same table, but displayed using the DataTables plugin. With this, we get automatic paging, searching as well as sorting by columns. Header filters Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. A numeric column gets a range selector A categorical or boolean column a dropdown selection Any other column a text-field. Download buttons An example with buttons for downloading and printing of the table. docs/staging/tables.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" An example with buttons for downloading and printing of the table. \"\"\" ) p . DataTable ( ex_table , downloads = True ) $(document).ready( function () { var myTable = $('#datatable_id-0').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Mpg\"}, {\"title\": \"Cyl\"}, {\"title\": \"Disp\"}, {\"title\": \"Hp\"}, {\"title\": \"Drat\"}, {\"title\": \"Wt\"}, {\"title\": \"Qsec\"}, {\"title\": \"Vs\"}, {\"title\": \"Am\"}, {\"title\": \"Gear\"}, {\"title\": \"Carb\"}], \"ajax\": \"../tables_store/datatable-ca9b6f052f673e1d46f468ebb1ccc5d1.json\"}); } ); $(document).ready( function () { var myTable = $('#datatable_id-1').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Age\"}, {\"title\": \"Hair\"}, {\"title\": \"Married\"}], \"ajax\": \"../tables_store/datatable-580c4149445c9b58b5740c532e20a5a0.json\"}); yadcf.init(myTable, [{\"column_number\": 0, \"filter_type\": \"text\"}, {\"column_number\": 1, \"filter_type\": \"range_number\"}, {\"column_number\": 2, \"filter_type\": \"select\"}, {\"column_number\": 3, \"filter_type\": \"select\"}]); } ); $(document).ready( function () { var myTable = $('#datatable_id-2').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Age\"}, {\"title\": \"Hair\"}, {\"title\": \"Married\"}], \"buttons\": [\"copy\", \"csv\", \"excel\", \"pdf\", \"print\"], \"dom\": \"<lfr>t<Bp>\", \"ajax\": \"../tables_store/datatable-580c4149445c9b58b5740c532e20a5a0.json\"}); } ); Tabulator javascript library Content Code This time, we use the Tabulator library. A library with a lot of interesting functionality. Header filters We also can enable header filtering. For the datatypes numeric boolean categorical str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are Input filter for the names Range filter with min and max for age Select dropdown for hair color and checkbox for marital status Download buttons An example showing download buttons for export to csv, json or excel. to CSV to JSON to XLSX docs/staging/tables.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . P ( \"\"\" An example showing download buttons for export to csv, json or excel. \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True , downloads = True , ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"title\": \"name\"}, {\"field\": \"mpg\", \"title\": \"mpg\"}, {\"field\": \"cyl\", \"title\": \"cyl\"}, {\"field\": \"disp\", \"title\": \"disp\"}, {\"field\": \"hp\", \"title\": \"hp\"}, {\"field\": \"drat\", \"title\": \"drat\"}, {\"field\": \"wt\", \"title\": \"wt\"}, {\"field\": \"qsec\", \"title\": \"qsec\"}, {\"field\": \"vs\", \"title\": \"vs\"}, {\"field\": \"am\", \"title\": \"am\"}, {\"field\": \"gear\", \"title\": \"gear\"}, {\"field\": \"carb\", \"title\": \"carb\"}], \"ajaxURL\": \"../tables_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); var table = new Tabulator('#tabulator_id-1', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"age\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Age\"}, {\"field\": \"hair\", \"headerFilter\": \"select\", \"headerFilterParams\": {\"values\": [\"\", \"brown\", \"green\", \"red\"]}, \"title\": \"Hair\"}, {\"field\": \"married\", \"headerFilter\": \"tickCross\", \"formatter\": \"tickCross\", \"headerFilterParams\": {\"tristate\": true}, \"title\": \"Married\"}], \"ajaxURL\": \"../tables_store/tabulator-75b468c8a8bcf5fff9d211e88d0e6972.json\"}); var table = new Tabulator('#tabulator_id-2', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"age\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Age\"}, {\"field\": \"hair\", \"headerFilter\": \"select\", \"headerFilterParams\": {\"values\": [\"\", \"brown\", \"green\", \"red\"]}, \"title\": \"Hair\"}, {\"field\": \"married\", \"headerFilter\": \"tickCross\", \"formatter\": \"tickCross\", \"headerFilterParams\": {\"tristate\": true}, \"title\": \"Married\"}], \"ajaxURL\": \"../tables_store/tabulator-75b468c8a8bcf5fff9d211e88d0e6972.json\"}); //trigger download of data.csv file $(\"#csv_down_id-0\").click(function(){ table.download(\"csv\", \"data.csv\"); }); //trigger download of data.json file $(\"#json_down_id-0\").click(function(){ table.download(\"json\", \"data.json\"); }); //trigger download of data.xlsx file $(\"#xslx_down_id-0\").click(function(){ table.download(\"xlsx\", \"data.xlsx\", {sheetName:\"data\"}); }); Notes Content Code Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the str funtion is called. If this is not ok, please transform the table columns accordingly. docs/staging/tables.py 133 134 135 136 137 138 139 140 141 p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" )","title":"Tables"},{"location":"usage/tables/#different-ways-of-handling-tables","text":"Code docs/staging/tables.py import pandas as pd from mkreports import Report , md from plotnine.data import mtcars def use_tables ( report : Report ) -> None : \"\"\" Show all the different ways on how we can work with tables. \"\"\" ex_table = pd . DataFrame ( [ { \"name\" : \"Alfred\" , \"age\" : 30 , \"hair\" : \"red\" , \"married\" : True }, { \"name\" : \"Beate\" , \"age\" : 50 , \"hair\" : \"brown\" , \"married\" : False }, { \"name\" : \"Caro\" , \"age\" : 7 , \"hair\" : \"green\" , \"married\" : False , }, ] ) ex_table [ \"hair\" ] = pd . Categorical ( ex_table . hair ) p = report . page ( \"usage/tables.md\" , truncate = True ) p . H1 ( \"Different ways of handling tables\" ) p . CollapsedCodeFile ( __file__ ) p . Raw ( \"\"\" Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed. \"\"\" ) with p . H2 ( \"Markdown tables\" ): p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False )) with p . H2 ( \"DataTable javascript library\" ): p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" An example with buttons for downloading and printing of the table. \"\"\" ) p . DataTable ( ex_table , downloads = True ) with p . H2 ( \"Tabulator javascript library\" ): p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . P ( \"\"\" An example showing download buttons for export to csv, json or excel. \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True , downloads = True , ) with p . H2 ( \"Notes\" ): p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" ) Conveying information with tables is very important for any type of report. Standard tables in markdown format can be very useful for this for limited amout of data, but for larger tables more sophisticated libraries are needed.","title":"Different ways of handling tables"},{"location":"usage/tables/#markdown-tables","text":"Content Code Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. name mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 docs/staging/tables.py 39 40 41 42 43 44 45 46 p . Raw ( \"\"\" Below an example of a regular markdown table. As it is very wide, horizontal scrolling is enabled by default. In addition, the number of rows is limited to 10 as there is no automatic paging available. \"\"\" ) p . add ( md . Table ( pd . DataFrame ( mtcars ) . head ( 10 ), index = False ))","title":"Markdown tables"},{"location":"usage/tables/#datatable-javascript-library","text":"Content Code Here the same table, but displayed using the DataTables plugin. With this, we get automatic paging, searching as well as sorting by columns.","title":"DataTable javascript library"},{"location":"usage/tables/#header-filters","text":"Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. A numeric column gets a range selector A categorical or boolean column a dropdown selection Any other column a text-field.","title":"Header filters"},{"location":"usage/tables/#download-buttons","text":"An example with buttons for downloading and printing of the table. docs/staging/tables.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 p . Raw ( \"\"\" Here the same table, but displayed using the [DataTables](https://datatables.net/) plugin. With this, we get automatic paging, searching as well as sorting by columns. \"\"\" ) # and as a DataTable p . DataTable ( pd . DataFrame ( mtcars )) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" Below a DataTable example with column filters in the header. The header in use is determined by the column type of the pandas table used for display. - A numeric column gets a range selector - A categorical or boolean column a dropdown selection - Any other column a text-field. \"\"\" ) p . DataTable ( ex_table , add_header_filters = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" An example with buttons for downloading and printing of the table. \"\"\" ) p . DataTable ( ex_table , downloads = True ) $(document).ready( function () { var myTable = $('#datatable_id-0').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Mpg\"}, {\"title\": \"Cyl\"}, {\"title\": \"Disp\"}, {\"title\": \"Hp\"}, {\"title\": \"Drat\"}, {\"title\": \"Wt\"}, {\"title\": \"Qsec\"}, {\"title\": \"Vs\"}, {\"title\": \"Am\"}, {\"title\": \"Gear\"}, {\"title\": \"Carb\"}], \"ajax\": \"../tables_store/datatable-ca9b6f052f673e1d46f468ebb1ccc5d1.json\"}); } ); $(document).ready( function () { var myTable = $('#datatable_id-1').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Age\"}, {\"title\": \"Hair\"}, {\"title\": \"Married\"}], \"ajax\": \"../tables_store/datatable-580c4149445c9b58b5740c532e20a5a0.json\"}); yadcf.init(myTable, [{\"column_number\": 0, \"filter_type\": \"text\"}, {\"column_number\": 1, \"filter_type\": \"range_number\"}, {\"column_number\": 2, \"filter_type\": \"select\"}, {\"column_number\": 3, \"filter_type\": \"select\"}]); } ); $(document).ready( function () { var myTable = $('#datatable_id-2').DataTable({\"scrollX\": \"true\", \"columns\": [{\"title\": \"Name\"}, {\"title\": \"Age\"}, {\"title\": \"Hair\"}, {\"title\": \"Married\"}], \"buttons\": [\"copy\", \"csv\", \"excel\", \"pdf\", \"print\"], \"dom\": \"<lfr>t<Bp>\", \"ajax\": \"../tables_store/datatable-580c4149445c9b58b5740c532e20a5a0.json\"}); } );","title":"Download buttons"},{"location":"usage/tables/#tabulator-javascript-library","text":"Content Code This time, we use the Tabulator library. A library with a lot of interesting functionality.","title":"Tabulator javascript library"},{"location":"usage/tables/#header-filters_1","text":"We also can enable header filtering. For the datatypes numeric boolean categorical str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are Input filter for the names Range filter with min and max for age Select dropdown for hair color and checkbox for marital status","title":"Header filters"},{"location":"usage/tables/#download-buttons_1","text":"An example showing download buttons for export to csv, json or excel. to CSV to JSON to XLSX docs/staging/tables.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 p . Raw ( \"\"\" This time, we use the [Tabulator](http://tabulator.info) library. A library with a lot of interesting functionality. \"\"\" ) p . Tabulator ( pd . DataFrame ( mtcars ), add_header_filters = False , prettify_colnames = False ) with p . H3 ( \"Header filters\" ) . ctx ( \"nocode\" ): p . Raw ( \"\"\" We also can enable header filtering. For the datatypes - numeric - boolean - categorical - str default filter options have been defined. Below we create a table with various different data types to show these functions. The applied filters are - Input filter for the names - Range filter with min and max for age - Select dropdown for hair color - and checkbox for marital status \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True ) with p . H3 ( \"Download buttons\" ) . ctx ( \"nocode\" ): p . P ( \"\"\" An example showing download buttons for export to csv, json or excel. \"\"\" ) p . Tabulator ( ex_table , add_header_filters = True , prettify_colnames = True , downloads = True , ) var table = new Tabulator('#tabulator_id-0', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"title\": \"name\"}, {\"field\": \"mpg\", \"title\": \"mpg\"}, {\"field\": \"cyl\", \"title\": \"cyl\"}, {\"field\": \"disp\", \"title\": \"disp\"}, {\"field\": \"hp\", \"title\": \"hp\"}, {\"field\": \"drat\", \"title\": \"drat\"}, {\"field\": \"wt\", \"title\": \"wt\"}, {\"field\": \"qsec\", \"title\": \"qsec\"}, {\"field\": \"vs\", \"title\": \"vs\"}, {\"field\": \"am\", \"title\": \"am\"}, {\"field\": \"gear\", \"title\": \"gear\"}, {\"field\": \"carb\", \"title\": \"carb\"}], \"ajaxURL\": \"../tables_store/tabulator-c8469972d60cd61d98262704e068f4e9.json\"}); var table = new Tabulator('#tabulator_id-1', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"age\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Age\"}, {\"field\": \"hair\", \"headerFilter\": \"select\", \"headerFilterParams\": {\"values\": [\"\", \"brown\", \"green\", \"red\"]}, \"title\": \"Hair\"}, {\"field\": \"married\", \"headerFilter\": \"tickCross\", \"formatter\": \"tickCross\", \"headerFilterParams\": {\"tristate\": true}, \"title\": \"Married\"}], \"ajaxURL\": \"../tables_store/tabulator-75b468c8a8bcf5fff9d211e88d0e6972.json\"}); var table = new Tabulator('#tabulator_id-2', {\"layout\": \"fitDataTable\", \"pagination\": true, \"paginationSize\": 10, \"paginationSizeSelector\": true, \"columns\": [{\"field\": \"name\", \"headerFilter\": \"input\", \"title\": \"Name\"}, {\"field\": \"age\", \"width\": 80, \"headerFilter\": minMaxFilterEditor, \"headerFilterFunc\": minMaxFilterFunction, \"headerFilterLiveFilter\": false, \"title\": \"Age\"}, {\"field\": \"hair\", \"headerFilter\": \"select\", \"headerFilterParams\": {\"values\": [\"\", \"brown\", \"green\", \"red\"]}, \"title\": \"Hair\"}, {\"field\": \"married\", \"headerFilter\": \"tickCross\", \"formatter\": \"tickCross\", \"headerFilterParams\": {\"tristate\": true}, \"title\": \"Married\"}], \"ajaxURL\": \"../tables_store/tabulator-75b468c8a8bcf5fff9d211e88d0e6972.json\"}); //trigger download of data.csv file $(\"#csv_down_id-0\").click(function(){ table.download(\"csv\", \"data.csv\"); }); //trigger download of data.json file $(\"#json_down_id-0\").click(function(){ table.download(\"json\", \"data.json\"); }); //trigger download of data.xlsx file $(\"#xslx_down_id-0\").click(function(){ table.download(\"xlsx\", \"data.xlsx\", {sheetName:\"data\"}); });","title":"Download buttons"},{"location":"usage/tables/#notes","text":"Content Code Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the str funtion is called. If this is not ok, please transform the table columns accordingly. docs/staging/tables.py 133 134 135 136 137 138 139 140 141 p . Raw ( \"\"\" Internally, the tables are serialized to json so that they can be displayed in the web-browser. For any types that are non-native to json (e.g. Path-instances), as a default handler the `str` funtion is called. If this is not ok, please transform the table columns accordingly. \"\"\" )","title":"Notes"}]}